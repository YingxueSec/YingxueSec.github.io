<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>第13章 异步 JavaScript | Jackhou Blog</title><meta name="keywords" content="《JavaScript权威指南》,JavaScript"><meta name="author" content="Jack hou"><meta name="copyright" content="Jack hou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="第13章 异步 JavaScript"><meta name="application-name" content="第13章 异步 JavaScript"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="第13章 异步 JavaScript"><meta property="og:url" content="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/index.html"><meta property="og:site_name" content="Jackhou Blog"><meta property="og:description" content="Some computer programs, such as scientific simulations and machine learning models, are compute-bound: they run continuously, without pause, until"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover3.jpg"><meta property="article:author" content="Jack hou"><meta property="article:tag" content="Jackhou, blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover3.jpg"><meta name="description" content="Some computer programs, such as scientific simulations and machine learning models, are compute-bound: they run continuously, without pause, until"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.houyanbin.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Jack hou","link":"链接: ","source":"来源: Jackhou Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Jackhou Blog',
  title: '第13章 异步 JavaScript',
  postAI: '',
  pageFillDescription: '13.1 Asynchronous Programming with Callbacks, 13.1.1 Timers, 13.1.2 Events, 13.1.3 Network Events, 13.1.4 Callbacks and Events in Node, 13.2 Promises, IMPORTANT, 13.2.1 Using Promises, HANDLING ERRORS WITH PROMISES, PROMISE TERMINOLOGY, 13.2.2 Chaining Promises, 13.2.3 Resolving Promises, 13.2.4 More on Promises and Errors, THE CATCH AND FINALLY METHODS, RETURNING FROM A PROMISE CALLBACK, 13.2.5 Promises in Parallel, 13.2.6 Making Promises, PROMISES BASED ON OTHER PROMISES, PROMISES BASED ON SYNCHRONOUS VALUES, PROMISES FROM SCRATCH, 13.2.7 Promises in Sequence, 13.3 async and await, 13.3.1 await Expressions, 13.3.2 async Functions, 13.3.3 Awaiting Multiple Promises, 13.3.4 Implementation Details, 13.4 Asynchronous Iteration, 13.4.1 The forx2Fawait Loop, 13.4.2 Asynchronous Iterators, 13.4.3 Asynchronous Generators, 13.4.4 Implementing Asynchronous Iterators, 13.5 Summary一些计算机程序如科学模拟和机器学习模型是计算受限的它们不停地运行没有停顿直到计算出结果然而值得注意的是现实世界中的大多数计算机程序都是异步的这意味着在等待数据到达或某些事件发生时它们常常不得不停止计算浏览器中的程序是典型地事件驱动的这意味着它们在实际执行任何操作之前等待用户单击或点击基于的服务器通常在执行任何操作之前等待客户机请求通过网络到达这种异步编程在中很常见本章将介绍三种重要的语言特性它们有助于简化异步代码的使用是中的新特性是表示目前不可用结果的异步操作对象关键字和是在中引入的它们提供了新的语法通过允许将基于的代码构造成同步的方式来简化异步编程最后在中引入了异步迭代器和循环允许使用简单的同步循环处理异步事件流具有讽刺意味的是尽管为处理异步代码提供了这些强大的特性但核心语言本身并没有异步的特性因此为了演示和我们将首先使用客户端和服务器端来解释浏览器和的一些异步特性可以在第章和第章中了解更多关于客户端和服务器端的知识在最基本的层次上中的异步编程是通过回调来完成的回调是一个你编写的函数然后传递给其他函数当满足某些条件或发生某些异步事件时其他函数调用回调你的函数提供的回调函数的调用会通知你条件或事件有时调用将提供包含额外细节的函数实参通过一些具体的示例会更容易理解下面的子节将演示使用客户端和的各种形式的基于回调的异步编程当希望在经过一定时间后运行某些代码是一种最简单的异步类型正如我们在中看到的可以通过函数来做到这一点的第一个实参是一个函数第二个实参是一个以毫秒为单位的时间间隔前面的代码中在调用后毫秒分钟后将调用一个假定的函数是程序定义的一个回调函数而是用于注册回调函数并指定应该在什么异步条件下调用它的函数调用一次指定的回调函数不传递任何实参然后忘记它如果正在编写一个检查更新的函数可能希望它重复运行可以使用来代替客户端程序几乎都是由事件驱动的它们通常不等待用户执行某种预定的计算而是等待用户执行某些操作然后响应用户的操作当用户按下键盘上的键移动鼠标单击鼠标按钮或触摸触摸屏设备时浏览器会发生事件事件驱动的程序在指定的上下文中为指定类型的事件注册回调函数并且只要指定事件发生浏览器就会调用这些函数这些回调函数称为事件句柄或事件监听器并且使用注册在此示例中假设是我们在某个地方实现的回调函数调用返回一个对象该对象表示网页中的单个指定元素我们在该元素上调用来注册我们的回调然后的第一个实参是一个字符串该字符串指定了事件的类型在这种情况下是单击鼠标或触摸屏如果用户单击或点击网页上的特定元素则浏览器将调用我们的回调函数并传递一个包含事件详细信息例如时间和鼠标指针坐标的对象编程中异步的另一个常见来源是网络请求在浏览器中运行的可以使用以下代码从服务器获取数据客户端代码可以使用类以及回调函数来发出请求并在服务器响应时异步处理这里定义的函数我们可以假设在提到的函数使用了该函数发出请求并定义事件处理程序该事件处理程序将在收到服务器的响应或超时或其他异常导致请求失败时被调用请注意上面的代码示例未像前面的示例那样调用对于大多数包括此可以通过在生成事件的对象上调用并将事件的名称与回调函数一起传递来定义事件处理程序不过通常也可以通过将单个事件侦听器直接分配给对象的属性来注册它这就是我们在此示例代码中所做的将函数分配给和属性按照惯例此类事件侦听器属性的名称始终以开头是更灵活的技术因为它允许多个事件处理程序但是如果确定没有其他代码需要为相同的对象和事件类型注册一个侦听器则只需将适当的属性设置为回调会更简单此示例代码中关于函数的另一点注意事项是由于它发出异步请求因此无法同步返回调用者感兴趣的值当前版本号相反调用者传递了一个回调函数当结果准备就绪或发生异常时调用在这种情况下调用方提供了一个回调函数该函数需要两个参数如果正常工作则会使用为第一个实参和版本号为第二个实参调用回调函数或者如果发生异常则会在第一个实参中带有异常详细信息而在第二个参数中使用现在我们已经见过了客户端和服务器端环境中基于回调和基于事件的异步编程的示例我们接着介绍这是一种旨在简化异步编程的核心语言特性是描述异步计算结果的对象该结果可能准备好或尚未准备好故意对此含糊其词无法同步获取的值只能要求在值准备好时调用回调函数如果要像上一节中的函数那样定义异步但想使其基于则省略参数而返回对象然后调用者可以在此对象上注册一个或多个回调并且在异步计算完成后将调用它们因此最简单的说只是使用回调的另一种方式但是使用它有实际的好处基于回调的异步编程的一个真正的问题是通常在回调内部嵌套多层回调并且代码行缩进程度很高以至于很难阅读允许将这种嵌套的回调作为更线性的链重新表达该链往往更易于阅读和推理回调的另一个问题是它们会使处理异常变得困难如果异步函数或异步调用的回调引发异常则该异常无法传播回异步操作的发起者这是关于异步编程的基本事实它破坏了异常处理替代方法是使用回调实参和返回值来精心跟踪和传播异常但这很繁琐且难以正确处理通过标准化处理异常的方式以及为异常通过链正确传播的方式提供帮助请注意表示单个异步计算的未来结果但是它不能用于表示重复的异步计算例如在本章的后面我们将写一个基于的函数替代方法但是我们不能使用来代替因为该函数会反复调用回调函数而并不是同样我们可以使用代替对象的事件处理程序因为该回调仅被调用一次但是我们通常不会使用来代替按钮对象的事件处理程序因为我们通常希望允许用户多次单击按钮接下来的小节将解释术语并演示的基本用法展示如何将链接起来演示如何创建自己的基于的一开始似乎很简单并且的基本用例实际上也是简单明了的但是除了最简单的用例之外它们还会使其他任何事情变得令人困惑对于异步编程是一个强大的习惯用法但是需要深刻理解它们才能正确自信地使用它们但是它值得花时间来深入理解我建议仔细阅读这一长篇章随着核心语言中的出现浏览器已经开始实现基于的在上一节中我们实现了一个函数该函数发出一个异步请求并将响应的主体作为字符串传递给指定的回调函数想象一下该函数的一个变体它可以解析主体响应的形式为并返回而不是接受回调参数我们将在本章稍后实现函数但现在让我们看一下如何使用返回功能程序函数对指定的启动一个异步请求当该请求待定时它返回一个对象对象定义了实例方法我们没有将回调函数直接传递给而是将其传递给方法当响应时该响应的主体将解析为并将所解析的结果值传给我们传递给的回调函数可以将方法视为回调注册方法例如用于在客户端中注册事件处理程序的方法如果多次调用对象的方法则在完成的计算后将调用指定的每个函数但是与许多事件侦听器不同表示单个计算并且注册的每个函数仅被调用一次值得注意的是传递给的函数是异步调用的即使调用时异步计算已经完成在简单的语法级别上方法是独有的特性编码中习惯于将直接跟随返回的函数而无需将对象分配给变量的中间步骤常用带有动词命名返回的函数和使用结果的函数这些常用语使代码特别容易阅读异步操作尤其是涉及网络的异步操作通常会以多种方式失败并且必须编写健壮的代码来处理不可避免地会发生的异常对于我们可以通过将第二个函数传递给方法来实现描述在对象创建之后发生的异步计算的未来结果由于计算是在对象返回给我们之后执行的因此该计算无法传统地返回值或引发我们可以捕获的异常我们传递给的函数提供了替代方案当同步计算正常完成时它仅将其结果返回给其调用者当基于的异步计算正常完成时它将其结果传递给的第一个实参函数当同步计算中出现问题时它将引发一个异常该异常会沿调用堆栈传播直到有一个子句来处理它为止当异步计算运行时它的调用者不再在堆栈上因此如果出现问题则根本不可能将异常抛出给调用者而基于的异步计算将异常通常是某种对象尽管这不是必需的传递给的第二个函数因此在上面的代码中如果正常运行它将其结果传递给如果出现异常用户未登录服务器关闭用户的连接断开请求超时等则会将对象传递给实践中很少有两个函数传递给在处理时有一种更好更常用的异常处理方式为了理解它首先考虑如果正常完成但中发生异常该怎么办当返回时该回调函数将异步调用因此它也是异步的并且无法有意义地引发异常因为调用堆栈上没有代码可以处理该异常如下所示处理此代码中异常的更常用方式使用此代码的正常结果仍会传递给但是或中的任何异常包括抛出的任何异常都将传递给调用第一个实参为空指定的异常处理函数为第二个实参方法只是其简写在下一节中讨论链时我们将对和这个处理异常常用方法作更多的说明在我们进一步讨论之前需要暂停定义一些术语现实生活中我们讨论下人类的诺言我们说信守或违背诺言在讨论时用已兑现和已拒绝想象一下已经调用了的方法并向其传递了两个回调函数当调用第一个回调那么我们说已兑现当调用第二个回调我们则说已被拒绝如果一个既不是已兑现也不是已拒绝那么它就是待定一旦已兑现或已拒绝我们就说它已敲定请注意一个永远不会同时已兑现和已拒绝一旦敲定就永远不会从已兑现变为已拒绝反之亦然记住我们在本节开始时如何定义是描述异步计算结果的对象重要的是要记住不仅仅是注册在某些异步代码完成时运行的回调的抽象方式它们还描述了异步代码的结果如果异步代码正常运行并且已兑现那么该结果实质上就是代码的返回值而且如果异步代码无法正常完成并且已拒绝那么结果将是对象或其他不是异步的代码可能会抛出的值任何已敲定的都有与其相关的值并且该值不会改变如果已兑现则该值是一个返回值该值将传递给注册为第一个实参的回调函数如果已拒绝则该值是某种异常该异常会传递给使用或的第二个实参注册的回调函数我希望对术语保持精确的原因是还可以被决议将已决议状态与已兑现状态或已敲定状态混淆是很容易的但是三者都不完全相同理解已决议状态是深入了解的关键之一在下面讨论了链之后我将再次介绍它的最重要的好处之一是它们提供了一种自然的方式来表达一系列异步操作表示方法调用的线性链而不必将每个操作嵌套在前一个回调中例如一个假设的链此代码表明了链如何简化一系列异步操作我们不会讨论这个特殊的链但是我们将继续探索使用链发出请求的想法在本章的前面我们看到了对象该对象用于在中发出请求这个奇怪命名的对象具有一个旧且笨拙的并且在很大程度上已被较新的基于的所取代以最简单的形式这个新的只是函数给它传递一个然后返回一个当开始收到响应并且状态和标头可用时这个已兑现当返回的已兑现时它将对象传递给传递给方法的函数此响应对象可以访问请求状态和标头并且还定义了诸如和之类的方法这些方法可以分别以文本和的形式访问响应的正文但是尽管最初的已兑现但响应的主体可能尚未到达因此这些用于访问响应正文的和方法本身返回这是使用和方法获取响应正文的一种简单方法这是一种没经验的使用方式因为我们像回调一样嵌套了它们这违背了目的首选常用方法是在顺序链中使用其代码如下所示让我们看一下这段代码中的方法调用忽略传递给方法的参数当像这样在单个表达式中调用多个方法时我们将其称为方法链我们知道函数返回一个对象并且可以看到该链中的第一个作为返回的对象的方法调用但是链中还有第二个这意味着方法的第一次调用本身一定返回有时当一个设计为使用这种方法链接时只有一个对象并且该对象的每个方法都返回该对象本身以便于链接但是这不是的工作方式当我们编写一系列的调用时我们并未在单个对象上注册多个回调而是对方法的每次调用都会返回一个新的对象在传递给的函数完成之前新的对象不会被兑现让我们回到上面原始链的简化形式如果我们在其他地方定义传递给调用的函数则可以将代码重构为如下形式让我们详细介绍这段代码在第一行使用调用它针对该发起请求并返回我们将这个请求称为将称为在第二行我们调用的方法并传递在已兑现时要调用的函数方法将回调函数存储在某个位置然后返回一个新的我们将在这一步返回的新称为并且我们说当被调用时开始在第三行我们调用的方法并传递在已兑现时要调用的函数这个方法会记住我们的回调并返回另一个我们说是在调用时开始的我们可以将最新的称为但是我们并不需要它的名称因为我们根本不会使用它最初执行表达式时前三个步骤都是同步发生的现在在第步中启动的请求通过发送时我们有了异步暂停最终响应开始到达调用的异步部分将状态和标头包装在对象中并以该对象作为值来兑现已兑现后其值对象将传递到我们的函数开始以对象作为输入此任务的工作是获得响应主体转化为对象假设正常完成并且能够解析响应主体以生成对象此对象用于兑现兑现的值在传递给函数时成为的输入现在第三个任务以某种未指定的方式向用户显示数据当完成时假设它正常完成则将被兑现但是因为我们从未对做任何事情所以当敲定时什么也没有发生并且异步计算链到此结束在上一部分中用列表解释链时我们讨论了和但是实际上也涉及第四个对象并且这为我们带来重要的讨论什么是的已决议状态请记住返回一个对象当其已兑现时它将对象传递给我们注册的回调函数此对象具有和其他方法以各种形式请求响应的主体但是由于主体可能尚未到达因此这些方法必须返回对象在我们一直在研究的示例中调用方法并返回其值这是第四个对象它是函数的返回值让我们以冗长且非常用方式再次重写代码使回调和明确化为了使链有效地工作的输出必须成为的输入在此示例中我们在这里考虑的是的输入是从所获取的的主体将其解析为对象但是正如我们刚刚讨论的那样回调的返回值不是对象而是该对象的这似乎有矛盾但并非如此当已兑现时将调用并且开始当已兑现时被调用开始但是仅仅因为被调用时开始可这并不意味着必须在返回时结束毕竟是关于管理异步任务的如果是异步的在本例中为异步则在回调返回时该任务将不会完成现在我们准备讨论最后的细节需要了解这些才能真正掌握当将回调传递给方法时返回并安排在以后的某个时间异步调用调执行一些计算并返回值当回调返回时用值决议当使用不是本身的值决议时立即用该值兑现因此如果返回一个非则返回值成为的值则已兑现并且任务完成但是如果返回值本身是一个则已决议但尚未兑现在此阶段直到敲定才能敲定如果已兑现则将被兑现为相同的值如果已拒绝则将因相同的原因而被拒绝这就是一个的已决议状态的含义已与另一个关联或锁定我们尚不知道是已兑现还是拒绝但是我们的回调对此不再具有任何控制权是已决议的从这一方面来说它命运现在完全取决于会发生什么让我们回到我们的示例中当返回时已决议但是已决议与已兑现并不相同因此尚未开始当响应的全文可用时方法可以对其进行解析并使用该解析后的值来已兑现当已兑现时也会使用相同的已解析值自动已兑现此时已解析的对象将传递给然后开始这可能是最难理解的部分之一可能需要多次阅读本节图以可视形式显示了该过程可能有助于对其进行说明在本章的前面我们看到可以将第二个回调函数传递给方法并且如果被拒绝则将调用该第二个函数发生这种情况时第二个回调函数的实参是一个值通常是一个对象它表示拒绝的原因我们还了解到将两个回调传递给方法并不常见甚至是单例的相反通常通过向链添加方法调用来处理与相关的异常现在我们已经检查了链我们可以返回异常处理并更详细地讨论它在开始讨论之前我想强调指出进行异步编程时仔细的异常处理非常重要使用同步代码如果省略了异常处理代码则至少会得到一个异常和一个堆栈跟踪可用于找出问题所在对于异步代码未处理的异常通常不会报告异常可以静默发生从而使调试更加困难好消息是使用方法可以更轻松地处理的异常可以处理异常使用为第一个实参而异常处理回调为第二个实参的方法只是这种调用的一种简便写法给定和回调以下两行代码是等效的首选速记因为它更简单并且名称与异常处理语句中的子句匹配正如我们所讨论的普通例外不适用于异步代码的方法是一种适用于异步代码的替代方法当同步代码中出现问题时我们使调用堆栈冒泡描述一个异常直到找到块为止对于异步的链则是向链下滴直到找到调用为止在中对象还定义了一个方法其目的类似于语句中的子句如果将调用添加到链中那么的调用者的敲定的时候传递给的回调将被调用如果已兑现或已拒绝则将调用回调并且它不会再作为实参传递因此无法确定它是已兑现还是已拒绝但是无论哪种情况如果都需要运行某种清理代码例如关闭打开的文件或网络连接则回调是实现此目的的理想方法与和一样返回一个新的对象回调的返回值通常被忽略返回的通常将以调用的相同的值来决议或拒绝但是如果回调引发异常则返回的以该异常值拒绝我们在上一节中研究的代码没有任何异常处理现在使用更可行的代码版本进行更正让我们通过发生异常情况情况来分析此代码我们将使用之前使用的命名方案是调用返回的是第一个调用返回的而是我们传递给该的回调是第二个调用返回的而是我们传递给该调用的回调最后是我们传递给的回调该调用返回一个但我们不需要按名称引用它第一个可能失败的是请求本身如果网络连接断开或由于某些其他原因而无法发出请求则将被对象拒绝我们没有将异常处理回调函数作为调用的第二个实参传递因此同样会被相同的对象拒绝如果将异常处理程序传递给第一个调用则将调用该异常处理程序并且如果该异常处理程序正常返回伴随处理的返回值变为已决议和或或已兑现但是出于相同的原因被拒绝然后被拒绝此时将调用异常处理回调并在其中运行特定于的代码代码失败的另一种方式是如果我们的请求返回或另一个异常这些是有效的响应因此调用不会将其视为异常在对象中封装了一个并用该对象已兑现从而导致被调用我们在中的代码检查对象的属性以检测它没有收到正常的响应并通过简单地返回来处理这种情况因为此返回值不是所以它立即已兑现并使用该值调用我们在中的代码显式检查并处理错误值并向用户显示不同的结果在这种情况下我们将异常情况视为非异常并在不使用异常处理程序的情况下对其进行处理如果我们获得正常的响应代码但标头设置不正确则中会发生更严重的异常我们的代码需要一个格式的响应因此如果服务器发送给我们的是或纯文本那么我们将会遇到问题包含用于检查标头的代码如果标头错误则将其视为不可恢复的问题并引发当传递给或的回调引发一个值时作为调用的返回的将被该抛出的值拒绝在这种情况下中的代码引发导致带有对象的一起被拒绝由于我们没有为指定异常处理程序因此也将被拒绝将不会被调用并且将传递给后者具有显式检查和处理此类异常的代码关于此代码有些得注意首先请注意用常规的同步语句引发的异常对象最终会通过链中的方法调用进行异步捕获这清楚表明为什么与将第二个实参传递给相比更偏向使用这种速记方法以及为什么习惯以调用结束链在我们结束异常处理主题之前我想指出尽管习惯于在每个链中添加一个来清理或至少记录日志该链中发生的任何异常但是在链中的其他位置使用也完全有效如果链中的某一阶段可能因异常而失败并且该异常是某种可恢复的异常并且该异常不会阻止链的其余部分运行则可以在链中插入调用代码可能如下所示请记住仅当前一阶段的回调引发异常时才会调用传递给的回调如果该回调正常返回则将跳过回调并且前一个回调的返回值将成为下一个回调的输入还请记住回调不仅用于异常报告而且用于异常处理并从异常中恢复将异常传递给回调后它将停止沿链传播回调可以引发新的异常但是如果它正常返回则该返回值用于决议和或或兑现关联的并且异常停止传播让我们具体地讲一下在前面的代码示例中如果或引发异常则将调用函数如果正常返回则其返回值将传递给并且异步操作将正常继续另一方面如果无法恢复则它本身将引发异常或者重新抛出传入的异常在这种情况下不会调用或并且引发的异常将传递给有时在复杂的网络环境中异常可能会或多或少地随机发生并且可以通过简单地重试异步请求来处理这些异常假设编写了一个基于的操作来查询数据库现在假设大约的概率瞬态网络负载问题导致其失败一个简单的解决方案可能是使用调用重试查询如果假设的失败确实是随机的那么添加这一行代码应使错误率从降低到让我们最后一次返回前面的示例并考虑传递给第一个调用的回调注意可以通过三种方式终止它可以通过调用返回的正常返回这将导致变为已决议但是该是已兑现还是拒绝取决于新返回的发生了什么也可以正常返回值这将导致立即变成已兑现最后可以通过引发异常来终止从而导致变成已拒绝这是的三个可能结果而中的代码演示了回调如何导致每个结果在链中在链的一个阶段返回或抛出的值成为链的下一阶段的输入因此正确实现这一点至关重要实际上回调函数忘记返回值是与相关的常见错误而的箭头函数快捷语法会加剧这种情况回想一下我们之前看到的以下代码行回顾第章箭头函数提供了许多快捷方式由于仅存在一个参数异常值因此我们可以省略括号由于函数的主体是单个表达式因此我们可以省略函数主体周围的花括号并且表达式的值成为函数的返回值由于这些快捷方式前面的代码是正确的但是考虑一下这种无害的变化通过添加花括号我们不再获得自动返回现在此函数返回而不是返回这意味着将以作为输入而不是重试查询的结果来调用此链中的下一个阶段这是一个细微的错误可能不容易调试我们花了很多时间讨论链这些链可按顺序运行较大的异步的操作步骤但是有时我们想并行执行许多异步操作函数可以做到这一点将对象数组作为其输入并返回如果任何输入的中有一个是已拒绝状态则返回的将被拒绝否则它将使用每个输入的兑现值组成的数组来被兑现因此例如如果要获取多个的文本内容则可以使用如下代码比前面描述的要灵活一些输入数组可以包含对象和非值如果数组的元素不是则将其视为已兑现的的值并原封不动地复制到输出数组中当任何输入的被拒绝时返回的也会被拒绝这在第一次拒绝时立即发生可能其他输入仍是待定状态在中接受输入的数组并返回就像一样但是永远不会拒绝返回的并且不会兑现这个直到所有输入全部已敲定解析为一组对象每个输入都有一个对象每个返回的对象中有一个状态属性设置为已兑现或已拒绝如果状态为已兑现则对象还将具有一个属性该属性提供兑现值并且如果状态为已拒绝则对象还将具有一个属性该属性给出相应的的异常或拒绝值有时可能想一次运行多个但可能只关心第一个要兑现的值在这种情况下可以使用代替当输入数组中的第一个是已兑现或已拒绝状态时它返回一个已兑现或已拒绝的或者如果输入数组中有任何非值则只返回其中的第一个在之前的许多示例中我们都使用了返回函数因为它是内置于浏览器中的最简单的返回的函数之一我们对的讨论还依赖于假设的返回函数和编写用于返回的函数确实非常有用本节说明如何创建自己的基于的特别是我们将展示和的实现如果以返回函数作为开头来写一个返回的函数是很容易的有了总是可以通过调用创建并返回一个新的因此如果我们使用现有的函数作为起点则可以这样编写该代码很简单因为的对象具有预定义的方法我们从回调该回调是带有单个表达式主体的箭头函数因此返回值是隐式的中通过方法返回一个因此返回的解析为当该兑现时由返回的将兑现为相同的值请注意此实现中没有异常处理如果不能将主体解析为则无需检查和标头而只需允许方法拒绝它的并返回让我们编写另一个返回函数这次使用作为初始的来源我们假设此函数是某种基于网络的游戏的一部分并且返回的是包含属性的格式的数据结构有时即使要执行的计算实际上不需要任何异步操作也可能需要实现现有的基于的并从函数返回在这种情况下静态方法和会做您想要的采用一个单个实参值并返回一个该将立即但异步地兑现为该值同样接受一个实参值并返回一个该值将作为被拒绝的原因请注意这些静态方法返回的在返回时尚未兑现或拒绝但是它们将在当前同步代码块运行完毕后立即兑现或拒绝通常这种情况会在几毫秒内发生除非有许多等待执行的待处理异步任务回顾已决议的与已兑现的不同当我们调用时通常会传递兑现值以创建一个对象该对象将很快兑现该值但是该方法未命名为如果将传递给它将返回一个新的该立即被决议但是直到被兑现或拒绝该才会被兑现或拒绝可以但不常见编写一个基于的函数同步计算的值通过通过异步返回但是在异步函数中包含同步特殊情况是很常见的可以使用和处理这些特殊情况特别是如果在开始异步操作之前检测到异常条件例如异常的实参值则可以通过返回使用创建的来报告该异常在这种情况下也可以同步引发异常但这被认为是较差的形式因为函数的调用者需要同时编写同步子句并使用异步方法来处理异常最后有时可用于在链中创建初始我们将看到几个使用这种方式的示例对于和我们首先调用现有函数以获取初始然后通过调用该初始的方法创建并返回新的但是当不能使用另一个返回函数作为起点时如何编写返回函数呢在这种情况下可以使用构造函数创建一个可以完全控制的新对象它是这样工作的调用构造函数并将一个函数作为唯一实参传递传递的函数应编写为包含两个参数按照惯例应将其命名为和构造函数会同步调用使用和参数的函数调用函数后构造函数将返回新创建的返回的受传递给构造函数的函数的控制该函数应该执行一些异步操作然后调用函数来决议或兑现返回的或者调用函数来拒绝返回的函数不必是异步的它可以同步地调用或拒绝但是如果这样做仍将被异步地决议兑现或拒绝仅仅阅读一下很难理解传递给构造函数的函数但是希望有一些例子可以使这一点变得清楚这是在本章前面的各种示例中使用的基于的函数的编写方法请注意用于控制由构造函数创建的命运的一对函数分别命名为和而不是和如果传递一个给则返回的将决议于该新的但是通常会传递一个非值返回的会兑现这个值示例是使用构造函数的另一个示例这一节实现了中在未内置使用的函数请记住本章开始时讨论了异步回调和事件此示例同时使用了回调和事件处理程序因此很好地演示了如何在其他风格的异步编程之上实现基于的示例异步函数使得并行运行任意数量的变得容易链使表达固定数量的序列变得容易但是依次执行任意数量的会比较棘手例如假设您要获取一组但是为了避免网络过载希望一次获取一个如果数组的长度是任意的且内容未知则无法提前写出链因此需要使用以下代码动态构建一个定义了这个函数之后我们可以用一个代码一次来获取多个就像我们之前用来演示的并行获取代码一样函数首先创建一个该将在返回后立即兑现然后它从该初始构建一个长的线性链并返回链中的最后一个这就像设置一排多米诺骨牌然后将第一个多米诺骨牌撞倒一样我们可以采用另一种方法可能更优雅除了提前创建外我们还可以为每个创建回调并返回下一个也就是说我们没有创建和链接一堆而是创建了决议于其他承诺的承诺与其创建类似多米诺骨牌的链不如创建一系列彼此嵌套在一起的序列就像俄罗斯套娃一样使用这种方法我们的代码可以知道第一个最外面的最终将兑现或拒绝使其返回序列中最后一个最里面的相同的值后面是通用的函数并不特定于提取因为它很复杂所以将它放在我们对的讨论的结尾但是如果仔细阅读了本章希望能理解它的工作原理特别要注意的是中的嵌套函数类似递归地调用自身但是由于递归调用是通过方法进行的因此实际上没有发生任何传统的递归函数是通用的我们可以使用它通过以下代码来获取引入了两个新的关键字和描述异步编程中的模式转变这些新关键字极大地简化了的使用使我们能够编写基于的异步代码看起来像是等待网络响应或其他异步事件而阻塞的同步代码尽管了解的工作原理仍然很重要但是当将它们与和一起使用时它们的大部分复杂性有时甚至是它们的存在就消失了如本章前面所述异步代码无法像常规同步代码那样返回值或引发异常这就是为什么如此设计的原因已兑现的的值类似于同步函数的返回值而且已拒绝的的值就像同步函数抛出的值后者通过类似的方法命名使得表述更清晰和使用高效的基于的代码并隐藏以便异步代码可以像低效阻塞同步代码一样容易阅读和推理关键字接受一个并将其转换为返回值或引发的异常给定一个对象表达式等待直到敲定如果兑现则等待的值就是的兑现值另一方面如果被拒绝则表达式将抛出的拒绝值我们通常不将与保存的变量一起使用相反我们在调用返回的函数之前使用它立即了解至关重要的一点是在指定的敲定之前关键字不会导致程序阻塞并且实际上什么也不做代码保持异步并且只是掩盖了这一事实这意味着使用的任何代码本身都是异步的因为任何使用的代码都是异步的所以有一个关键规则只能在使用关键字声明的函数中使用关键字下面是本章前面的函数的一个版本使用和重写异步声明函数意味着函数的返回值将是一个即使函数体中没有出现与相关的代码如果异步函数看起来正常返回那么作为函数实际返回值的对象将决议为该返回值如果一个异步函数出现抛出异常那么它返回的对象将被那个异常拒绝函数被声明为异步因此它返回一个承诺因为它返回一个承诺所以我们可以使用关键字但是请记住只有在另一个异步函数中该行代码才有效可以根据需要在异步函数中嵌套任何层表达式但是如果处于最高级别或由于某种原因而处于不异步的函数内那么您无法使用并且必须以常规方式处理返回的可以将关键字与任何函数一起使用它用作于关键字作为语句或表达式它可与箭头函数以及类和对象字面量中的速记方法方式一起使用有关如何编写函数的各种方法请参见第章假设我们已经使用编写了函数并且现在假设我们要用这个方法获取两个值此代码的问题在于它不必要地是连续的第二个的获取要等到第一次获取完成后才能开始如果第二个不依赖于从第一个获得的值那么我们可能应该尝试同时获取两个值这是基于的异步函数本质的一种情况为了等待一组并发执行的异步函数我们使用就像直接使用一样最后为了了解异步功能是如何工作的考虑一下幕后发生了什么可能会有所帮助假设写这样的一个异步函数可以将其视为包装原始函数主体的返回函数用像这样的语法转换来表达关键字比较困难但是将关键字视为将函数主体分解为单独的同步块的标记解释器可以将函数主体分解为一系列单独的子函数每个子函数都传递给位于其前面标记的的方法在本章的开头我们讨论了基于回调和基于事件的异步当我们介绍时我们注意到它们对于单次异步计算很有用但不适用于重复性异步事件的代码例如网络浏览器中的事件或流上的事件因为单个不适用于异步事件序列所以我们也不能对这些事物使用常规的异步函数和语句但是提供了一个解决方案异步迭代器类似于第章中描述的迭代器但是它们基于并且打算与循环一起使用的新形式使其可读流可以异步迭代这意味着可以使用如下所示的循环从流中读取连续的数据块像普通的表达式一样循环是基于的粗略地说异步迭代器产生一个循环等待该兑现将兑现值分配给循环变量然后运行循环的主体然后重新开始从迭代器中获得另一个然后等待该新兑现假设有一个数组可以在每个上调用以获取一个数组我们在本章的前面已经看到我们现在可以使用等待数组中的所有都已兌現但是假设我们希望第一个提取的结果尽快可用并且不想等待所有都被获取当然第一次获取可能比其他任何获取都要花费更长的时间因此不一定比使用更快数组是可迭代的因此我们可以使用常规的对数组进行遍历此示例代码使用循环遍历常规迭代器但是因为此迭代器返回所以我们还可以将新的稍微简化下代码在这种情况下循环仅将调用构建到循环中并使我们的代码稍微紧凑一些但是两个示例的作用完全相同重要的是这两个示例只有在声明为异步的函数中时才起作用循环与常规表达式没有什么不同但是重要的是要意识到在此示例中我们正在使用作用于常规迭代器的作用于完全异步的迭代器使事情变得更加有趣让我们回顾一下第章中的一些术语可迭代对象是可以与循环一起使用的对象它定义了一个名称为的方法此方法返回一个迭代器对象迭代器对象具有方法可以重复调用该方法以获得可迭代对象的值迭代器对象的方法返回迭代结果对象迭代结果对象具有属性和或或属性异步迭代器与常规迭代器非常相似但是有两个重要的区别首先一个异步可迭代对象以符号名称而不是实现一个方法如前所述与常规可迭代对象兼容但是它更喜欢异步可迭代对象并在尝试方法之前先尝试使用方法其次异步迭代器的方法返回解析为迭代器结果对象的而不是直接返回迭代器结果对象在上一节中当我们在常规的同步可迭代的数组上使用时我们正在使用同步迭代器结果对象其中属性是对象但属性是同步的真正的异步迭代器为迭代结果对象返回并且和属性都是异步的这是一个微妙的区别使用异步迭代器可以异步选择何时结束迭代正如我们在第章中看到的那样实现迭代器的最简单方法通常是使用生成器异步迭代器也是如此我们可以使用声明为异步的生成器函数来实现异步生成器具有异步特性和生成器特性可以像在常规异步函数中一样使用并且可以像在常规生成器中一样使用但是产生的值会自动包装在中甚至异步生成器的语法也是一个组合异步函数和组合为这是一个示例描述如何使用异步生成器和循环代替回调函数以固定的间隔重复运行代码除了使用异步生成器来实现异步迭代器外还可以通过使用方法定义一个对象来直接实现它们而方法将返回一个对象而方法将返回一个决议为迭代器结果对象的在下面的代码中我们重新实现了上一个示例中的函数因此它不是生成器而仅是返回一个异步可迭代的对象请注意此示例中的方法未明确返回相反我们只声明是异步的这个基于迭代器版本的函数修复了基于生成器版本中的一个缺陷请注意在此代码中我们在每次迭代开始时设置了绝对目标时间并将其与当前时间的差值作为间隔传递给如果我们将与循环一起使用则此版本将在指定的时间间隔内更精确地运行循环迭代因为它考虑了实际运行循环主体所需的时间但是此修补程序不仅涉及定时精度循环始终在开始下一次迭代之前等待一次迭代返回的被兑现但是如果使用不带循环的异步迭代器则没有什么可以阻止在需要时调用方法使用基于生成器的版本如果依次调用方法三遍将获得三个这些几乎都在同一时间完成这可能不是想要的结果我们在这里实现的基于迭代器的版本没有这个问题异步迭代器的好处在于它们允许我们表示异步事件或数据流前面讨论的函数编写起来非常简单因为异步源是我们自己进行的调用但是当我们尝试与其他异步源一起使用时例如事件处理程序的触发实现异步迭代器的难度将大大提高我们通常只有一个事件处理程序函数来响应事件但是每次调用迭代器的方法一定返回一个不同的对象并且在第一个决议之前可能会多次调用这意味着任何异步迭代器方法都必须能够维护一个内部的队列该队列将在响应异步事件时按顺序进行决议如果我们将此有序列的行为封装到类中那么基于编写异步迭代器将变得更加容易正如期望的那样后面的类具有和方法但是方法返回而不是实际值这意味着可以在调用之前调用类也是一个异步迭代器旨在与循环一起使用该循环的主体在每次将新值异步排队时都运行一次有一个方法一旦被调用就不能将更多的值加入队列当关闭的队列为空时循环将停止遍历请注意的实现不使用异步或等待而是直接与一起使用该代码有些复杂可以使用它来测试对本长篇文章所涉及内容的理解即使您不完全了解的实现也请看一下它后面的简短示例它在之上实现了一个简单但非常有趣的异步迭代器因为类定义了异步迭代基础所以我们可以简单地通过异步排队值来创建更有趣的自定义异步迭代器这是一个使用生成可通过循环处理的浏览器事件流的示例在本章中您学习了大多数真实的程序都是异步的传统上异步是通过事件和回调函数来处理的但是这可能会变得复杂因为最终可能会嵌套在其他回调中嵌套的多个级别的回调并且因为很难进行可靠的异常处理提供了构造回调函数的新方法如果正确使用不幸的是易于错误使用它们可以将异步代码转换为嵌套在调用的线性链中的代码一个计算的异步步骤跟随在其他之后而且允许将异常处理代码集中到一个调用链末尾的单个调用中和关键字允许我们编写异步代码该代码基于但看起来像同步代码这使代码更易于理解和推理如果一个函数被声明为它将隐式返回一个在异步函数内部可以或返回的函数就像值是同步计算的一样异步可迭代的对象可以与循环一起使用可以通过实现方法或调用生成器函数来创建异步可迭代对象异步迭代器为中流的事件提供了一种替代方法可用于表示客户端中的用户输入事件的流类与无关在现代的客户端中它已被取代该已在中进行了介绍此处显示的代码示例是本书中最后一个基于的示例通常可以在浏览器的开发人员控制台的顶层使用还有一个悬而未决的建议允许在将来的版本中进行顶级我从的博客中了解了这种异步迭代方法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:45:28',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Jackhou Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 1.05rem;">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 1.05rem;">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem;">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 1.05rem;">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 1.05rem;">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 1.05rem;">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 1.05rem;">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 1.05rem;">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.05rem;">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 1.05rem;">越权<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">37</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>《JavaScript权威指南》</span></a><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">第13章 异步 JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:48.000Z" title="发表于 2023-04-26 00:00:48">2023-04-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-04-26T13:45:28.000Z" title="更新于 2023-04-26 21:45:28">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="第13章 异步 JavaScript"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover3.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url">《JavaScript权威指南》</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><h1 id="CrawlerTitle" itemprop="name headline">第13章 异步 JavaScript</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jack hou</span><time itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:48.000Z" title="发表于 2023-04-26 00:00:48">2023-04-26</time><time itemprop="dateCreated datePublished" datetime="2023-04-26T13:45:28.000Z" title="更新于 2023-04-26 21:45:28">2023-04-26</time></header><meta name="referrer" content="no-referrer"/>



<p>Some computer programs, such as scientific simulations and machine learning models, are compute-bound: they run continuously, without pause, until they have computed their result. Most real-world computer programs, however, are significantly asynchronous. This means that they often have to stop computing while waiting for data to arrive or for some event to occur. JavaScript programs in a web browser are typically event-driven, meaning that they wait for the user to click or tap before they actually do anything. And JavaScript-based servers typically wait for client requests to arrive over the network before they do anything.</p>
<blockquote>
<p>一些计算机程序，如科学模拟和机器学习模型，是计算受限的：它们不停地运行，没有停顿，直到计算出结果。然而，值得注意的是现实世界中的大多数计算机程序都是异步的。这意味着在等待数据到达或某些事件发生时，它们常常不得不停止计算。web 浏览器中的 JavaScript 程序是典型地事件驱动的，这意味着它们在实际执行任何操作之前等待用户单击或点击。基于 javascript 的服务器通常在执行任何操作之前等待客户机请求通过网络到达。</p>
</blockquote>
<p>This kind of asynchronous programming is commonplace in JavaScript, and this chapter documents three important language features that help make it easier to work with asynchronous code. Promises, new in ES6, are objects that represent the not-yet-available result of an asynchronous operation. The keywords async and await were introduced in ES2017 and provide new syntax that simplifies asynchronous programming by allowing you to structure your Promise-based code as if it was synchronous. Finally, asynchronous iterators and the for&#x2F;await loop were introduced in ES2018 and allow you to work with streams of asynchronous events using simple loops that appear synchronous.</p>
<blockquote>
<p>这种异步编程在 JavaScript 中很常见，本章将介绍三种重要的语言特性，它们有助于简化异步代码的使用。Promise 是 ES6 中的新特性，是表示目前不可用结果的异步操作对象。关键字 async 和 await 是在 ES2017 中引入的，它们提供了新的语法，通过允许将基于 Promise 的代码构造成同步的方式来简化异步编程。最后，在 ES2018 中引入了异步迭代器和 for&#x2F;await 循环，允许使用简单的同步循环处理异步事件流。</p>
</blockquote>
<p>Ironically, even though JavaScript provides these powerful features for working with asynchronous code, there are no features of the core language that are themselves asynchronous. In order to demonstrate Promises, async, await, and for&#x2F;await, therefore, we will first take a detour into client-side and server-side JavaScript to explain some of the asynchronous features of web browsers and Node. (You can learn more about client-side and server-side JavaScript in Chapters 15 and 16.)</p>
<blockquote>
<p>具有讽刺意味的是，尽管 JavaScript 为处理异步代码提供了这些强大的特性，但核心语言本身并没有异步的特性。因此，为了演示 Promise、async、await 和 for&#x2F;await，我们将首先使用客户端和服务器端 JavaScript 来解释 web 浏览器和 Node 的一些异步特性。（可以在第 15 章和第 16 章中了解更多关于客户端和服务器端 JavaScript 的知识。）</p>
</blockquote>
<h2 id="13-1-Asynchronous-Programming-with-Callbacks"><a href="#13-1-Asynchronous-Programming-with-Callbacks" class="headerlink" title="13.1 Asynchronous Programming with Callbacks"></a>13.1 Asynchronous Programming with Callbacks</h2><p>At its most fundamental level, asynchronous programming in JavaScript is done with callbacks. A callback is a function that you write and then pass to some other function. That other function then invokes (“calls back”) your function when some condition is met or some (asynchronous) event occurs. The invocation of the callback function you provide notifies you of the condition or event, and sometimes, the invocation will include function arguments that provide additional details. This is easier to understand with some concrete examples, and the subsections that follow demonstrate various forms of callback-based asynchronous programming using both client-side JavaScript and Node.</p>
<blockquote>
<p>在最基本的层次上，JavaScript 中的异步编程是通过回调来完成的。回调是一个你编写的函数，然后传递给其他函数。当满足某些条件或发生某些（异步）事件时，其他函数调用（“回调”）你的函数。提供的回调函数的调用会通知你条件或事件，有时，调用将提供包含额外细节的函数实参。通过一些具体的示例会更容易理解，下面的子节将演示使用客户端 JavaScript 和 Node 的各种形式的基于回调的异步编程。</p>
</blockquote>
<h3 id="13-1-1-Timers"><a href="#13-1-1-Timers" class="headerlink" title="13.1.1 Timers"></a>13.1.1 Timers</h3><p>One of the simplest kinds of asynchrony is when you want to run some code after a certain amount of time has elapsed. As we saw in §11.10, you can do this with the setTimeout() function:</p>
<blockquote>
<p>当希望在经过一定时间后运行某些代码是一种最简单的异步类型。正如我们在 §11.10 中看到的，可以通过 setTimeout() 函数来做到这一点：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(checkForUpdates, <span class="number">60000</span>);</span><br></pre></td></tr></table></figure>

<p>The first argument to setTimeout() is a function and the second is a time interval measured in milliseconds. In the preceding code, a hypothetical checkForUpdates() function will be called 60,000 milliseconds (1 minute) after the setTimeout() call. checkForUpdates() is a callback function that your program might define, and setTimeout() is the function that you invoke to register your callback function and specify under what asynchronous conditions it should be invoked.</p>
<blockquote>
<p>setTimeout() 的第一个实参是一个函数，第二个实参是一个以毫秒为单位的时间间隔。前面的代码中，在 setTimeout() 调用后 60,000 毫秒（1分钟）后，将调用一个假定的 checkForUpdates() 函数。checkForUpdates() 是程序定义的一个回调函数，而 setTimeout() 是用于注册回调函数并指定应该在什么异步条件下调用它的函数。</p>
</blockquote>
<p>setTimeout() calls the specified callback function one time, passing no arguments, and then forgets about it. If you are writing a function that really does check for updates, you probably want it to run repeatedly. You can do this by using setInterval() instead of setTimeout():</p>
<blockquote>
<p>setTimeout() 调用一次指定的回调函数，不传递任何实参，然后忘记它。如果正在编写一个检查更新的函数，可能希望它重复运行。可以使用 setInterval() 来代替 setTimeout()：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Call checkForUpdates in one minute and then again every minute after that</span></span><br><span class="line"><span class="keyword">let</span> updateIntervalId = <span class="built_in">setInterval</span>(checkForUpdates, <span class="number">60000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setInterval() returns a value that we can use to stop the repeated</span></span><br><span class="line"><span class="comment">// invocations by calling clearInterval(). (Similarly, setTimeout()</span></span><br><span class="line"><span class="comment">// returns a value that you can pass to clearTimeout())</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">stopCheckingForUpdates</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">clearInterval</span>(updateIntervalId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-1-2-Events"><a href="#13-1-2-Events" class="headerlink" title="13.1.2 Events"></a>13.1.2 Events</h3><p>Client-side JavaScript programs are almost universally event driven: rather than running some kind of predetermined computation, they typically wait for the user to do something and then respond to the user’s actions. The web browser generates an event when the user presses a key on the keyboard, moves the mouse, clicks a mouse button, or touches a touchscreen device. Event-driven JavaScript programs register callback functions for specified types of events in specified contexts, and the web browser invokes those functions whenever the specified events occur. These callback functions are called event handlers or event listeners, and they are registered with addEventListener():</p>
<blockquote>
<p>客户端 JavaScript 程序几乎都是由事件驱动的：它们通常不等待用户执行某种预定的计算，而是等待用户执行某些操作，然后响应用户的操作。当用户按下键盘上的键，移动鼠标，单击鼠标按钮或触摸触摸屏设备时，Web 浏览器会发生事件。事件驱动的 JavaScript 程序在指定的上下文中为指定类型的事件注册回调函数，并且只要指定事件发生，Web 浏览器就会调用这些函数。这些回调函数称为事件句柄或事件监听器，并且使用 addEventListener() 注册：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ask the web browser to return an object representing the HTML</span></span><br><span class="line"><span class="comment">// &lt;button&gt; element that matches this CSS selector</span></span><br><span class="line"><span class="keyword">let</span> okay = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#confirmUpdateDialog button.okay&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now register a callback function to be invoked when the user</span></span><br><span class="line"><span class="comment">// clicks on that button.</span></span><br><span class="line">okay.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, applyUpdate);</span><br></pre></td></tr></table></figure>
<p>In this example, applyUpdate() is a hypothetical callback function that we assume is implemented somewhere else. The call to document.querySelector() returns an object that represents a single specified element in the web page. We call addEventListener() on that element to register our callback. Then the first argument to addEventListener() is a string that specifies the kind of event we’re interested in—a mouse click or touchscreen tap, in this case. If the user clicks or taps on that specific element of the web page, then the browser will invoke our applyUpdate() callback function, passing an object that includes details (such as the time and the mouse pointer coordinates) about the event.</p>
<blockquote>
<p>在此示例中，假设 applyUpdate() 是我们在某个地方实现的回调函数。调用 document.querySelector() 返回一个对象，该对象表示网页中的单个指定元素。我们在该元素上调用 addEventListener() 来注册我们的回调。然后，addEventListener() 的第一个实参是一个字符串，该字符串指定了事件的类型（在这种情况下是单击鼠标或触摸屏）。如果用户单击或点击网页上的特定元素，则浏览器将调用我们的 applyUpdate() 回调函数，并传递一个包含事件详细信息（例如时间和鼠标指针坐标）的对象。</p>
</blockquote>
<h3 id="13-1-3-Network-Events"><a href="#13-1-3-Network-Events" class="headerlink" title="13.1.3 Network Events"></a>13.1.3 Network Events</h3><p>Another common source of asynchrony in JavaScript programming is network requests. JavaScript running in the browser can fetch data from a web server with code like this:</p>
<blockquote>
<p>JavaScript 编程中异步的另一个常见来源是网络请求。在浏览器中运行的 JavaScript 可以使用以下代码从 Web 服务器获取数据：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getCurrentVersionNumber</span>(<span class="params">versionCallback</span>) &#123; <span class="comment">// Note callback argument</span></span><br><span class="line">    <span class="comment">// Make a scripted HTTP request to a backend version API</span></span><br><span class="line">    <span class="keyword">let</span> request = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    request.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://www.example.com/api/version&quot;</span>);</span><br><span class="line">    request.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a callback that will be invoked when the response arrives</span></span><br><span class="line">    request.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (request.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// If HTTP status is good, get version number and call callback.</span></span><br><span class="line">            <span class="keyword">let</span> currentVersion = <span class="built_in">parseFloat</span>(request.<span class="property">responseText</span>);</span><br><span class="line">            <span class="title function_">versionCallback</span>(<span class="literal">null</span>, currentVersion);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise report an error to the callback</span></span><br><span class="line">            <span class="title function_">versionCallback</span>(response.<span class="property">statusText</span>, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Register another callback that will be invoked for network errors</span></span><br><span class="line">    request.<span class="property">onerror</span> = request.<span class="property">ontimeout</span> = <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">        <span class="title function_">versionCallback</span>(e.<span class="property">type</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Client-side JavaScript code can use the XMLHttpRequest class plus callback functions to make HTTP requests and asynchronously handle the server’s response when it arrives.[^1] The getCurrentVersionNumber() function defined here (we can imagine that it is used by the hypothetical checkForUpdates() function we discussed in §13.1.1) makes an HTTP request and defines event handlers that will be invoked when the server’s response is received or when a timeout or other error causes the request to fail.</p>
<blockquote>
<p>客户端 JavaScript 代码可以使用 XMLHttpRequest 类以及回调函数来发出 HTTP 请求，并在服务器响应时异步处理。[^1] 这里定义的 getCurrentVersionNumber() 函数（我们可以假设在 §13.1.1 提到的 checkForUpdates() 函数使用了该函数）发出 HTTP 请求并定义事件处理程序，该事件处理程序将在收到服务器的响应或超时或其他异常导致请求失败时被调用。</p>
</blockquote>
<p>Notice that the code example above does not call addEventListener() as our previous example did. For most web APIs (including this one), event handlers can be defined by invoking addEventListener() on the object generating the event and passing the name of the event of interest along with the callback function. Typically, though, you can also register a single event listener by assigning it directly to a property of the object. That is what we do in this example code, assigning functions to the onload, onerror, and ontimeout properties. By convention, event listener properties like these always have names that begin with on. addEventListener() is the more flexible technique because it allows for multiple event handlers. But in cases where you are sure that no other code will need to register a listener for the same object and event type, it can be simpler to simply set the appropriate property to your callback.</p>
<blockquote>
<p>请注意，上面的代码示例未像前面的示例那样调用 addEventListener()。对于大多数 Web API（包括此API），可以通过在生成事件的对象上调用 addEventListener() 并将事件的名称与回调函数一起传递来定义事件处理程序。不过，通常，也可以通过将单个事件侦听器直接分配给对象的属性来注册它。这就是我们在此示例代码中所做的，将函数分配给 onload、onerror 和 ontimeout 属性。按照惯例，此类事件侦听器属性的名称始终以 on 开头。 addEventListener() 是更灵活的技术，因为它允许多个事件处理程序。但是，如果确定没有其他代码需要为相同的对象和事件类型注册一个侦听器，则只需将适当的属性设置为回调会更简单。</p>
</blockquote>
<p>Another thing to note about the getCurrentVersionNumber() function in this example code is that, because it makes an asynchronous request, it cannot synchronously return the value (the current version number) that the caller is interested in. Instead, the caller passes a callback function, which is invoked when the result is ready or when an error occurs. In this case, the caller supplies a callback function that expects two arguments. If the XMLHttpRequest works correctly, then getCurrentVersionNumber() invokes the callback with a null first argument and the version number as the second argument. Or, if an error occurs, then getCurrentVersionNumber() invokes the callback with error details in the first argument and null as the second argument.</p>
<blockquote>
<p>此示例代码中关于 getCurrentVersionNumber() 函数的另一点注意事项是，由于它发出异步请求，因此无法同步返回调用者感兴趣的值（当前版本号）。相反，调用者传递了一个回调函数，当结果准备就绪或发生异常时调用。在这种情况下，调用方提供了一个回调函数，该函数需要两个参数。如果 XMLHttpRequest 正常工作，则 getCurrentVersionNumber() 会使用 null 为第一个实参和版本号为第二个实参调用回调函数。或者，如果发生异常，则 getCurrentVersionNumber() 会在第一个实参中带有异常详细信息，而在第二个参数中使用 null。</p>
</blockquote>
<h3 id="13-1-4-Callbacks-and-Events-in-Node"><a href="#13-1-4-Callbacks-and-Events-in-Node" class="headerlink" title="13.1.4 Callbacks and Events in Node"></a>13.1.4 Callbacks and Events in Node</h3><p>The Node.js server-side JavaScript environment is deeply asynchronous and defines many APIs that use callbacks and events. The default API for reading the contents of a file, for example, is asynchronous and invokes a callback function when the contents of the file have been read:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>); <span class="comment">// The &quot;fs&quot; module has filesystem-related APIs</span></span><br><span class="line"><span class="keyword">let</span> options = &#123;           <span class="comment">// An object to hold options for our program</span></span><br><span class="line">    <span class="comment">// default options would go here</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read a configuration file, then call the callback function</span></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;config.json&quot;</span>, <span class="string">&quot;utf-8&quot;</span>, <span class="function">(<span class="params">err, text</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// If there was an error, display a warning, but continue</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;Could not read config file:&quot;</span>, err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise, parse the file contents and assign to the options object</span></span><br><span class="line">        <span class="title class_">Object</span>.<span class="title function_">assign</span>(options, <span class="title class_">JSON</span>.<span class="title function_">parse</span>(text));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In either case, we can now start running the program</span></span><br><span class="line">    <span class="title function_">startProgram</span>(options);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Node’s fs.readFile() function takes a two-parameter callback as its last argument. It reads the specified file asynchronously and then invokes the callback. If the file was read successfully, it passes the file contents as the second callback argument. If there was an error, it passes the error as the first callback argument. In this example, we express the callback as an arrow function, which is a succinct and natural syntax for this kind of simple operation.</p>
<p>Node also defines a number of event-based APIs. The following function shows how to make an HTTP request for the contents of a URL in Node. It has two layers of asynchronous code handled with event listeners. Notice that Node uses an on() method to register event listeners instead of addEventListener():</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">&quot;https&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Read the text content of the URL and asynchronously pass it to the callback.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getText</span>(<span class="params">url, callback</span>) &#123;</span><br><span class="line">    <span class="comment">// Start an HTTP GET request for the URL</span></span><br><span class="line">    request = https.<span class="title function_">get</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a function to handle the &quot;response&quot; event.</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&quot;response&quot;</span>, <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// The response event means that response headers have been received</span></span><br><span class="line">        <span class="keyword">let</span> httpStatus = response.<span class="property">statusCode</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The body of the HTTP response has not been received yet.</span></span><br><span class="line">        <span class="comment">// So we register more event handlers to to be called when it arrives.</span></span><br><span class="line">        response.<span class="title function_">setEncoding</span>(<span class="string">&quot;utf-8&quot;</span>);  <span class="comment">// We&#x27;re expecting Unicode text</span></span><br><span class="line">        <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;                  <span class="comment">// which we will accumulate here.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// This event handler is called when a chunk of the body is ready</span></span><br><span class="line">        response.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123; body += chunk; &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This event handler is called when the response is complete</span></span><br><span class="line">        response.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpStatus === <span class="number">200</span>) &#123;   <span class="comment">// If the HTTP response was good</span></span><br><span class="line">                <span class="title function_">callback</span>(<span class="literal">null</span>, body);   <span class="comment">// Pass response body to the callback</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                    <span class="comment">// Otherwise pass an error</span></span><br><span class="line">                <span class="title function_">callback</span>(httpStatus, <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We also register an event handler for lower-level network errors</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">callback</span>(err, <span class="literal">null</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-2-Promises"><a href="#13-2-Promises" class="headerlink" title="13.2 Promises"></a>13.2 Promises</h2><p>Now that we’ve seen examples of callback and event-based asynchronous programming in client-side and server-side JavaScript environments, we can introduce Promises, a core language feature designed to simplify asynchronous programming.</p>
<blockquote>
<p>现在，我们已经见过了客户端和服务器端 JavaScript 环境中基于回调和基于事件的异步编程的示例，我们接着介绍 Promise，这是一种旨在简化异步编程的核心语言特性。</p>
</blockquote>
<p>A Promise is an object that represents the result of an asynchronous computation. That result may or may not be ready yet, and the Promise API is intentionally vague about this: there is no way to synchronously get the value of a Promise; you can only ask the Promise to call a callback function when the value is ready. If you are defining an asynchronous API like the getText() function in the previous section, but want to make it Promise-based, omit the callback argument, and instead return a Promise object. The caller can then register one or more callbacks on this Promise object, and they will be invoked when the asynchronous computation is done.</p>
<blockquote>
<p>Promise 是描述异步计算结果的对象。该结果可能准备好或尚未准备好，Promise API 故意对此含糊其词：无法同步获取 Promise 的值；只能要求 promise 在值准备好时调用回调函数。如果要像上一节中的 getText() 函数那样定义异步 API，但想使其基于 Promise，则省略 callback 参数，而返回 Promise 对象。然后，调用者可以在此 Promise 对象上注册一个或多个回调，并且在异步计算完成后将调用它们。</p>
</blockquote>
<p>So, at the simplest level, Promises are just a different way of working with callbacks. However, there are practical benefits to using them. One real problem with callback-based asynchronous programming is that it is common to end up with callbacks inside callbacks inside callbacks, with lines of code so highly indented that it is difficult to read. Promises allow this kind of nested callback to be re-expressed as a more linear Promise chain that tends to be easier to read and easier to reason about.</p>
<blockquote>
<p>因此，最简单的说，promise 只是使用回调的另一种方式。但是，使用它有实际的好处。基于回调的异步编程的一个真正的问题是，通常在回调内部嵌套多层回调，并且代码行缩进程度很高，以至于很难阅读。Promise 允许将这种嵌套的回调作为更线性的 Promise 链重新表达，该链往往更易于阅读和推理。</p>
</blockquote>
<p>Another problem with callbacks is that they can make handling errors difficult. If an asynchronous function (or an asynchronously invoked callback) throws an exception, there is no way for that exception to propagate back to the initiator of the asynchronous operation. This is a fundamental fact about asynchronous programming: it breaks exception handling. The alternative is to meticulously track and propagate errors with callback arguments and return values, but this is tedious and difficult to get right. Promises help here by standardizing a way to handle errors and providing a way for errors to propagate correctly through a chain of promises.</p>
<blockquote>
<p>回调的另一个问题是，它们会使处理异常变得困难。如果异步函数（或异步调用的回调）引发异常，则该异常无法传播回异步操作的发起者。这是关于异步编程的基本事实：它破坏了异常处理。替代方法是使用回调实参和返回值来精心跟踪和传播异常，但这很繁琐且难以正确处理。Promise 通过标准化处理异常的方式以及为异常通过 Promise 链正确传播的方式提供帮助。</p>
</blockquote>
<p>Note that Promises represent the future results of single asynchronous computations. They cannot be used to represent repeated asynchronous computations, however. Later in this chapter, we’ll write a Promise-based alternative to the setTimeout() function, for example. But we can’t use Promises to replace setInterval() because that function invokes a callback function repeatedly, which is something that Promises are just not designed to do. Similarly, we could use a Promise instead of the “load” event handler of an XMLHttpRequest object, since that callback is only ever called once. But we typically would not use a Promise in place of a “click” event handler of an HTML button object, since we normally want to allow the user to click a button multiple times.</p>
<blockquote>
<p>请注意，promise 表示单个异步计算的未来结果。但是，它不能用于表示重复的异步计算。例如，在本章的后面，我们将写一个基于 Promise 的 setTieout() 函数替代方法。但是，我们不能使用 Promise 来代替 setInterval()，因为该函数会反复调用回调函数，而 Promise 并不是。同样，我们可以使用 Promise 代替 XMLHttpRequest 对象的“load”事件处理程序，因为该回调仅被调用一次。但是我们通常不会使用 Promise 来代替 HTML 按钮对象的“click”事件处理程序，因为我们通常希望允许用户多次单击按钮。</p>
</blockquote>
<p>The subsections that follow will:</p>
<blockquote>
<p>接下来的小节将：</p>
</blockquote>
<ul>
<li>Explain Promise terminology and show basic Promise usage</li>
<li>Show how promises can be chained</li>
<li>Demonstrate how to create your own Promise-based APIs</li>
</ul>
<blockquote>
<ul>
<li>解释 Promise 术语并演示 Promise 的基本用法</li>
<li>展示如何将 Promise 链接起来</li>
<li>演示如何创建自己的基于 Promise 的 API</li>
</ul>
</blockquote>
<h4 id="IMPORTANT"><a href="#IMPORTANT" class="headerlink" title="IMPORTANT"></a>IMPORTANT</h4><p>Promises seem simple at first, and the basic use case for Promises is, in fact, straightforward and simple. But they can become surprisingly confusing for anything beyond the simplest use cases. Promises are a powerful idiom for asynchronous programming, but you need to understand them deeply to use them correctly and confidently. It is worth taking the time to develop that deep understanding, however, and I urge you to study this long chapter carefully.</p>
<blockquote>
<p>Promise 一开始似乎很简单，并且 Promise 的基本用例实际上也是简单明了的。但是，除了最简单的用例之外，它们还会使其他任何事情变得令人困惑。对于异步编程，Promise 是一个强大的习惯用法，但是需要深刻理解它们，才能正确、自信地使用它们。但是，它值得花时间来深入理解，我建议仔细阅读这一长篇章。</p>
</blockquote>
<h3 id="13-2-1-Using-Promises"><a href="#13-2-1-Using-Promises" class="headerlink" title="13.2.1 Using Promises"></a>13.2.1 Using Promises</h3><p>With the advent of Promises in the core JavaScript language, web browsers have begun to implement Promise-based APIs. In the previous section, we implemented a getText() function that made an asynchronous HTTP request and passed the body of the HTTP response to a specified callback function as a string. Imagine a variant of this function, getJSON(), which parses the body of the HTTP response as JSON and returns a Promise instead of accepting a callback argument. We will implement a getJSON() function later in this chapter, but for now, let’s look at how we would use this Promise-returning utility function:</p>
<blockquote>
<p>随着核心 JavaScript 语言中 Promise 的出现，Web 浏览器已经开始实现基于 Promise 的 API。在上一节中，我们实现了一个 getText() 函数，该函数发出一个异步 HTTP 请求，并将 HTTP 响应的主体作为字符串传递给指定的回调函数。想象一下该函数的一个变体 getJSON()，它可以解析主体 HTTP 响应的形式为 JSON，并返回 Promise 而不是接受回调参数。我们将在本章稍后实现 getJSON() 函数，但现在，让我们看一下如何使用返回 Promise 功能程序函数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">jsonData</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// This is a callback function that will be asynchronously</span></span><br><span class="line">    <span class="comment">// invoked with the parsed JSON value when it becomes available.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>getJSON() starts an asynchronous HTTP request for the URL you specify and then, while that request is pending, it returns a Promise object. The Promise object defines a then() instance method. Instead of passing our callback function directly to getJSON(), we instead pass it to the then() method. When the HTTP response arrives, the body of that response is parsed as JSON, and the resulting parsed value is passed to the function that we passed to then().</p>
<blockquote>
<p>getJSON() 对指定的 URL 启动一个异步 HTTP 请求，当该请求待定时，它返回一个 Promise 对象。Promise 对象定义了 then() 实例方法。我们没有将回调函数直接传递给 getJSON()，而是将其传递给 then() 方法。当 HTTP 响应时，该响应的主体将解析为 JSON，并将所解析的结果值传给我们传递给 then() 的回调函数。</p>
</blockquote>
<p>You can think of the then() method as a callback registration method like the addEventListener() method used for registering event handlers in client-side JavaScript. If you call the then() method of a Promise object multiple times, each of the functions you specify will be called when the promised computation is complete.</p>
<blockquote>
<p>可以将 then() 方法视为回调注册方法，例如用于在客户端 JavaScript 中注册事件处理程序的 addEventListener() 方法。如果多次调用 Promise 对象的 then() 方法，则在完成 promise 的计算后将调用指定的每个函数。</p>
</blockquote>
<p>Unlike many event listeners, though, a Promise represents a single computation, and each function registered with then() will be invoked only once. It is worth noting that the function you pass to then() is invoked asynchronously, even if the asynchronous computation is already complete when you call then().</p>
<blockquote>
<p>但是，与许多事件侦听器不同，Promise 表示单个计算，并且 then() 注册的每个函数仅被调用一次。值得注意的是，传递给 then() 的函数是异步调用的，即使调用 then() 时异步计算已经完成。</p>
</blockquote>
<p>At a simple syntactical level, the then() method is the distinctive feature of Promises, and it is idiomatic to append .then() directly to the function invocation that returns the Promise, without the intermediate step of assigning the Promise object to a variable.</p>
<blockquote>
<p>在简单的语法级别上，then() 方法是 Promise 独有的特性，编码中习惯于将 .then() 直接跟随返回 Promise 的函数，而无需将 Promise 对象分配给变量的中间步骤。</p>
</blockquote>
<p>It is also idiomatic to name functions that return Promises and functions that use the results of Promises with verbs, and these idioms lead to code that is particularly easy to read:</p>
<blockquote>
<p>常用带有动词命名返回 Promise 的函数和使用 Promise 结果的函数，这些常用语使代码特别容易阅读：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Suppose you have a function like this to display a user profile</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">displayUserProfile</span>(<span class="params">profile</span>) &#123; <span class="comment">/* implementation omitted */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s how you might use that function with a Promise.</span></span><br><span class="line"><span class="comment">// Notice how this line of code reads almost like an English sentence:</span></span><br><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/api/user/profile&quot;</span>).<span class="title function_">then</span>(displayUserProfile);</span><br></pre></td></tr></table></figure>
<h4 id="HANDLING-ERRORS-WITH-PROMISES"><a href="#HANDLING-ERRORS-WITH-PROMISES" class="headerlink" title="HANDLING ERRORS WITH PROMISES"></a>HANDLING ERRORS WITH PROMISES</h4><p>Asynchronous operations, particularly those that involve networking, can typically fail in a number of ways, and robust code has to be written to handle the errors that will inevitably occur.</p>
<blockquote>
<p>异步操作，尤其是涉及网络的异步操作，通常会以多种方式失败，并且必须编写健壮的代码来处理不可避免地会发生的异常。</p>
</blockquote>
<p>For Promises, we can do this by passing a second function to the then() method:</p>
<blockquote>
<p>对于 Promise，我们可以通过将第二个函数传递给 then() 方法来实现：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/api/user/profile&quot;</span>).<span class="title function_">then</span>(displayUserProfile, handleProfileError);</span><br></pre></td></tr></table></figure>
<p>A Promise represents the future result of an asynchronous computation that occurs after the Promise object is created. Because the computation is performed after the Promise object is returned to us, there is no way that the computation can traditionally return a value or throw an exception that we can catch. The functions that we pass to then() provide alternatives. When a synchronous computation completes normally, it simply returns its result to its caller. When a Promise-based asynchronous computation completes normally, it passes its result to the function that is the first argument to then().</p>
<blockquote>
<p>Promise 描述在 Promise 对象创建之后发生的异步计算的未来结果。由于计算是在 Promise 对象返回给我们之后执行的，因此该计算无法传统地返回值或引发我们可以捕获的异常。我们传递给 then() 的函数提供了替代方案。当同步计算正常完成时，它仅将其结果返回给其调用者。当基于 Promise 的异步计算正常完成时，它将其结果传递给 then() 的第一个实参函数。</p>
</blockquote>
<p>When something goes wrong in a synchronous computation, it throws an exception that propagates up the call stack until there is a catch clause to handle it. When an asynchronous computation runs, its caller is no longer on the stack, so if something goes wrong, it is simply not possible to throw an exception back to the caller.</p>
<blockquote>
<p>当同步计算中出现问题时，它将引发一个异常，该异常会沿调用堆栈传播，直到有一个 catch 子句来处理它为止。当异步计算运行时，它的调用者不再在堆栈上，因此，如果出现问题，则根本不可能将异常抛出给调用者。</p>
</blockquote>
<p>Instead, Promise-based asynchronous computations pass the exception (typically as an Error object of some kind, though this is not required) to the second function passed to then(). So, in the code above, if getJSON() runs normally, it passes its result to displayUserProfile(). If there is an error (the user is not logged in, the server is down, the user’s internet connection dropped, the request timed out, etc.), then getJSON() passes an Error object to handleProfileError().</p>
<blockquote>
<p>而基于 Promise 的异步计算将异常（通常是某种 Error 对象，尽管这不是必需的）传递给 then() 的第二个函数。因此，在上面的代码中，如果 getJSON() 正常运行，它将其结果传递给 displayUserProfile()。如果出现异常（用户未登录，服务器关闭，用户的 Internet 连接断开，请求超时等），则 getJSON() 会将 Error 对象传递给 handleProfileError()。</p>
</blockquote>
<p>In practice, it is rare to see two functions passed to then(). There is a better and more idiomatic way of handling errors when working with Promises. To understand it, first consider what happens if getJSON() completes normally but an error occurs in displayUserProfile(). That callback function is invoked asynchronously when getJSON() returns, so it is also asynchronous and cannot meaningfully throw an exception (because there is no code on the call stack to handle it).</p>
<blockquote>
<p>实践中，很少有两个函数传递给 then()。在处理 Promise 时，有一种更好更常用的异常处理方式。为了理解它，首先考虑如果 getJSON() 正常完成但 displayUserProfile() 中发生异常该怎么办。当 getJSON() 返回时，该回调函数将异步调用，因此它也是异步的，并且无法有意义地引发异常（因为调用堆栈上没有代码可以处理该异常）。</p>
</blockquote>
<p>The more idiomatic way to handle errors in this code looks like this:</p>
<blockquote>
<p>如下所示，处理此代码中异常的更常用方式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getJSON</span>(<span class="string">&quot;/api/user/profile&quot;</span>).<span class="title function_">then</span>(displayUserProfile).<span class="title function_">catch</span>(handleProfileError);</span><br></pre></td></tr></table></figure>
<p>With this code, a normal result from getJSON() is still passed to displayUserProfile(), but any error in getJSON() or in displayUserProfile() (including any exceptions thrown by displayUserProfile) get passed to handleProfileError(). The catch() method is just a shorthand for calling then() with a null first argument and the specified error handler function as the second argument.</p>
<blockquote>
<p>使用此代码，getJSON() 的正常结果仍会传递给 displayUserProfile()，但是 getJSON() 或 displayUserProfile() 中的任何异常（包括 displayUserProfile 抛出的任何异常）都将传递给 handleProfileError()。调用 then() 第一个实参为空，指定的异常处理函数为第二个实参，catch() 方法只是其简写。</p>
</blockquote>
<p>We’ll have more to say about catch() and this error-handling idiom when we discuss Promise chains in the next section.</p>
<blockquote>
<p>在下一节中讨论 Promise 链时，我们将对 catch() 和这个处理异常常用方法作更多的说明。</p>
</blockquote>
<h4 id="PROMISE-TERMINOLOGY"><a href="#PROMISE-TERMINOLOGY" class="headerlink" title="PROMISE TERMINOLOGY"></a>PROMISE TERMINOLOGY</h4><p>Before we discuss Promises further, it is worth pausing to define some terms. When we are not programming and we talk about human promises, we say that a promise is “kept” or “broken.” When discussing JavaScript Promises, the equivalent terms are “fulfilled” and “rejected.” Imagine that you have called the then() method of a Promise and have passed two callback functions to it. We say that the promise has been fulfilled if and when the first callback is called. And we say that the Promise has been rejected if and when the second callback is called. If a Promise is neither fulfilled nor rejected, then it is pending. And once a promise is fulfilled or rejected, we say that it is settled. Note that a Promise can never be both fulfilled and rejected. Once a Promise settles, it will never change from fulfilled to rejected or vice versa.</p>
<blockquote>
<p>在我们进一步讨论 Promises 之前，需要暂停定义一些术语。现实生活中，我们讨论下人类的诺言，我们说“信守”或“违背”诺言。在讨论 JavaScript Promise 时，用“已兑现（fulfilled）”和“已拒绝（rejected）”。想象一下，已经调用了 Promise 的 then() 方法，并向其传递了两个回调函数。当调用第一个回调，那么我们说 Promise 已兑现。当调用第二个回调，我们则说 Promise 已被拒绝。如果一个 Promise 既不是已兑现也不是已拒绝，那么它就是待定（pending）。一旦 Promise 已兑现或已拒绝，我们就说它已敲定（settled）。请注意，一个 Promise 永远不会同时已兑现和已拒绝。Promise 一旦敲定，就永远不会从已兑现变为已拒绝，反之亦然。</p>
</blockquote>
<p>Remember how we defined Promises at the start of this section: “a Promise is an object that represents the result of an asynchronous operation.” It is important to remember that Promises are not just abstract ways registering callbacks to run when some async code finishes—they represent the results of that async code. If the async code runs normally (and the Promise is fulfilled), then that result is essentially the return value of the code. And if the async code does not complete normally (and the Promise is rejected), then the result is an Error object or some other value that the code might have thrown if it was not asynchronous. Any Promise that has settled has a value associated with it, and that value will not change. If the Promise is fulfilled, then the value is a return value that gets passed to any callback functions registered as the first argument of then(). If the Promise is rejected, then the value is an error of some sort that is passed to any callback functions registered with catch() or as the second argument of then().</p>
<blockquote>
<p>记住我们在本节开始时如何定义 Promise：“Promise 是描述异步计算结果的对象。”重要的是要记住，Promise 不仅仅是注册在某些异步代码完成时运行的回调的抽象方式，它们还描述了异步代码的结果。如果异步代码正常运行（并且 Promise 已兑现），那么该结果实质上就是代码的返回值。而且，如果异步代码无法正常完成（并且 Promise 已拒绝），那么结果将是 Error 对象或其他不是异步的代码可能会抛出的值。任何已敲定的 Promise 都有与其相关的值，并且该值不会改变。如果 Promise 已兑现，则该值是一个返回值，该值将传递给注册为 then() 第一个实参的回调函数。如果 Promise 已拒绝，则该值是某种异常，该异常会传递给使用 catch() 或 then() 的第二个实参注册的回调函数。</p>
</blockquote>
<p>The reason that I want to be precise about Promise terminology is that Promises can also be resolved. It is easy to confuse this resolved state with the fulfilled state or with settled state, but it is not precisely the same as either. Understanding the resolved state is one of the keys to a deep understanding of Promises, and I’ll come back to it after we’ve discussed Promise chains below.</p>
<blockquote>
<p>我希望对 Promise 术语保持精确的原因是 Promise 还可以被决议。将已决议状态与已兑现状态或已敲定状态混淆是很容易的，但是三者都不完全相同。理解已决议状态是深入了解 Promise 的关键之一，在下面讨论了 Promise 链之后，我将再次介绍它。</p>
</blockquote>
<h3 id="13-2-2-Chaining-Promises"><a href="#13-2-2-Chaining-Promises" class="headerlink" title="13.2.2 Chaining Promises"></a>13.2.2 Chaining Promises</h3><p>One of the most important benefits of Promises is that they provide a natural way to express a sequence of asynchronous operations as a linear chain of then() method invocations, without having to nest each operation within the callback of the previous one. Here, for example, is a hypothetical Promise chain:</p>
<blockquote>
<p>Promise 的最重要的好处之一是，它们提供了一种自然的方式来表达一系列异步操作，表示 then() 方法调用的线性链，而不必将每个操作嵌套在前一个回调中。例如，一个假设的 Promise 链：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(documentURL)                      <span class="comment">// Make an HTTP request</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())  <span class="comment">// Ask for the JSON body of the response</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">document</span> =&gt;</span> &#123;                 <span class="comment">// When we get the parsed JSON</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">render</span>(<span class="variable language_">document</span>);        <span class="comment">// display the document to the user</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">rendered</span> =&gt;</span> &#123;                 <span class="comment">// When we get the rendered document</span></span><br><span class="line">        <span class="title function_">cacheInDatabase</span>(rendered);      <span class="comment">// cache it in the local database.</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="title function_">handle</span>(error));     <span class="comment">// Handle any errors that occur</span></span><br></pre></td></tr></table></figure>
<p>This code illustrates how a chain of Promises can make it easy to express a sequence of asynchronous operations. We’re not going to discuss this particular Promise chain at all, however. We will continue to explore the idea of using Promise chains to make HTTP requests, however.</p>
<blockquote>
<p>此代码表明了 Promise 链如何简化一系列异步操作。我们不会讨论这个特殊的 Promise 链。但是，我们将继续探索使用 Promise 链发出 HTTP 请求的想法。 </p>
</blockquote>
<p>Earlier in this chapter, we saw the XMLHttpRequest object used to make an HTTP request in JavaScript. That strangely named object has an old and awkward API, and it has largely been replaced by the newer, Promise-based Fetch API (§15.11.1). In its simplest form, this new HTTP API is just the function fetch(). You pass it a URL, and it returns a Promise. That promise is fulfilled when the HTTP response begins to arrive and the HTTP status and headers are available:</p>
<blockquote>
<p>在本章的前面，我们看到了 XMLHttpRequest 对象，该对象用于在 JavaScript 中发出 HTTP 请求。这个奇怪命名的对象具有一个旧且笨拙的 API，并且在很大程度上已被较新的基于 Promise 的 Fetch API（§15.11.1）所取代。以最简单的形式，这个新的 HTTP API 只是 fetch() 函数。给它传递一个 URL，然后返回一个 Promise。当 HTTP 开始收到响应并且 HTTP 状态和标头可用时，这个 promise 已兑现：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// When the promise resolves, we have status and headers</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">ok</span> &amp;&amp;</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;Content-Type&quot;</span>) === <span class="string">&quot;application/json&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// What can we do here? We don&#x27;t actually have the response body yet.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>When the Promise returned by fetch() is fulfilled, it passes a Response object to the function you passed to its then() method. This response object gives you access to request status and headers, and it also defines methods like text() and json(), which give you access to the body of the response in text and JSON-parsed forms, respectively. But although the initial Promise is fulfilled, the body of the response may not yet have arrived. So these text() and json() methods for accessing the body of the response themselves return Promises. Here’s a naive way of using fetch() and the response.json() method to get the body of an HTTP response:</p>
<blockquote>
<p>当 fetch() 返回的 Promise 已兑现时，它将 Response 对象传递给传递给 then() 方法的函数。此响应对象可以访问请求状态和标头，并且还定义了诸如 text() 和 json() 之类的方法，这些方法可以分别以文本和 JSON 的形式访问响应的正文。但是，尽管最初的 Promise 已兑现，但响应的主体可能尚未到达。因此，这些用于访问响应正文的 text() 和 json() 方法本身返回 Promise。这是使用 fetch() 和 response.json() 方法获取 HTTP Response 响应正文的一种简单方法： </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    response.<span class="title function_">json</span>().<span class="title function_">then</span>(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;  <span class="comment">// Ask for the JSON-parsed body</span></span><br><span class="line">        <span class="comment">// When the body of the response arrives, it will be automatically</span></span><br><span class="line">        <span class="comment">// parsed as JSON and passed to this function.</span></span><br><span class="line">        <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This is a naive way to use Promises because we nested them, like callbacks, which defeats the purpose. The preferred idiom is to use Promises in a sequential chain with code like this:</p>
<blockquote>
<p>这是 Promise 一种没经验的使用方式，因为我们像回调一样嵌套了它们，这违背了目的。首选常用方法是在顺序链中使用 Promise，其代码如下所示： </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>Let’s look at the method invocations in this code, ignoring the arguments that are passed to the methods:</p>
<blockquote>
<p>让我们看一下这段代码中的方法调用，忽略传递给方法的参数： </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>().<span class="title function_">then</span>().<span class="title function_">then</span>()</span><br></pre></td></tr></table></figure>
<p>When more than one method is invoked in a single expression like this, we call it a method chain. We know that the fetch() function returns a Promise object, and we can see that the first .then() in this chain invokes a method on that returned Promise object. But there is a second .then() in the chain, which means that the first invocation of the then() method must itself return a Promise.</p>
<blockquote>
<p>当像这样在单个表达式中调用多个方法时，我们将其称为方法链。我们知道 fetch() 函数返回一个 Promise 对象，并且可以看到该链中的第一个 .then() 作为返回的 Promise 对象的方法调用。但是链中还有第二个 .then()，这意味着 then() 方法的第一次调用本身一定返回 Promise。</p>
</blockquote>
<p>Sometimes, when an API is designed to use this kind of method chaining, there is just a single object, and each method of that object returns the object itself in order to facilitate chaining. That is not how Promises work, however. When we write a chain of .then() invocations, we are not registering multiple callbacks on a single Promise object. Instead, each invocation of the then() method returns a new Promise object. That new Promise object is not fulfilled until the function passed to then() is complete.</p>
<blockquote>
<p>有时，当一个 API 设计为使用这种方法链接时，只有一个对象，并且该对象的每个方法都返回该对象本身以便于链接。但是，这不是 Promise 的工作方式。当我们编写一系列的 .then() 调用时，我们并未在单个 Promise 对象上注册多个回调。而是，对 then() 方法的每次调用都会返回一个新的 Promise 对象。在传递给 then() 的函数完成之前，新的 Promise 对象不会被兑现。</p>
</blockquote>
<p>Let’s return to a simplified form of the original fetch() chain above. If we define the functions passed to the then() invocations elsewhere, we might refactor the code to look like this:</p>
<blockquote>
<p>让我们回到上面原始 fetch() 链的简化形式。如果我们在其他地方定义传递给 then() 调用的函数，则可以将代码重构为如下形式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(theURL)          <span class="comment">// task 1; returns promise 1</span></span><br><span class="line">    .<span class="title function_">then</span>(callback1)   <span class="comment">// task 2; returns promise 2</span></span><br><span class="line">    .<span class="title function_">then</span>(callback2);  <span class="comment">// task 3; returns promise 3</span></span><br></pre></td></tr></table></figure>
<p>Let’s walk through this code in detail:</p>
<blockquote>
<p>让我们详细介绍这段代码：</p>
</blockquote>
<ol>
<li>On the first line, fetch() is invoked with a URL. It initiates an HTTP GET request for that URL and returns a Promise. We’ll call this HTTP request “task 1” and we’ll call the Promise “promise 1”.</li>
<li>On the second line, we invoke the then() method of promise 1, passing the callback1 function that we want to be invoked when promise 1 is fulfilled. The then() method stores our callback somewhere, then returns a new Promise. We’ll call the new Promise returned at this step “promise 2”, and we’ll say that “task 2” begins when callback1 is invoked.</li>
<li>On the third line, we invoke the then() method of promise 2, passing the callback2 function we want invoked when promise 2 is fulfilled. This then() method remembers our callback and returns yet another Promise. We’ll say that “task 3” begins when callback2 is invoked. We can call this latest Promise “promise 3”, but we don’t really need a name for it because we won’t be using it at all.</li>
<li>The previous three steps all happen synchronously when the expression is first executed. Now we have an asynchronous pause while the HTTP request initiated in step 1 is sent out across the internet.</li>
<li>Eventually, the HTTP response starts to arrive. The asynchronous part of the fetch() call wraps the HTTP status and headers in a Response object and fulfills promise 1 with that Response object as the value.</li>
<li>When promise 1 is fulfilled, its value (the Response object) is passed to our callback1() function, and task 2 begins. The job of this task, given a Response object as input, is to obtain the response body as a JSON object.</li>
<li>Let’s assume that task 2 completes normally and is able to parse the body of the HTTP response to produce a JSON object. This JSON object is used to fulfill promise 2.</li>
<li>The value that fulfills promise 2 becomes the input to task 3 when it is passed to the callback2() function. This third task now displays the data to the user in some unspecified way. When task 3 is complete (assuming it completes normally), then promise 3 will be fulfilled. But because we never did anything with promise 3, nothing happens when that Promise settles, and the chain of asynchronous computation ends at this point.</li>
</ol>
<blockquote>
<ol>
<li>在第一行，使用 URL 调用 fetch()。它针对该 URL 发起 HTTP GET请求并返回 Promise。我们将这个 HTTP 请求称为“task 1”，将 Promise 称为“promise 1”。</li>
<li>在第二行，我们调用 promise 1 的 then() 方法，并传递 promise 1 在已兑现时要调用的 callback1 函数。then() 方法将回调函数存储在某个位置，然后返回一个新的 Promise。我们将在这一步返回的新 Promise 称为“promise 2”，并且我们说当 callback1 被调用时“task 2”开始。</li>
<li>在第三行，我们调用 promise 2 的 then() 方法，并传递 promise 2 在已兑现时要调用的 callback2 函数。这个 then() 方法会记住我们的回调并返回另一个 Promise。我们说“task 3”是在调用 callback2 时开始的。我们可以将最新的 Promise 称为“promise 3”，但是我们并不需要它的名称，因为我们根本不会使用它。</li>
<li>最初执行表达式时，前三个步骤都是同步发生的。现在，在第 1 步中启动的 HTTP 请求通过 Internet 发送时，我们有了异步暂停。</li>
<li>最终，HTTP 响应开始到达。fetch() 调用的异步部分将 HTTP 状态和标头包装在 Response 对象中，并以该 Response 对象作为值来兑现 promise 1。</li>
<li>promise 1 已兑现后，其值（Response 对象）将传递到我们的 callback1() 函数，task 2 开始。以 Response 对象作为输入，此任务的工作是获得响应主体转化为 JSON 对象。</li>
<li>假设 task 2 正常完成，并且能够解析 HTTP 响应主体以生成 JSON 对象。此 JSON 对象用于兑现 promise 2。</li>
<li>兑现 promise 2 的值在传递给 callback2() 函数时成为 task 3 的输入。现在，第三个任务以某种未指定的方式向用户显示数据。当 task 3 完成时（假设它正常完成），则 promise 3 将被兑现。但是，因为我们从未对 promise 3 做任何事情，所以当 promise 3 敲定时，什么也没有发生，并且异步计算链到此结束。</li>
</ol>
</blockquote>
<h3 id="13-2-3-Resolving-Promises"><a href="#13-2-3-Resolving-Promises" class="headerlink" title="13.2.3 Resolving Promises"></a>13.2.3 Resolving Promises</h3><p>While explaining the URL-fetching Promise chain with the list in the last section, we talked about promises 1, 2, and 3. But there is actually a fourth Promise object involved as well, and this brings us to our important discussion of what it means for a Promise to be “resolved.”</p>
<blockquote>
<p>在上一部分中用列表解释 URL-fetching Promise 链时，我们讨论了 promise 1、2 和 3。但是实际上也涉及第四个 Promise 对象，并且这为我们带来重要的讨论————什么是 Promise 的“已决议（resolved）”状态 。 </p>
</blockquote>
<p>Remember that fetch() returns a Promise object which, when fulfilled, passes a Response object to the callback function we register. This Response object has .text(), .json(), and other methods to request the body of the HTTP response in various forms. But since the body may not yet have arrived, these methods must return Promise objects. In the example we’ve been studying, “task 2” calls the .json() method and returns its value. This is the fourth Promise object, and it is the return value of the callback1() function.</p>
<blockquote>
<p>请记住，fetch() 返回一个 Promise 对象，当其已兑现时，它将 Response 对象传递给我们注册的回调函数。此 Response 对象具有 .text()、.json() 和其他方法，以各种形式请求 HTTP 响应的主体。但是由于主体可能尚未到达，因此这些方法必须返回 Promise 对象。在我们一直在研究的示例中，“task 2”调用 .json() 方法并返回其值。这是第四个 Promise 对象，它是 callback1() 函数的返回值。</p>
</blockquote>
<p>Let’s rewrite the URL-fetching code one more time in a verbose and nonidiomatic way that makes the callbacks and promises explicit:</p>
<blockquote>
<p>让我们以冗长且非常用方式再次重写 URL-fetching 代码，使回调和 Promise 明确化：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">c1</span>(<span class="params">response</span>) &#123;               <span class="comment">// callback 1</span></span><br><span class="line">    <span class="keyword">let</span> p4 = response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> p4;                        <span class="comment">// returns promise 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">c2</span>(<span class="params">profile</span>) &#123;                <span class="comment">// callback 2</span></span><br><span class="line">    <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>);  <span class="comment">// promise 1, task 1</span></span><br><span class="line"><span class="keyword">let</span> p2 = p1.<span class="title function_">then</span>(c1);                 <span class="comment">// promise 2, task 2</span></span><br><span class="line"><span class="keyword">let</span> p3 = p2.<span class="title function_">then</span>(c2);                 <span class="comment">// promise 3, task 3</span></span><br></pre></td></tr></table></figure>
<p>In order for Promise chains to work usefully, the output of task 2 must become the input to task 3. And in the example we’re considering here, the input to task 3 is the body of the URL that was fetched, parsed as a JSON object. But, as we’ve just discussed, the return value of callback c1 is not a JSON object, but Promise p4 for that JSON object. This seems like a contradiction, but it is not: when p1 is fulfilled, c1 is invoked, and task 2 begins. And when p2 is fulfilled, c2 is invoked, and task 3 begins. But just because task 2 begins when c1 is invoked, it does not mean that task 2 must end when c1 returns. Promises are about managing asynchronous tasks, after all, and if task 2 is asynchronous (which it is, in this case), then that task will not be complete by the time the callback returns.</p>
<blockquote>
<p>为了使 Promise 链有效地工作，task 2 的输出必须成为 task 3 的输入。在此示例中，我们在这里考虑的是，task 3 的输入是从 URL 所获取的的主体，将其解析为 JSON 对象。但是，正如我们刚刚讨论的那样，回调 c1 的返回值不是 JSON 对象，而是该 JSON 对象的 Promise p4。这似乎有矛盾，但并非如此：当 p1 已兑现时，将调用 c1，并且 task 2 开始。当 p2 已兑现时，c2 被调用，task 3 开始。但是，仅仅因为 c1 被调用时开始 task 2 ，可这并不意味着 task 2 必须在 c1 返回时结束。毕竟，Promise 是关于管理异步任务的，如果 task 2 是异步的（在本例中为异步），则在回调返回时该任务将不会完成。</p>
</blockquote>
<p>We are now ready to discuss the final detail that you need to understand to really master Promises. When you pass a callback c to the then() method, then() returns a Promise p and arranges to asynchronously invoke c at some later time. The callback performs some computation and returns a value v. When the callback returns, p is resolved with the value v. When a Promise is resolved with a value that is not itself a Promise, it is immediately fulfilled with that value. So if c returns a non-Promise, that return value becomes the value of p, p is fulfilled and we are done. But if the return value v is itself a Promise, then p is resolved but not yet fulfilled. At this stage, p cannot settle until the Promise v settles. If v is fulfilled, then p will be fulfilled to the same value. If v is rejected, then p will be rejected for the same reason. This is what the “resolved” state of a Promise means: the Promise has become associated with, or “locked onto,” another Promise. We don’t know yet whether p will be fulfilled or rejected, but our callback c no longer has any control over that. p is “resolved” in the sense that its fate now depends entirely on what happens to Promise v.</p>
<blockquote>
<p>现在我们准备讨论最后的细节，需要了解这些才能真正掌握 Promise。当将回调 c 传递给 then() 方法时，then() 返回 Promise p 并安排在以后的某个时间异步调用  c。调执行一些计算并返回值 v。当回调返回时，p 用值 v 决议。当 Promise 使用不是本身的 Promise 值决议时，立即用该值兑现。因此，如果 c 返回一个非 Promise，则返回值成为 p 的值，则 p 已兑现并且任务完成。但是，如果返回值 v 本身是一个 Promise，则 p 已决议但尚未兑现。在此阶段，直到 Promise v 敲定，p 才能敲定。如果 v 已兑现，则 p 将被兑现为相同的值。如果 v 已拒绝，则 p 将因相同的原因而被拒绝。这就是一个 Promise 的“已决议（resolved）”状态的含义：Promise 已与另一个 Promise 关联或“锁定”。我们尚不知道 p 是已兑现还是拒绝，但是我们的回调 c 对此不再具有任何控制权。p 是“已决议”的，从这一方面来说它命运现在完全取决于 Promise v 会发生什么。</p>
</blockquote>
<p>Let’s bring this back to our URL-fetching example. When c1 returns p4, p2 is resolved. But being resolved is not the same as being fulfilled, so task 3 does not begin yet. When the full body of the HTTP response becomes available, then the .json() method can parse it and use that parsed value to fulfill p4. When p4 is fulfilled, p2 is automatically fulfilled as well, with the same parsed JSON value. At this point, the parsed JSON object is passed to c2, and task 3 begins.</p>
<blockquote>
<p>让我们回到我们的 URL-fetching 示例中。 当 c1 返回 p4 时，p2 已决议。但是已决议与已兑现并不相同，因此 task 3 尚未开始。当 HTTP 响应的全文可用时，.json() 方法可以对其进行解析，并使用该解析后的值来已兑现 p4。 当 p4 已兑现时，也会使用相同的已解析 JSON 值自动已兑现 p2。此时，已解析的 JSON 对象将传递给 c2，然后 task 3 开始。</p>
</blockquote>
<p>This can be one of the trickiest parts of JavaScript to understand, and you may need to read this section more than once. Figure 13-1 presents the process in visual form and may help clarify it for you.</p>
<blockquote>
<p>这可能是 JavaScript 最难理解的部分之一，可能需要多次阅读本节。图 13-1 以可视形式显示了该过程，可能有助于对其进行说明。</p>
</blockquote>
<p><Figures figure="13-1">Fetching a URL with Promises</Figures></p>
<h3 id="13-2-4-More-on-Promises-and-Errors"><a href="#13-2-4-More-on-Promises-and-Errors" class="headerlink" title="13.2.4 More on Promises and Errors"></a>13.2.4 More on Promises and Errors</h3><p>Earlier in the chapter, we saw that you can pass a second callback function to the .then() method and that this second function will be invoked if the Promise is rejected. When that happens, the argument to this second callback function is a value—typically an Error object—that represents the reason for the rejection. We also learned that it is uncommon (and even unidiomatic) to pass two callbacks to a .then() method. Instead, Promise-related errors are typically handled by adding a .catch() method invocation to a Promise chain. Now that we have examined Promise chains, we can return to error handling and discuss it in more detail. To preface the discussion, I’d like to stress that careful error handling is really important when doing asynchronous programming. With synchronous code, if you leave out error-handling code, you’ll at least get an exception and a stack trace that you can use to figure out what is going wrong. With asynchronous code, unhandled exceptions will often go unreported, and errors can occur silently, making them much harder to debug. The good news is that the .catch() method makes it easy to handle errors when working with Promises.</p>
<blockquote>
<p>在本章的前面，我们看到可以将第二个回调函数传递给 .then() 方法，并且如果 Promise 被拒绝，则将调用该第二个函数。发生这种情况时，第二个回调函数的实参是一个值（通常是一个 Error 对象），它表示拒绝的原因。我们还了解到，将两个回调传递给 .then() 方法并不常见（甚至是单例的）。相反，通常通过向 Promise 链添加 .catch() 方法调用来处理与 Promise 相关的异常。现在我们已经检查了 Promise 链，我们可以返回异常处理并更详细地讨论它。在开始讨论之前，我想强调指出，进行异步编程时，仔细的异常处理非常重要。使用同步代码，如果省略了异常处理代码，则至少会得到一个异常和一个堆栈跟踪，可用于找出问题所在。对于异步代码，未处理的异常通常不会报告，异常可以静默发生，从而使调试更加困难。好消息是，使用 .catch() 方法可以更轻松地处理 Promise 的异常。</p>
</blockquote>
<h4 id="THE-CATCH-AND-FINALLY-METHODS"><a href="#THE-CATCH-AND-FINALLY-METHODS" class="headerlink" title="THE CATCH AND FINALLY METHODS"></a>THE CATCH AND FINALLY METHODS</h4><p>The .catch() method of a Promise is simply a shorthand way to call .then() with null as the first argument and an error-handling callback as the second argument. Given any Promise p and a callback c, the following two lines are equivalent:</p>
<blockquote>
<p>.then() 可以处理异常，使用 null 为第一个实参，而异常处理回调为第二个实参，Promise 的 .catch() 方法只是这种 .then() 调用的一种简便写法。给定 Promise p 和回调 c，以下两行代码是等效的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="title function_">then</span>(<span class="literal">null</span>, c);</span><br><span class="line">p.<span class="title function_">catch</span>(c);</span><br></pre></td></tr></table></figure>
<p>The .catch() shorthand is preferred because it is simpler and because the name matches the catch clause in a try&#x2F;catch exception-handling statement. As we’ve discussed, normal exceptions don’t work with asynchronous code. The .catch() method of Promises is an alternative that does work for asynchronous code. When something goes wrong in synchronous code, we can speak of an exception “bubbling up the call stack” until it finds a catch block. With an asynchronous chain of Promises, the comparable metaphor might be of an error “trickling down the chain” until it finds a .catch() invocation.</p>
<blockquote>
<p>首选 .catch() 速记，因为它更简单，并且名称与 try&#x2F;catch 异常处理语句中的 catch 子句匹配。正如我们所讨论的，普通例外不适用于异步代码。Promise 的 .catch() 方法是一种适用于异步代码的替代方法。当同步代码中出现问题时，我们“使调用堆栈冒泡”描述一个异常，直到找到 catch 块为止。对于异步的 Promise 链，则是“向链下滴”，直到找到 .catch() 调用为止。</p>
</blockquote>
<p>In ES2018, Promise objects also define a .finally() method whose purpose is similar to the finally clause in a try&#x2F;catch&#x2F;finally statement. If you add a .finally() invocation to your Promise chain, then the callback you pass to .finally() will be invoked when the Promise you called it on settles. Your callback will be invoked if the Promise fulfills or rejects, and it will not be passed any arguments, so you can’t find out whether it fulfilled or rejected. But if you need to run some kind of cleanup code (such as closing open files or network connections) in either case, a .finally() callback is the ideal way to do that. Like .then() and .catch(), .finally() returns a new Promise object. The return value of a .finally() callback is generally ignored, and the Promise returned by .finally() will typically resolve or reject with the same value that the Promise that .finally() was invoked on resolves or rejects with. If a .finally() callback throws an exception, however, then the Promise returned by .finally() will reject with that value.</p>
<blockquote>
<p>在 ES2018 中，Promise 对象还定义了一个 .finally() 方法，其目的类似于 try&#x2F;catch&#x2F;finally 语句中的 finally 子句。如果将 .finally() 调用添加到 Promise 链中，那么 .finally() 的调用者 Promise 的敲定的时候，传递给 .finally() 的回调将被调用。如果 Promise 已兑现或已拒绝，则将调用回调，并且它不会再作为实参传递，因此无法确定它是已兑现还是已拒绝。但是，无论哪种情况，如果都需要运行某种清理代码（例如关闭打开的文件或网络连接），则 .finally() 回调是实现此目的的理想方法。与 .then() 和 .catch() 一样，.finally() 返回一个新的 Promise 对象。.finally() 回调的返回值通常被忽略，.finally() 返回的 Promise 通常将以调用 .finally() 的 Promise 相同的值来决议或拒绝。但是，如果 .finally() 回调引发异常，则 .finally() 返回的 Promise 以该异常值拒绝。</p>
</blockquote>
<p>The URL-fetching code that we studied in the previous sections did not do any error handling. Let’s correct that now with a more realistic version of the code:</p>
<blockquote>
<p>我们在上一节中研究的 URL-fetching 代码没有任何异常处理。现在，使用更可行的代码版本进行更正：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>)    <span class="comment">// Start the HTTP request</span></span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;       <span class="comment">// Call this when status and headers are ready</span></span><br><span class="line">        <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;   <span class="comment">// If we got a 404 Not Found or similar error</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;      <span class="comment">// Maybe user is logged out; return null profile</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now check the headers to ensure that the server sent us JSON.</span></span><br><span class="line">        <span class="comment">// If not, our server is broken, and this is a serious error!</span></span><br><span class="line">        <span class="keyword">let</span> type = response.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;content-type&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (type !== <span class="string">&quot;application/json&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`Expected JSON, got <span class="subst">$&#123;type&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we get here, then we got a 2xx status and a JSON content-type</span></span><br><span class="line">        <span class="comment">// so we can confidently return a Promise for the response</span></span><br><span class="line">        <span class="comment">// body as a JSON object.</span></span><br><span class="line">        <span class="keyword">return</span> response.<span class="title function_">json</span>();</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">profile</span> =&gt;</span> &#123;        <span class="comment">// Called with the parsed response body or null</span></span><br><span class="line">        <span class="keyword">if</span> (profile) &#123;</span><br><span class="line">            <span class="title function_">displayUserProfile</span>(profile);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// If we got a 404 error above and returned null we end up here</span></span><br><span class="line">            <span class="title function_">displayLoggedOutProfilePage</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">NetworkError</span>) &#123;</span><br><span class="line">            <span class="comment">// fetch() can fail this way if the internet connection is down</span></span><br><span class="line">            <span class="title function_">displayErrorMessage</span>(<span class="string">&quot;Check your internet connection.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> <span class="title class_">TypeError</span>) &#123;</span><br><span class="line">            <span class="comment">// This happens if we throw TypeError above</span></span><br><span class="line">            <span class="title function_">displayErrorMessage</span>(<span class="string">&quot;Something is wrong with our server!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// This must be some kind of unanticipated error</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>Let’s analyze this code by looking at what happens when things go wrong. We’ll use the naming scheme we used before: p1 is the Promise returned by the fetch() call. p2 is the Promise returned by the first .then() call, and c1 is the callback that we pass to that .then() call. p3 is the Promise returned by the second .then() call, and c2 is the callback we pass to that call. Finally, c3 is the callback that we pass to the .catch() call. (That call returns a Promise, but we don’t need to refer to it by name.)</p>
<blockquote>
<p>让我们通过发生异常情况情况来分析此代码。我们将使用之前使用的命名方案：p1 是 fetch() 调用返回的 Promise。p2 是第一个 .then() 调用返回的 Promise，而 c1 是我们传递给该 .then() 的回调。p3 是第二个 .then() 调用返回的 Promise，而 c2 是我们传递给该调用的回调。最后，c3 是我们传递给 .catch() 的回调。（该调用返回一个 Promise，但我们不需要按名称引用它。）</p>
</blockquote>
<p>The first thing that could fail is the fetch() request itself. If the network connection is down (or for some other reason an HTTP request cannot be made), then Promise p1 will be rejected with a NetworkError object. We didn’t pass an error-handling callback function as the second argument to the .then() call, so p2 rejects as well with the same NetworkError object. (If we had passed an error handler to that first .then() call, the error handler would be invoked, and if it returned normally, p2 would be resolved and&#x2F;or fulfilled with the return value from that handler.) Without a handler, though, p2 is rejected, and then p3 is rejected for the same reason. At this point, the c3 error-handling callback is called, and the NetworkError-specific code within it runs.</p>
<blockquote>
<p>第一个可能失败的是 fetch() 请求本身。如果网络连接断开（或由于某些其他原因而无法发出 HTTP 请求），则 Promise p1 将被 NetworkError 对象拒绝。我们没有将异常处理回调函数作为 .then() 调用的第二个实参传递，因此 p2 同样会被相同的 NetworkError 对象拒绝。（如果将异常处理程序传递给第一个 .then() 调用，则将调用该异常处理程序，并且如果该异常处理程序正常返回，伴随处理的返回值，p2 变为已决议和或或已兑现。）但是，出于相同的原因，p2 被拒绝，然后 p3 被拒绝。此时，将调用 c3 异常处理回调，并在其中运行特定于 NetworkError 的代码。</p>
</blockquote>
<p>Another way our code could fail is if our HTTP request returns a 404 Not Found or another HTTP error. These are valid HTTP responses, so the fetch() call does not consider them errors. fetch() encapsulates a 404 Not Found in a Response object and fulfills p1 with that object, causing c1 to be invoked. Our code in c1 checks the ok property of the Response object to detect that it has not received a normal HTTP response and handles that case by simply returning null. Because this return value is not a Promise, it fulfills p2 right away, and c2 is invoked with this value. Our code in c2 explicitly checks for and handles falsy values by displaying a different result to the user. This is a case where we treat an abnormal condition as a nonerror and handle it without actually using an error handler.</p>
<blockquote>
<p>代码失败的另一种方式是，如果我们的 HTTP 请求返回 404 Not Found 或另一个 HTTP 异常。这些是有效的 HTTP 响应，因此 fetch() 调用不会将其视为异常。fetch() 在 Response 对象中封装了一个 404 Not Found，并用该对象已兑现 p1，从而导致 c1 被调用。我们在 c1 中的代码检查 Response 对象的 ok 属性，以检测它没有收到正常的 HTTP 响应，并通过简单地返回 null 来处理这种情况。因为此返回值不是 Promise，所以它立即已兑现 p2，并使用该值调用 c2。 我们在 c2 中的代码显式检查并处理错误值，并向用户显示不同的结果。在这种情况下，我们将异常情况视为非异常，并在不使用异常处理程序的情况下对其进行处理。</p>
</blockquote>
<p>A more serious error occurs in c1 if the we get a normal HTTP response code but the Content-Type header is not set appropriately. Our code expects a JSON-formatted response, so if the server is sending us HTML, XML, or plain text instead, we’re going to have a problem. c1 includes code to check the Content-Type header. If the header is wrong, it treats this as a nonrecoverable problem and throws a TypeError. When a callback passed to .then() (or .catch()) throws a value, the Promise that was the return value of the .then() call is rejected with that thrown value. In this case, the code in c1 that raises a TypeError causes p2 to be rejected with that TypeError object. Since we did not specify an error handler for p2, p3 will be rejected as well. c2 will not be called, and the TypeError will be passed to c3, which has code to explicitly check for and handle this type of error.</p>
<blockquote>
<p>如果我们获得正常的 HTTP 响应代码，但 Content-Type 标头设置不正确，则 c1 中会发生更严重的异常。我们的代码需要一个 JSON 格式的响应，因此，如果服务器发送给我们的是 HTML、XML 或纯文本，那么我们将会遇到问题。c1 包含用于检查 Content-Type 标头的代码。如果标头错误，则将其视为不可恢复的问题，并引发 TypeError。当传递给 .then()（或 .catch()）的回调引发一个值时，作为 .then() 调用的返回的 Promise 将被该抛出的值拒绝。在这种情况下，c1 中的代码引发 TypeError 导致带有 TypeError 对象的 p2 一起被拒绝。由于我们没有为 p2 指定异常处理程序，因此 p3 也将被拒绝。c2 将不会被调用，并且 TypeError 将传递给 c3，后者具有显式检查和处理此类异常的代码。</p>
</blockquote>
<p>There are a couple of things worth noting about this code. First, notice that the error object thrown with a regular, synchronous throw statement ends up being handled asynchronously with a .catch() method invocation in a Promise chain. This should make it clear why this shorthand method is preferred over passing a second argument to .then(), and also why it is so idiomatic to end Promise chains with a .catch() call.</p>
<blockquote>
<p>关于此代码有些得注意。首先，请注意用常规的同步 throw 语句引发的异常对象最终会通过 Promise 链中的 .catch() 方法调用进行异步捕获。这清楚表明为什么与将第二个实参传递给 .then() 相比更偏向使用这种速记方法，以及为什么习惯以 .catch() 调用结束 Promise 链。</p>
</blockquote>
<p>Before we leave the topic of error handling, I want to point out that, although it is idiomatic to end every Promise chain with a .catch() to clean up (or at least log) any errors that occurred in the chain, it is also perfectly valid to use .catch() elsewhere in a Promise chain. If one of the stages in your Promise chain can fail with an error, and if the error is some kind of recoverable error that should not stop the rest of the chain from running, then you can insert a .catch() call in the chain, resulting in code that might look like this:</p>
<blockquote>
<p>在我们结束异常处理主题之前，我想指出，尽管习惯于在每个 Promise 链中添加一个 .catch() 来清理（或至少记录日志）该链中发生的任何异常，但是在 Promise 链中的其他位置使用 .catch() 也完全有效。如果 Promise 链中的某一阶段可能因异常而失败，并且该异常是某种可恢复的异常，并且该异常不会阻止链的其余部分运行，则可以在链中插入 .catch() 调用，代码可能如下所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">startAsyncOperation</span>()</span><br><span class="line">    .<span class="title function_">then</span>(doStageTwo)</span><br><span class="line">    .<span class="title function_">catch</span>(recoverFromStageTwoError)</span><br><span class="line">    .<span class="title function_">then</span>(doStageThree)</span><br><span class="line">    .<span class="title function_">then</span>(doStageFour)</span><br><span class="line">    .<span class="title function_">catch</span>(logStageThreeAndFourErrors);</span><br></pre></td></tr></table></figure>
<p>Remember that the callback you pass to .catch() will only be invoked if the callback at a previous stage throws an error. If the callback returns normally, then the .catch() callback will be skipped, and the return value of the previous callback will become the input to the next .then() callback. Also remember that .catch() callbacks are not just for reporting errors, but for handling and recovering from errors. Once an error has been passed to a .catch() callback, it stops propagating down the Promise chain. A .catch() callback can throw a new error, but if it returns normally, than that return value is used to resolve and&#x2F;or fulfill the associated Promise, and the error stops propagating.</p>
<blockquote>
<p>请记住，仅当前一阶段的回调引发异常时，才会调用传递给 catch() 的回调。如果该回调正常返回，则将跳过 catch() 回调，并且前一个回调的返回值将成为下一个 then() 回调的输入。还请记住，catch() 回调不仅用于异常报告，而且用于异常处理并从异常中恢复。将异常传递给 catch() 回调后，它将停止沿 Promise 链传播。catch() 回调可以引发新的异常，但是如果它正常返回，则该返回值用于决议和或或兑现关联的 Promise，并且异常停止传播。</p>
</blockquote>
<p>Let’s be concrete about this: in the preceding code example, if either startAsyncOperation() or doStageTwo() throws an error, then the recoverFromStageTwoError() function will be invoked. If recoverFromStageTwoError() returns normally, then its return value will be passed to doStageThree() and the asynchronous operation continues normally. On the other hand, if recoverFromStageTwoError() was unable to recover, it will itself throw an error (or it will rethrow the error that it was passed). In this case, neither doStageThree() nor doStageFour() will be invoked, and the error thrown by recoverFromStageTwoError() would be passed to logStageThreeAndFourErrors().</p>
<blockquote>
<p>让我们具体地讲一下：在前面的代码示例中，如果 startAsyncOperation() 或 doStageTwo() 引发异常，则将调用 recoveryFromStageTwoError() 函数。如果 restoreFromStageTwoError() 正常返回，则其返回值将传递给 doStageThree()，并且异步操作将正常继续。另一方面，如果 recoverFromStageTwoError() 无法恢复，则它本身将引发异常（或者重新抛出传入的异常）。在这种情况下，不会调用 doStageThree() 或 doStageFour()，并且 recoverFromStageTwoError() 引发的异常将传递给 logStageThreeAndFourErrors()。</p>
</blockquote>
<p>Sometimes, in complex network environments, errors can occur more or less at random, and it can be appropriate to handle those errors by simply retrying the asynchronous request. Imagine you’ve written a Promise-based operation to query a database:</p>
<blockquote>
<p>有时，在复杂的网络环境中，异常可能会或多或少地随机发生，并且可以通过简单地重试异步请求来处理这些异常。假设编写了一个基于 Promise 的操作来查询数据库：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">queryDatabase</span>()</span><br><span class="line">    .<span class="title function_">then</span>(displayTable)</span><br><span class="line">    .<span class="title function_">catch</span>(displayDatabaseError);</span><br></pre></td></tr></table></figure>
<p>Now suppose that transient network load issues are causing this to fail about 1% of the time. A simple solution might be to retry the query with a .catch() call:</p>
<blockquote>
<p>现在，假设大约 1％ 的概率瞬态网络负载问题导致其失败。一个简单的解决方案可能是使用 .catch() 调用重试查询：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">queryDatabase</span>()</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">wait</span>(<span class="number">500</span>).<span class="title function_">then</span>(queryDatabase))  <span class="comment">// On failure, wait and retry</span></span><br><span class="line">    .<span class="title function_">then</span>(displayTable)</span><br><span class="line">    .<span class="title function_">catch</span>(displayDatabaseError);</span><br></pre></td></tr></table></figure>
<p>If the hypothetical failures are truly random, then adding this one line of code should reduce your error rate from 1% to .01%.</p>
<blockquote>
<p>如果假设的失败确实是随机的，那么添加这一行代码应使错误率从 1％ 降低到 .01％。</p>
</blockquote>
<h4 id="RETURNING-FROM-A-PROMISE-CALLBACK"><a href="#RETURNING-FROM-A-PROMISE-CALLBACK" class="headerlink" title="RETURNING FROM A PROMISE CALLBACK"></a>RETURNING FROM A PROMISE CALLBACK</h4><p>Let’s return one last time to the earlier URL-fetching example, and consider the c1 callback that we passed to the first .then() invocation. Notice that there are three ways that c1 can terminate. It can return normally with the Promise returned by the .json() call. This causes p2 to be resolved, but whether that Promise is fulfilled or rejected depends on what happens with the newly returned Promise. c1 can also return normally with the value null, which causes p2 to be fulfilled immediately. Finally, c1 can terminate by throwing an error, which causes p2 to be rejected. These are the three possible outcomes for a Promise, and the code in c1 demonstrates how the callback can cause each outcome.</p>
<blockquote>
<p>让我们最后一次返回前面的 URL-fetching 示例，并考虑传递给第一个 .then() 调用的回调 c1。注意，c1 可以通过三种方式终止。它可以通过 .json() 调用返回的 Promise 正常返回。这将导致 p2 变为已决议，但是该 Promise 是已兑现还是拒绝取决于新返回的 Promise 发生了什么。c1 也可以正常返回 null 值，这将导致 p2 立即变成已兑现。最后，c1 可以通过引发异常来终止，从而导致 p2 变成已拒绝。这是 Promise 的三个可能结果，而 c1 中的代码演示了回调如何导致每个结果。</p>
</blockquote>
<p>In a Promise chain, the value returned (or thrown) at one stage of the chain becomes the input to the next stage of the chain, so it is critical to get this right. In practice, forgetting to return a value from a callback function is actually a common source of Promise-related bugs, and this is exacerbated by JavaScript’s arrow function shortcut syntax. Consider this line of code that we saw earlier:</p>
<blockquote>
<p>在 Promise 链中，在链的一个阶段返回（或抛出）的值成为链的下一阶段的输入，因此正确实现这一点至关重要。实际上，回调函数忘记返回值是与 Promise 相关的常见错误，而 JavaScript 的箭头函数快捷语法会加剧这种情况。回想一下我们之前看到的以下代码行：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="title function_">wait</span>(<span class="number">500</span>).<span class="title function_">then</span>(queryDatabase))</span><br></pre></td></tr></table></figure>
<p>Recall from Chapter 8 that arrow functions allow a lot of shortcuts. Since there is exactly one argument (the error value), we can omit the parentheses. Since the body of the function is a single expression, we can omit the curly braces around the function body, and the value of the expression becomes the return value of the function. Because of these shortcuts, the preceding code is correct. But consider this innocuous-seeming change:</p>
<blockquote>
<p>回顾第 8 章，箭头函数提供了许多快捷方式。由于仅存在一个参数（异常值），因此我们可以省略括号。由于函数的主体是单个表达式，因此我们可以省略函数主体周围的花括号，并且表达式的值成为函数的返回值。由于这些快捷方式，前面的代码是正确的。但是考虑一下这种无害的变化：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123; <span class="title function_">wait</span>(<span class="number">500</span>).<span class="title function_">then</span>(queryDatabase) &#125;)</span><br></pre></td></tr></table></figure>
<p>By adding the curly braces, we no longer get the automatic return. This function now returns undefined instead of returning a Promise, which means that the next stage in this Promise chain will be invoked with undefined as its input rather than the result of the retried query. It is a subtle error that may not be easy to debug.</p>
<blockquote>
<p>通过添加花括号，我们不再获得自动返回。现在，此函数返回 undefined 而不是返回 Promise，这意味着将以 undefined 作为输入而不是重试查询的结果来调用此 Promise 链中的下一个阶段。这是一个细微的错误，可能不容易调试。</p>
</blockquote>
<h3 id="13-2-5-Promises-in-Parallel"><a href="#13-2-5-Promises-in-Parallel" class="headerlink" title="13.2.5 Promises in Parallel"></a>13.2.5 Promises in Parallel</h3><p>We’ve spent a lot of time talking about Promise chains for sequentially running the asynchronous steps of a larger asynchronous operation. Sometimes, though, we want to execute a number of asynchronous operations in parallel. The function Promise.all() can do this. Promise.all() takes an array of Promise objects as its input and returns a Promise. The returned Promise will be rejected if any of the input Promises are rejected. Otherwise, it will be fulfilled with an array of the fulfillment values of each of the input Promises. So, for example, if you want to fetch the text content of multiple URLs, you could use code like this:</p>
<blockquote>
<p>我们花了很多时间讨论 Promise 链，这些链可按顺序运行较大的异步的操作步骤。但是，有时我们想并行执行许多异步操作。函数 Promise.all() 可以做到这一点。Promise.all() 将 Promise 对象数组作为其输入，并返回 Promise。如果任何输入的 Promise 中有一个是已拒绝状态，则返回的 Promise 将被拒绝。否则，它将使用每个输入 Promise 的兑现值组成的数组来被兑现。因此，例如，如果要获取多个 URL 的文本内容，则可以使用如下代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We start with an array of URLs</span></span><br><span class="line"><span class="keyword">const</span> urls = [ <span class="comment">/* zero or more URLs here */</span> ];</span><br><span class="line"><span class="comment">// And convert it to an array of Promise objects</span></span><br><span class="line">promises = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">text</span>()));</span><br><span class="line"><span class="comment">// Now get a Promise to run all those Promises in parallel</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/* do something with the array of strings */</span> &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(e));</span><br></pre></td></tr></table></figure>
<p>Promise.all() is slightly more flexible than described before. The input array can contain both Promise objects and non-Promise values. If an element of the array is not a Promise, it is treated as if it is the value of an already fulfilled Promise and is simply copied unchanged into the output array.</p>
<blockquote>
<p>Promise.all() 比前面描述的要灵活一些。输入数组可以包含 Promise 对象和非 Promise 值。如果数组的元素不是 Promise，则将其视为已兑现的 Promise 的值，并原封不动地复制到输出数组中。</p>
</blockquote>
<p>The Promise returned by Promise.all() rejects when any of the input Promises is rejected. This happens immediately upon the first rejection and can happen while other input Promises are still pending. In ES2020, Promise.allSettled() takes an array of input Promises and returns a Promise, just like Promise.all() does. But Promise.allSettled() never rejects the returned Promise, and it does not fulfill that Promise until all of the input Promises have settled. The Promise resolves to an array of objects, with one object for each input Promise. Each of these returned objects has a status property set to “fulfilled” or “rejected.” If the status is “fulfilled”, then the object will also have a value property that gives the fulfillment value. And if the status is “rejected”, then the object will also have a reason property that gives the error or rejection value of the corresponding Promise:</p>
<blockquote>
<p>当任何输入的 Promise 被拒绝时，Promise.all() 返回的 Promise 也会被拒绝。这在第一次拒绝时立即发生，可能其他输入 Promise 仍是待定状态。在 ES2020 中，Promise.allSettled() 接受输入的 Promise 数组，并返回 Promise，就像 Promise.all() 一样。但是 Promise.allSettled() 永远不会拒绝返回的 Promise，并且不会兑现这个 Promise，直到所有输入 Promise 全部已敲定。Promise 解析为一组对象，每个输入 Promise 都有一个对象。每个返回的对象中有一个状态属性设置为“已兑现”或“已拒绝”。如果状态为“已兑现”，则对象还将具有一个 value 属性，该属性提供兑现值。并且，如果状态为“已拒绝”，则对象还将具有一个 reason 属性，该属性给出相应的 Promise 的异常或拒绝值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">allSettled</span>([<span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>), <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="number">2</span>), <span class="number">3</span>]).<span class="title function_">then</span>(<span class="function"><span class="params">results</span> =&gt;</span> &#123;</span><br><span class="line">    results[<span class="number">0</span>]  <span class="comment">// =&gt; &#123; status: &quot;fulfilled&quot;, value: 1 &#125;</span></span><br><span class="line">    results[<span class="number">1</span>]  <span class="comment">// =&gt; &#123; status: &quot;rejected&quot;, reason: 2 &#125;</span></span><br><span class="line">    results[<span class="number">2</span>]  <span class="comment">// =&gt; &#123; status: &quot;fulfilled&quot;, value: 3 &#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Occasionally, you may want to run a number of Promises at once but may only care about the value of the first one to fulfill. In that case, you can use Promise.race() instead of Promise.all(). It returns a Promise that is fulfilled or rejected when the first of the Promises in the input array is fulfilled or rejected. (Or, if there are any non-Promise values in the input array, it simply returns the first of those.)</p>
<blockquote>
<p>有时，可能想一次运行多个 Promise，但可能只关心第一个要兑现的值。在这种情况下，可以使用 Promise.race() 代替 Promise.all()。当输入数组中的第一个 Promise 是已兑现或已拒绝状态时，它返回一个已兑现或已拒绝的 Promise。（或者，如果输入数组中有任何非 Promise 值，则只返回其中的第一个。）</p>
</blockquote>
<h3 id="13-2-6-Making-Promises"><a href="#13-2-6-Making-Promises" class="headerlink" title="13.2.6 Making Promises"></a>13.2.6 Making Promises</h3><p>We’ve used the Promise-returning function fetch() in many of the previous examples because it is one of the simplest functions built in to web browsers that returns a Promise. Our discussion of Promises has also relied on hypothetical Promise-returning functions getJSON() and wait(). Functions written to return Promises really are quite useful, and this section shows how you can create your own Promise-based APIs. In particular, we’ll show implementations of getJSON() and wait().</p>
<blockquote>
<p>在之前的许多示例中，我们都使用了 Promise 返回函数 fetch()，因为它是内置于 Web 浏览器中的最简单的返回 Promise 的函数之一。我们对 Promise 的讨论还依赖于假设的 Promise 返回函数 getJSON() 和 wait()。编写用于返回 Promise 的函数确实非常有用，本节说明如何创建自己的基于 Promise 的 API。特别是，我们将展示 getJSON() 和 wait() 的实现。</p>
</blockquote>
<h4 id="PROMISES-BASED-ON-OTHER-PROMISES"><a href="#PROMISES-BASED-ON-OTHER-PROMISES" class="headerlink" title="PROMISES BASED ON OTHER PROMISES"></a>PROMISES BASED ON OTHER PROMISES</h4><p>It is easy to write a function that returns a Promise if you have some other Promise-returning function to start with. Given a Promise, you can always create (and return) a new one by calling .then(). So if we use the existing fetch() function as a starting point, we can write getJSON() like this:</p>
<blockquote>
<p>如果以 Promise 返回函数作为开头来写一个返回 Promise 的函数是很容易的。有了 Promise，总是可以通过调用 .then() 创建（并返回）一个新的 Promise。因此，如果我们使用现有的 fetch() 函数作为起点，则可以这样编写 getJSON()：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The code is trivial because the Response object of the fetch() API has a predefined json() method. The json() method returns a Promise, which we return from our callback (the callback is an arrow function with a single-expression body, so the return is implicit), so the Promise returned by getJSON() resolves to the Promise returned by response.json(). When that Promise fulfills, the Promise returned by getJSON() fulfills to the same value. Note that there is no error handling in this getJSON() implementation. Instead of checking response.ok and the Content-Type header, we instead just allow the json() method to reject the Promise it returned with a SyntaxError if the response body cannot be parsed as JSON.</p>
<blockquote>
<p>该代码很简单，因为 fetch() API 的 Response 对象具有预定义的 json() 方法。我们从回调（该回调是带有单个表达式主体的箭头函数，因此返回值是隐式的）中通过 json() 方法返回一个 Promise，因此 getJSON() 返回的 Promise 解析为 response.json()。当该 Promise 兑现时，由 getJSON() 返回的 Promise 将兑现为相同的值。请注意，此 getJSON() 实现中没有异常处理。如果不能将 response 主体解析为 JSON，则无需检查 response.ok 和 Content-Type 标头，而只需允许 json() 方法拒绝它的 Promise 并返回 SyntaxError。</p>
</blockquote>
<p>Let’s write another Promise-returning function, this time using getJSON() as the source of the initial Promise:</p>
<blockquote>
<p>让我们编写另一个 Promise 返回函数，这次使用 getJSON() 作为初始 Promise 的来源：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHighScore</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">getJSON</span>(<span class="string">&quot;/api/user/profile&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">profile</span> =&gt;</span> profile.<span class="property">highScore</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’re assuming that this function is part of some sort of web-based game and that the URL “&#x2F;api&#x2F;user&#x2F;profile” returns a JSON-formatted data structure that includes a highScore property.</p>
<blockquote>
<p>我们假设此函数是某种基于网络的游戏的一部分，并且 URL“&#x2F;api&#x2F;user&#x2F;profile”返回的是包含 highScore 属性的 JSON 格式的数据结构。</p>
</blockquote>
<h4 id="PROMISES-BASED-ON-SYNCHRONOUS-VALUES"><a href="#PROMISES-BASED-ON-SYNCHRONOUS-VALUES" class="headerlink" title="PROMISES BASED ON SYNCHRONOUS VALUES"></a>PROMISES BASED ON SYNCHRONOUS VALUES</h4><p>Sometimes, you may need to implement an existing Promise-based API and return a Promise from a function, even though the computation to be performed does not actually require any asynchronous operations. In that case, the static methods Promise.resolve() and Promise.reject() will do what you want. Promise.resolve() takes a value as its single argument and returns a Promise that will immediately (but asynchronously) be fulfilled to that value. Similarly, Promise.reject() takes a single argument and returns a Promise that will be rejected with that value as the reason. (To be clear: the Promises returned by these static methods are not already fulfilled or rejected when they are returned, but they will fulfill or reject immediately after the current synchronous chunk of code has finished running. Typically, this happens within a few milliseconds unless there are many pending asynchronous tasks waiting to run.)</p>
<blockquote>
<p>有时，即使要执行的计算实际上不需要任何异步操作，也可能需要实现现有的基于 Promise 的 API 并从函数返回 Promise。在这种情况下，静态方法 Promise.resolve() 和 Promise.reject() 会做您想要的。Promise.resolve() 采用一个单个实参值，并返回一个 Promise，该 Promise 将立即（但异步地）兑现为该值。同样，Promise.reject() 接受一个实参值，并返回一个 Promise，该值将作为被拒绝的原因。（请注意：这些静态方法返回的 Promise 在返回时尚未兑现或拒绝，但是它们将在当前同步代码块运行完毕后立即兑现或拒绝。通常，这种情况会在几毫秒内发生，除非有许多等待执行的待处理异步任务。）</p>
</blockquote>
<p>Recall from §13.2.3 that a resolved Promise is not the same thing as a fulfilled Promise. When we call Promise.resolve(), we typically pass the fulfillment value to create a Promise object that will very soon fulfill to that value. The method is not named Promise.fulfill(), however. If you pass a Promise p1 to Promise.resolve(), it will return a new Promise p2, which is immediately resolved, but which will not be fulfilled or rejected until p1 is fulfilled or rejected.</p>
<blockquote>
<p>回顾 §13.2.3，已决议的 Promise 与已兑现的 Promise 不同。当我们调用 Promise.resolve() 时，通常会传递兑现值以创建一个 Promise 对象，该对象将很快兑现该值。但是，该方法未命名为 Promise.fulfill()。如果将 Promise p1 传递给 Promise.resolve()，它将返回一个新的 Promise p2，该 p2 立即被决议，但是直到 p1 被兑现或拒绝，该 Promise p2 才会被兑现或拒绝。 </p>
</blockquote>
<p>It is possible, but unusual, to write a Promise-based function where the value is computed synchronously and returned asynchronously with Promise.resolve(). It is fairly common, however, to have synchronous special cases within an asynchronous function, and you can handle these special cases with Promise.resolve() and Promise.reject(). In particular, if you detect error conditions (such as bad argument values) before beginning an asynchronous operation, you can report that error by returning a Promise created with Promise.reject(). (You could also just throw an error synchronously in that case, but that is considered poor form because then the caller of your function needs to write both a synchronous catch clause and use an asynchronous .catch() method to handle errors.) Finally, Promise.resolve() is sometimes useful to create the initial Promise in a chain of Promises. We’ll see a couple of examples that use it this way.</p>
<blockquote>
<p>可以（但不常见）编写一个基于 Promise 的函数，同步计算的值通过通过 Promise.resolve() 异步返回。但是，在异步函数中包含同步特殊情况是很常见的，可以使用 Promise.resolve() 和 Promise.reject() 处理这些特殊情况。特别是，如果在开始异步操作之前检测到异常条件（例如异常的实参值），则可以通过返回使用 Promise.reject() 创建的 Promise 来报告该异常。（在这种情况下，也可以同步引发异常，但这被认为是较差的形式，因为函数的调用者需要同时编写同步 catch 子句并使用异步 .catch() 方法来处理异常。）最后，Promise.resolve() 有时可用于在 Promise 链中创建初始 Promise。我们将看到几个使用这种方式的示例。 </p>
</blockquote>
<h4 id="PROMISES-FROM-SCRATCH"><a href="#PROMISES-FROM-SCRATCH" class="headerlink" title="PROMISES FROM SCRATCH"></a>PROMISES FROM SCRATCH</h4><p>For both getJSON() and getHighScore(), we started off by calling an existing function to get an initial Promise, and created and returned a new Promise by calling the .then() method of that initial Promise. But what about writing a Promise-returning function when you can’t use another Promise-returning function as the starting point? In that case, you use the Promise() constructor to create a new Promise object that you have complete control over. Here’s how it works: you invoke the Promise() constructor and pass a function as its only argument. The function you pass should be written to expect two parameters, which, by convention, should be named resolve and reject. The constructor synchronously calls your function with function arguments for the resolve and reject parameters. After calling your function, the Promise() constructor returns the newly created Promise. That returned Promise is under the control of the function you passed to the constructor. That function should perform some asynchronous operation and then call the resolve function to resolve or fulfill the returned Promise or call the reject function to reject the returned Promise. Your function does not have to be asynchronous: it can call resolve or reject synchronously, but the Promise will still be resolved, fulfilled, or rejected asynchronously if you do this.</p>
<blockquote>
<p>对于 getJSON() 和 getHighScore()，我们首先调用现有函数以获取初始 Promise，然后通过调用该初始 Promise 的 .then() 方法创建并返回新的 Promise。但是，当不能使用另一个返回 Promise 函数作为起点时，如何编写返回 Promise 函数呢？在这种情况下，可以使用 Promise() 构造函数创建一个可以完全控制的新 Promise 对象。它是这样工作的：调用 Promise() 构造函数并将一个函数作为唯一实参传递。传递的函数应编写为包含两个参数，按照惯例，应将其命名为 resolve 和 reject。构造函数会同步调用使用 resolve 和 reject 参数的函数。调用函数后，Promise() 构造函数将返回新创建的 Promise。返回的 Promise 受传递给构造函数的函数的控制。该函数应该执行一些异步操作，然后调用 resolve 函数来决议或兑现返回的 Promise，或者调用 reject 函数来拒绝返回的 Promise。函数不必是异步的：它可以同步地调用 resolve 或拒绝，但是如果这样做，Promise 仍将被异步地决议，兑现或拒绝。</p>
</blockquote>
<p>It can be hard to understand the functions passed to a function passed to a constructor by just reading about it, but hopefully some examples will make this clear. Here’s how to write the Promise-based wait() function that we used in various examples earlier in the chapter:</p>
<blockquote>
<p>仅仅阅读一下很难理解传递给构造函数的函数，但是希望有一些例子可以使这一点变得清楚。这是在本章前面的各种示例中使用的基于 Promise 的 wait() 函数的编写方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params">duration</span>) &#123;</span><br><span class="line">    <span class="comment">// Create and return a new Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; <span class="comment">// These control the Promise</span></span><br><span class="line">        <span class="comment">// If the argument is invalid, reject the Promise</span></span><br><span class="line">        <span class="keyword">if</span> (duration &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Time travel not yet implemented&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Otherwise, wait asynchronously and then resolve the Promise.</span></span><br><span class="line">        <span class="comment">// setTimeout will invoke resolve() with no arguments, which means</span></span><br><span class="line">        <span class="comment">// that the Promise will fulfill with the undefined value.</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that the pair of functions that you use to control the fate of a Promise created with the Promise() constructor are named resolve() and reject(), not fulfill() and reject(). If you pass a Promise to resolve(), the returned Promise will resolve to that new Promise. Often, however, you will pass a non-Promise value, which fulfills the returned Promise with that value.</p>
<blockquote>
<p>请注意，用于控制由 Promise() 构造函数创建的 Promise 命运的一对函数分别命名为 resolve() 和 reject()，而不是 fulfill() 和 reject()。如果传递一个 Promise 给 resolve()，则返回的 Promise 将决议于该新的 Promise。但是，通常会传递一个非 Promise 值，返回的 Promise 会兑现这个值。</p>
</blockquote>
<p>Example 13-1 is another example of using the Promise() constructor. This one implements our getJSON() function for use in Node, where the fetch() API is not built in. Remember that we started this chapter with a discussion of asynchronous callbacks and events. This example uses both callbacks and event handlers and is a good demonstration, therefore, of how we can implement Promise-based APIs on top of other styles of asynchronous programming.</p>
<blockquote>
<p>示例 13-1 是使用 Promise() 构造函数的另一个示例。这一节实现了 Node 中在未内置 fetch() API 使用的 getJSON() 函数。请记住，本章开始时讨论了异步回调和事件。此示例同时使用了回调和事件处理程序，因此很好地演示了如何在其他风格的异步编程之上实现基于 Promise 的 API。</p>
</blockquote>
<p>Example 13-1. An asynchronous getJSON() function</p>
<blockquote>
<p>示例 13-1 异步 getJSON() 函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="comment">// Create and return a new Promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// Start an HTTP GET request for the specified URL</span></span><br><span class="line">        request = http.<span class="title function_">get</span>(url, <span class="function"><span class="params">response</span> =&gt;</span> &#123; <span class="comment">// called when response starts</span></span><br><span class="line">            <span class="comment">// Reject the Promise if the HTTP status is wrong</span></span><br><span class="line">            <span class="keyword">if</span> (response.<span class="property">statusCode</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`HTTP status <span class="subst">$&#123;response.statusCode&#125;</span>`</span>));</span><br><span class="line">                response.<span class="title function_">resume</span>();  <span class="comment">// so we don&#x27;t leak memory</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// And reject if the response headers are wrong</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (response.<span class="property">headers</span>[<span class="string">&quot;content-type&quot;</span>] !== <span class="string">&quot;application/json&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Invalid content-type&quot;</span>));</span><br><span class="line">                response.<span class="title function_">resume</span>();  <span class="comment">// don&#x27;t leak memory</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Otherwise, register events to read the body of the response</span></span><br><span class="line">                <span class="keyword">let</span> body = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                response.<span class="title function_">setEncoding</span>(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">                response.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123; body += chunk; &#125;);</span><br><span class="line">                response.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    <span class="comment">// When the response body is complete, try to parse it</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> parsed = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(body);</span><br><span class="line">                        <span class="comment">// If it parsed successfully, fulfill the Promise</span></span><br><span class="line">                        <span class="title function_">resolve</span>(parsed);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                        <span class="comment">// If parsing failed, reject the Promise</span></span><br><span class="line">                        <span class="title function_">reject</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// We also reject the Promise if the request fails before we</span></span><br><span class="line">        <span class="comment">// even get a response (such as when the network is down)</span></span><br><span class="line">        request.<span class="title function_">on</span>(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-2-7-Promises-in-Sequence"><a href="#13-2-7-Promises-in-Sequence" class="headerlink" title="13.2.7 Promises in Sequence"></a>13.2.7 Promises in Sequence</h3><p>Promise.all() makes it easy to run an arbitrary number of Promises in parallel. And Promise chains make it easy to express a sequence of a fixed number of Promises. Running an arbitrary number of Promises in sequence is trickier, however. Suppose, for example, that you have an array of URLs to fetch, but that to avoid overloading your network, you want to fetch them one at a time. If the array is of arbitrary length and unknown content, you can’t write out a Promise chain in advance, so you need to build one dynamically, with code like this:</p>
<blockquote>
<p>Promise.all() 使得并行运行任意数量的 Promise 变得容易。Promise 链使表达固定数量的 Promise 序列变得容易。但是，依次执行任意数量的 Promise 会比较棘手。例如，假设您要获取一组 URL，但是为了避免网络过载，希望一次获取一个 URL。如果数组的长度是任意的且内容未知，则无法提前写出 Promise 链，因此需要使用以下代码动态构建一个：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchSequentially</span>(<span class="params">urls</span>) &#123;</span><br><span class="line">    <span class="comment">// We&#x27;ll store the URL bodies here as we fetch them</span></span><br><span class="line">    <span class="keyword">const</span> bodies = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here&#x27;s a Promise-returning function that fetches one body</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fetchOne</span>(<span class="params">url</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">text</span>())</span><br><span class="line">            .<span class="title function_">then</span>(<span class="function"><span class="params">body</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// We save the body to the array, and we&#x27;re purposely</span></span><br><span class="line">                <span class="comment">// omitting a return value here (returning undefined)</span></span><br><span class="line">                bodies.<span class="title function_">push</span>(body);</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with a Promise that will fulfill right away (with value undefined)</span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now loop through the desired URLs, building a Promise chain</span></span><br><span class="line">    <span class="comment">// of arbitrary length, fetching one URL at each stage of the chain</span></span><br><span class="line">    <span class="keyword">for</span>(url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">        p = p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">fetchOne</span>(url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When the last Promise in that chain is fulfilled, then the</span></span><br><span class="line">    <span class="comment">// bodies array is ready. So let&#x27;s return a Promise for that</span></span><br><span class="line">    <span class="comment">// bodies array. Note that we don&#x27;t include any error handlers:</span></span><br><span class="line">    <span class="comment">// we want to allow errors to propagate to the caller.</span></span><br><span class="line">    <span class="keyword">return</span> p.<span class="title function_">then</span>(<span class="function">() =&gt;</span> bodies);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With this fetchSequentially() function defined, we could fetch the URLs one at a time with code much like the fetch-in-parallel code we used earlier to demonstrate Promise.all():</p>
<blockquote>
<p>定义了这个 fetchSequentially() 函数之后，我们可以用一个代码一次来获取多个 URL，就像我们之前用来演示 Promise.all() 的并行获取代码一样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetchSequentially</span>(urls)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/* do something with the array of strings */</span> &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(e));</span><br></pre></td></tr></table></figure>
<p>The fetchSequentially() function starts by creating a Promise that will fulfill immediately after it returns. It then builds a long, linear Promise chain off of that initial Promise and returns the last Promise in the chain. It is like setting up a row of dominoes and then knocking the first one over.</p>
<blockquote>
<p>fetchSequentially() 函数首先创建一个 Promise，该 Promise 将在返回后立即兑现。然后，它从该初始 Promise 构建一个长的线性 Promise 链，并返回链中的最后一个 Promise。这就像设置一排多米诺骨牌，然后将第一个多米诺骨牌撞倒一样。</p>
</blockquote>
<p>There is another (possibly more elegant) approach that we can take. Rather than creating the Promises in advance, we can have the callback for each Promise create and return the next Promise. That is, instead of creating and chaining a bunch of Promises, we instead create Promises that resolve to other Promises. Rather than creating a domino-like chain of Promises, we are instead creating a sequence of Promises nested one inside the other like a set of matryoshka dolls. With this approach, our code can return the first (outermost) Promise, knowing that it will eventually fulfill (or reject!) to the same value that the last (innermost) Promise in the sequence does. The promiseSequence() function that follows is written to be generic and is not specific to URL fetching. It is here at the end of our discussion of Promises because it is complicated. If you’ve read this chapter carefully, however, I hope you’ll be able to understand how it works. In particular, note that the nested function inside promiseSequence() appears to call itself recursively, but because the “recursive” call is through a then() method, there is not actually any traditional recursion happening:</p>
<blockquote>
<p>我们可以采用另一种方法（可能更优雅）。除了提前创建 Promise 外，我们还可以为每个 Promise 创建回调，并返回下一个 Promise。也就是说，我们没有创建和链接一堆 Promise，而是创建了决议于其他承诺的承诺。与其创建类似多米诺骨牌的 Promise 链，不如创建一系列彼此嵌套在一起的 Promise 序列，就像俄罗斯套娃一样。使用这种方法，我们的代码可以知道第一个（最外面的）Promise 最终将兑现（或拒绝！），使其返回序列中最后一个（最里面的）Promise 相同的值。后面是通用的 promiseSequence() 函数，并不特定于 URL 提取。因为它很复杂，所以将它放在我们对 Promise 的讨论的结尾。但是，如果仔细阅读了本章，希望能理解它的工作原理。特别要注意的是，promiseSequence() 中的嵌套函数类似递归地调用自身，但是由于“递归”调用是通过 then() 方法进行的，因此实际上没有发生任何传统的递归：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function takes an array of input values and a &quot;promiseMaker&quot; function.</span></span><br><span class="line"><span class="comment">// For any input value x in the array, promiseMaker(x) should return a Promise</span></span><br><span class="line"><span class="comment">// that will fulfill to an output value. This function returns a Promise</span></span><br><span class="line"><span class="comment">// that fulfills to an array of the computed output values.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Rather than creating the Promises all at once and letting them run in</span></span><br><span class="line"><span class="comment">// parallel, however, promiseSequence() only runs one Promise at a time</span></span><br><span class="line"><span class="comment">// and does not call promiseMaker() for a value until the previous Promise</span></span><br><span class="line"><span class="comment">// has fulfilled.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">promiseSequence</span>(<span class="params">inputs, promiseMaker</span>) &#123;</span><br><span class="line">    <span class="comment">// Make a private copy of the array that we can modify</span></span><br><span class="line">    inputs = [...inputs];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here&#x27;s the function that we&#x27;ll use as a Promise callback</span></span><br><span class="line">    <span class="comment">// This is the pseudorecursive magic that makes this all work.</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">handleNextInput</span>(<span class="params">outputs</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputs.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If there are no more inputs left, then return the array</span></span><br><span class="line">            <span class="comment">// of outputs, finally fulfilling this Promise and all the</span></span><br><span class="line">            <span class="comment">// previous resolved-but-not-fulfilled Promises.</span></span><br><span class="line">            <span class="keyword">return</span> outputs;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If there are still input values to process, then we&#x27;ll</span></span><br><span class="line">            <span class="comment">// return a Promise object, resolving the current Promise</span></span><br><span class="line">            <span class="comment">// with the future value from a new Promise.</span></span><br><span class="line">            <span class="keyword">let</span> nextInput = inputs.<span class="title function_">shift</span>(); <span class="comment">// Get the next input value,</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">promiseMaker</span>(nextInput)  <span class="comment">// compute the next output value,</span></span><br><span class="line">                <span class="comment">// Then create a new outputs array with the new output value</span></span><br><span class="line">                .<span class="title function_">then</span>(<span class="function"><span class="params">output</span> =&gt;</span> outputs.<span class="title function_">concat</span>(output))</span><br><span class="line">                <span class="comment">// Then &quot;recurse&quot;, passing the new, longer, outputs array</span></span><br><span class="line">                .<span class="title function_">then</span>(handleNextInput);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start with a Promise that fulfills to an empty array and use</span></span><br><span class="line">    <span class="comment">// the function above as its callback.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([]).<span class="title function_">then</span>(handleNextInput);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This promiseSequence() function is intentionally generic. We can use it to fetch URLs with code like this:</p>
<blockquote>
<p>promiseSequence() 函数是通用的。我们可以使用它通过以下代码来获取 URL：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a URL, return a Promise that fulfills to the URL body text</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchBody</span>(<span class="params">url</span>) &#123; <span class="keyword">return</span> <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">r</span> =&gt;</span> r.<span class="title function_">text</span>()); &#125;</span><br><span class="line"><span class="comment">// Use it to sequentially fetch a bunch of URL bodies</span></span><br><span class="line"><span class="title function_">promiseSequence</span>(urls, fetchBody)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">bodies</span> =&gt;</span> &#123; <span class="comment">/* do something with the array of strings */</span> &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>
<h2 id="13-3-async-and-await"><a href="#13-3-async-and-await" class="headerlink" title="13.3 async and await"></a>13.3 async and await</h2><p>ES2017 introduces two new keywords—async and await—that represent a paradigm shift in asynchronous JavaScript programming. These new keywords dramatically simplify the use of Promises and allow us to write Promise-based, asynchronous code that looks like synchronous code that blocks while waiting for network responses or other asynchronous events. Although it is still important to understand how Promises work, much of their complexity (and sometimes even their very presence!) vanishes when you use them with async and await.</p>
<blockquote>
<p>ES2017 引入了两个新的关键字（async 和 await）描述异步 JavaScript 编程中的模式转变。这些新关键字极大地简化了 Promises 的使用，使我们能够编写基于 Promise 的异步代码看起来像是等待网络响应或其他异步事件而阻塞的同步代码。尽管了解 Promises 的工作原理仍然很重要，但是当将它们与 async 和 await 一起使用时，它们的大部分复杂性（有时甚至是它们的存在！）就消失了。 </p>
</blockquote>
<p>As we discussed earlier in the chapter, asynchronous code can’t return a value or throw an exception the way that regular synchronous code can. And this is why Promises are designed the way the are. The value of a fulfilled Promise is like the return value of a synchronous function. And the value of a rejected Promise is like a value thrown by a synchronous function. This latter similarity is made explicit by the naming of the .catch() method. async and await take efficient, Promise-based code and hide the Promises so that your asynchronous code can be as easy to read and as easy to reason about as inefficient, blocking, synchronous code.</p>
<blockquote>
<p>如本章前面所述，异步代码无法像常规同步代码那样返回值或引发异常。这就是为什么 Promise 如此设计的原因。已兑现的 Promise 的值类似于同步函数的返回值。而且已拒绝的 Promise 的值就像同步函数抛出的值。后者通过类似的 .catch() 方法命名，使得表述更清晰。async 和 await 使用高效的、基于 Promise 的代码并隐藏 Promise，以便异步代码可以像低效、阻塞、同步代码一样容易阅读和推理。 </p>
</blockquote>
<h3 id="13-3-1-await-Expressions"><a href="#13-3-1-await-Expressions" class="headerlink" title="13.3.1 await Expressions"></a>13.3.1 await Expressions</h3><p>The await keyword takes a Promise and turns it back into a return value or a thrown exception. Given a Promise object p, the expression await p waits until p settles. If p fulfills, then the value of await p is the fulfillment value of p. On the other hand, if p is rejected, then the await p expression throws the rejection value of p. We don’t usually use await with a variable that holds a Promise; instead, we use it before the invocation of a function that returns a Promise:</p>
<blockquote>
<p>关键字 await 接受一个 Promise，并将其转换为返回值或引发的异常。给定一个 Promise 对象 p，表达式 await p 等待直到 p 敲定。如果 p 兑现，则等待 p 的值就是 p 的兑现值。另一方面，如果 p 被拒绝，则 await p 表达式将抛出 p 的拒绝值。我们通常不将 await 与保存 Promise 的变量一起使用；相反，我们在调用返回 Promise 的函数之前使用它：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> profile = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br></pre></td></tr></table></figure>
<p>It is critical to understand right away that the await keyword does not cause your program to block and literally do nothing until the specified Promise settles. The code remains asynchronous, and the await simply disguises this fact. This means that any code that uses await is itself asynchronous.</p>
<blockquote>
<p>立即了解至关重要的一点是，在指定的 Promise 敲定之前，await 关键字不会导致程序阻塞，并且实际上什么也不做。代码保持异步，并且 await 只是掩盖了这一事实。这意味着使用 await 的任何代码本身都是异步的。 </p>
</blockquote>
<h3 id="13-3-2-async-Functions"><a href="#13-3-2-async-Functions" class="headerlink" title="13.3.2 async Functions"></a>13.3.2 async Functions</h3><p>Because any code that uses await is asynchronous, there is one critical rule: you can only use the await keyword within functions that have been declared with the async keyword. Here’s a version of the getHighScore() function from earlier in the chapter, rewritten to use async and await:</p>
<blockquote>
<p>因为任何使用 await 的代码都是异步的，所以有一个关键规则：只能在使用 async 关键字声明的函数中使用 await 关键字。下面是本章前面的 getHighScore() 函数的一个版本，使用 async 和 await 重写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getHighScore</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&quot;/api/user/profile&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> profile = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> profile.<span class="property">highScore</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Declaring a function async means that the return value of the function will be a Promise even if no Promise-related code appears in the body of the function. If an async function appears to return normally, then the Promise object that is the real return value of the function will resolve to that apparent return value. And if an async function appears to throw an exception, then the Promise object that it returns will be rejected with that exception.</p>
<blockquote>
<p>异步声明函数意味着函数的返回值将是一个 Promise，即使函数体中没有出现与 Promise 相关的代码。如果异步函数看起来正常返回，那么作为函数实际返回值的 Promise 对象将决议为该返回值。如果一个异步函数出现抛出异常，那么它返回的 Promise 对象将被那个异常拒绝。</p>
</blockquote>
<p>The getHighScore() function is declared async, so it returns a Promise. And because it returns a Promise, we can use the await keyword with it:</p>
<blockquote>
<p>getHighScore() 函数被声明为异步，因此它返回一个承诺。因为它返回一个承诺，所以我们可以使用 await 关键字：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">displayHighScore</span>(<span class="keyword">await</span> <span class="title function_">getHighScore</span>());</span><br></pre></td></tr></table></figure>
<p>But remember, that line of code will only work if it is inside another async function! You can nest await expressions within async functions as deeply as you want. But if you’re at the top level [^2] or are inside a function that is not async for some reason, then you can’t use await and have to deal with a returned Promise in the regular way:</p>
<blockquote>
<p>但是请记住，只有在另一个异步函数中，该行代码才有效！可以根据需要在异步函数中嵌套任何层 await 表达式。但是，如果处于最高级别 [^2] 或由于某种原因而处于不异步的函数内，那么您无法使用 await 并且必须以常规方式处理返回的 Promise： </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getHighScore</span>().<span class="title function_">then</span>(displayHighScore).<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>);</span><br></pre></td></tr></table></figure>
<p>You can use the async keyword with any kind of function. It works with the function keyword as a statement or as an expression. It works with arrow functions and with the method shortcut form in classes and object literals. (See Chapter 8 for more about the various ways to write functions.)</p>
<blockquote>
<p>可以将 async 关键字与任何函数一起使用。它用作于 function 关键字作为语句或表达式。它可与箭头函数以及类和对象字面量中的速记方法方式一起使用。（有关如何编写函数的各种方法，请参见第 8 章。） </p>
</blockquote>
<h3 id="13-3-3-Awaiting-Multiple-Promises"><a href="#13-3-3-Awaiting-Multiple-Promises" class="headerlink" title="13.3.3 Awaiting Multiple Promises"></a>13.3.3 Awaiting Multiple Promises</h3><p>Suppose that we’ve written our getJSON() function using async:</p>
<blockquote>
<p>假设我们已经使用 async 编写了 getJSON() 函数： </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getJSON</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url);</span><br><span class="line">    <span class="keyword">let</span> body = <span class="keyword">await</span> response.<span class="title function_">json</span>();</span><br><span class="line">    <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>And now suppose that we want to fetch two JSON values with this function:</p>
<blockquote>
<p>并且现在假设我们要用这个方法获取两个 JSON 值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value1 = <span class="keyword">await</span> <span class="title function_">getJSON</span>(url1);</span><br><span class="line"><span class="keyword">let</span> value2 = <span class="keyword">await</span> <span class="title function_">getJSON</span>(url2);</span><br></pre></td></tr></table></figure>
<p>The problem with this code is that it is unnecessarily sequential: the fetch of the second URL will not begin until the first fetch is complete. If the second URL does not depend on the value obtained from the first URL, then we should probably try to fetch the two values at the same time. This is a case where the Promise-based nature of async functions shows. In order to await a set of concurrently executing async functions, we use Promise.all() just as we would if working with Promises directly:</p>
<blockquote>
<p>此代码的问题在于，它不必要地是连续的：第二个 URL 的获取要等到第一次获取完成后才能开始。如果第二个 URL 不依赖于从第一个 URL 获得的值，那么我们可能应该尝试同时获取两个值。这是基于 Promise 的异步函数本质的一种情况。为了等待一组并发执行的异步函数，我们使用 Promise.all() 就像直接使用 Promise 一样： </p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [value1, value2] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([<span class="title function_">getJSON</span>(url1), <span class="title function_">getJSON</span>(url2)]);</span><br></pre></td></tr></table></figure>
<h3 id="13-3-4-Implementation-Details"><a href="#13-3-4-Implementation-Details" class="headerlink" title="13.3.4 Implementation Details"></a>13.3.4 Implementation Details</h3><p>Finally, in order to understand how async functions work, it may help to think about what is going on under the hood.</p>
<blockquote>
<p>最后，为了了解异步功能是如何工作的，考虑一下幕后发生了什么可能会有所帮助。</p>
</blockquote>
<p>Suppose you write an async function like this:</p>
<blockquote>
<p>假设写这样的一个异步函数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123; <span class="comment">/* body */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>You can think about this as a Promise-returning function wrapped around the body of your original function:</p>
<blockquote>
<p>可以将其视为包装原始函数主体的 Promise 返回函数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>((<span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="comment">/* body */</span> &#125;)(x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is harder to express the await keyword in terms of a syntax transformation like this one. But think of the await keyword as a marker that breaks a function body up into separate, synchronous chunks. An ES2017 interpreter can break the function body up into a sequence of separate subfunctions, each of which gets passed to the then() method of the await-marked Promise that precedes it.</p>
<blockquote>
<p>用像这样的语法转换来表达 await 关键字比较困难。但是，将 await 关键字视为将函数主体分解为单独的同步块的标记。ES2017 解释器可以将函数主体分解为一系列单独的子函数，每个子函数都传递给位于其前面 await 标记的 Promise 的 then() 方法。</p>
</blockquote>
<h2 id="13-4-Asynchronous-Iteration"><a href="#13-4-Asynchronous-Iteration" class="headerlink" title="13.4 Asynchronous Iteration"></a>13.4 Asynchronous Iteration</h2><p>We began this chapter with a discussion of callback- and event-based asynchrony, and when we introduced Promises, we noted that they were useful for single-shot asynchronous computations but were not suitable for use with sources of repetitive asynchronous events, such as setInterval(), the “click” event in a web browser, or the “data” event on a Node stream. Because single Promises do not work for sequences of asynchronous events, we also cannot use regular async functions and the await statements for these things.</p>
<blockquote>
<p>在本章的开头我们讨论了基于回调和基于事件的异步，当我们介绍 Promise 时，我们注意到它们对于单次异步计算很有用，但不适用于重复性异步事件的代码，例如 setInterval()，网络浏览器中的“click”事件或 Node 流上的“data”事件。因为单个 Promise 不适用于异步事件序列，所以我们也不能对这些事物使用常规的异步函数和 await 语句。</p>
</blockquote>
<p>ES2018 provides a solution, however. Asynchronous iterators are like the iterators described in Chapter 12, but they are Promise-based and are meant to be used with a new form of the for&#x2F;of loop: for&#x2F;await.</p>
<blockquote>
<p>但是 ES2018 提供了一个解决方案。异步迭代器类似于第 12 章中描述的迭代器，但是它们基于 Promise，并且打算与 for&#x2F;of 循环一起使用的新形式：for&#x2F;await。</p>
</blockquote>
<h3 id="13-4-1-The-for-x2F-await-Loop"><a href="#13-4-1-The-for-x2F-await-Loop" class="headerlink" title="13.4.1 The for&#x2F;await Loop"></a>13.4.1 The for&#x2F;await Loop</h3><p>Node 12 makes its readable streams asynchronously iterable. This means you can read successive chunks of data from a stream with a for&#x2F;await loop like this one:</p>
<blockquote>
<p>Node 12 使其可读流可以异步迭代。这意味着可以使用如下所示的 for&#x2F;await 循环从流中读取连续的数据块：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">parseFile</span>(<span class="params">filename</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stream = fs.<span class="title function_">createReadStream</span>(filename, &#123; <span class="attr">encoding</span>: <span class="string">&quot;utf-8&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> chunk <span class="keyword">of</span> stream) &#123;</span><br><span class="line">        <span class="title function_">parseChunk</span>(chunk); <span class="comment">// Assume parseChunk() is defined elsewhere</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Like a regular await expression, the for&#x2F;await loop is Promise-based. Roughly speaking, the asynchronous iterator produces a Promise and the for&#x2F;await loop waits for that Promise to fulfill, assigns the fulfillment value to the loop variable, and runs the body of the loop. And then it starts over, getting another Promise from the iterator and waiting for that new Promise to fulfill.</p>
<blockquote>
<p>像普通的 await 表达式一样，for&#x2F;await 循环是基于 promise 的。粗略地说，异步迭代器产生一个 Promise，for&#x2F;await 循环等待该 Promise 兑现，将兑现值分配给循环变量，然后运行循环的主体。然后重新开始，从迭代器中获得另一个 Promise，然后等待该新 Promise 兑现。</p>
</blockquote>
<p>Suppose you have an array of URLs:</p>
<blockquote>
<p>假设有一个 URL 数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> urls = [url1, url2, url3];</span><br></pre></td></tr></table></figure>
<p>You can call fetch() on each URL to get an array of Promises:</p>
<blockquote>
<p>可以在每个 URL 上调用 fetch() 以获取一个 promise 数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = urls.<span class="title function_">map</span>(<span class="function"><span class="params">url</span> =&gt;</span> <span class="title function_">fetch</span>(url));</span><br></pre></td></tr></table></figure>
<p>We saw earlier in the chapter that we could now use Promise.all() to wait for all the Promises in the array to be fulfilled. But suppose we want the results of the first fetch as soon as they become available and don’t want to wait for all the URLs to be fetched. (Of course, the first fetch might take longer than any of the others, so this is not necessarily faster than using Promise.all().) Arrays are iterable, so we can iterate through the array of promises with a regular for&#x2F;of loop:</p>
<blockquote>
<p>我们在本章的前面已经看到，我们现在可以使用 Promise.all() 等待数组中的所有 promise 都已兌現。但是，假设我们希望第一个提取的结果尽快可用，并且不想等待所有 URL 都被获取。（当然，第一次获取可能比其他任何获取都要花费更长的时间，因此不一定比使用 Promise.all() 更快。）数组是可迭代的，因此我们可以使用常规的 for&#x2F;of 对数组进行遍历：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    response = <span class="keyword">await</span> promise;</span><br><span class="line">    <span class="title function_">handle</span>(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This example code uses a regular for&#x2F;of loop with a regular iterator. But because this iterator returns Promises, we can also use the new for&#x2F;await for slightly simpler code:</p>
<blockquote>
<p>此示例代码使用 for&#x2F;of 循环遍历常规迭代器。但是因为此迭代器返回 Promise，所以我们还可以将新的 for&#x2F;await 稍微简化下代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> response <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="title function_">handle</span>(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In this case, the for&#x2F;await loop just builds the await call into the loop and makes our code slightly more compact, but the two examples do exactly the same thing. Importantly, both examples will only work if they are within functions declared async; a for&#x2F;await loop is no different than a regular await expression in that way.</p>
<blockquote>
<p>在这种情况下，for&#x2F;await 循环仅将 await 调用构建到循环中，并使我们的代码稍微紧凑一些，但是两个示例的作用完全相同。重要的是，这两个示例只有在声明为异步的函数中时才起作用。for&#x2F;await 循环与常规 await 表达式没有什么不同。</p>
</blockquote>
<p>It is important to realize, however, that we’re using for&#x2F;await with a regular iterator in this example. Things are more interesting with fully asynchronous iterators.</p>
<blockquote>
<p>但是，重要的是要意识到，在此示例中，我们正在使用 for&#x2F;wait 作用于常规迭代器的。作用于完全异步的迭代器使事情变得更加有趣。</p>
</blockquote>
<h3 id="13-4-2-Asynchronous-Iterators"><a href="#13-4-2-Asynchronous-Iterators" class="headerlink" title="13.4.2 Asynchronous Iterators"></a>13.4.2 Asynchronous Iterators</h3><p>Let’s review some terminology from Chapter 12. An iterable object is one that can be used with a for&#x2F;of loop. It defines a method with the symbolic name Symbol.iterator. This method returns an iterator object. The iterator object has a next() method, which can be called repeatedly to obtain the values of the iterable object. The next() method of the iterator object returns iteration result objects. The iteration result object has a value property and&#x2F;or a done property.</p>
<blockquote>
<p>让我们回顾一下第 12 章中的一些术语。可迭代对象是可以与 for&#x2F;of 循环一起使用的对象。它定义了一个名称为 Symbol.iterator 的方法。此方法返回一个迭代器对象。迭代器对象具有 next() 方法，可以重复调用该方法以获得可迭代对象的值。迭代器对象的 next() 方法返回迭代结果对象。迭代结果对象具有 value 属性和或或 done 属性。</p>
</blockquote>
<p>Asynchronous iterators are quite similar to regular iterators, but there are two important differences. First, an asynchronously iterable object implements a method with the symbolic name Symbol.asyncIterator instead of Symbol.iterator. (As we saw earlier, for&#x2F;await is compatible with regular iterable objects but it prefers asynchronously iterable objects, and tries the Symbol.asyncIterator method before it tries the Symbol.iterator method.) Second, the next() method of an asynchronous iterator returns a Promise that resolves to an iterator result object instead of returning an iterator result object directly.</p>
<blockquote>
<p>异步迭代器与常规迭代器非常相似，但是有两个重要的区别。 首先，一个异步可迭代对象以符号名称 Symbol.asyncIterator 而不是 Symbol.iterator 实现一个方法。（如前所述，for&#x2F;await 与常规可迭代对象兼容，但是它更喜欢异步可迭代对象，并在尝试 Symbol.iterator 方法之前先尝试使用 Symbol.asyncIterator 方法。）其次，异步迭代器的 next() 方法返回解析为迭代器结果对象的 Promise，而不是直接返回迭代器结果对象。</p>
</blockquote>
<p><strong>NOTE</strong><br>In the previous section, when we used for&#x2F;await on a regular, synchronously iterable array of Promises, we were working with synchronous iterator result objects in which the value property was a Promise object but the done property was synchronous. True asynchronous iterators return Promises for iteration result objects, and both the value and the done properties are asynchronous. The difference is a subtle one: with asynchronous iterators, the choice about when iteration ends can be made asynchronously.</p>
<blockquote>
<p>在上一节中，当我们在常规的、同步可迭代的 Promise 数组上使用 for&#x2F;await 时，我们正在使用同步迭代器结果对象，其中 value 属性是 Promise 对象，但 done 属性是同步的。真正的异步迭代器为迭代结果对象返回 Promise，并且 value 和 done 属性都是异步的。这是一个微妙的区别：使用异步迭代器，可以异步选择何时结束迭代。</p>
</blockquote>
<h3 id="13-4-3-Asynchronous-Generators"><a href="#13-4-3-Asynchronous-Generators" class="headerlink" title="13.4.3 Asynchronous Generators"></a>13.4.3 Asynchronous Generators</h3><p>As we saw in Chapter 12, the easiest way to implement an iterator is often to use a generator. The same is true for asynchronous iterators, which we can implement with generator functions that we declare async. An async generator has the features of async functions and the features of generators: you can use await as you would in a regular async function, and you can use yield as you would in a regular generator. But values that you yield are automatically wrapped in Promises. Even the syntax for async generators is a combination: async function and function * combine into async function *. Here is an example that shows how you might use an async generator and a for&#x2F;await loop to repetitively run code at fixed intervals using loop syntax instead of a setInterval() callback function:</p>
<blockquote>
<p>正如我们在第 12 章中看到的那样，实现迭代器的最简单方法通常是使用生成器。异步迭代器也是如此，我们可以使用声明为异步的生成器函数来实现。异步生成器具有异步特性和生成器特性：可以像在常规异步函数中一样使用 await，并且可以像在常规生成器中一样使用 yield。但是，产生的值会自动包装在 Promise 中。甚至异步生成器的语法也是一个组合：异步函数和 function* 组合为 async function*。这是一个示例，描述如何使用异步生成器和 for&#x2F;await 循环代替 setInterval() 回调函数以固定的间隔重复运行代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Promise-based wrapper around setTimeout() that we can use await with.</span></span><br><span class="line"><span class="comment">// Returns a Promise that fulfills in the specified number of milliseconds</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">elapsedTime</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An async generator function that increments a counter and yields it</span></span><br><span class="line"><span class="comment">// a specified (or infinite) number of times at a specified interval.</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span>* <span class="title function_">clock</span>(<span class="params">interval, max=<span class="literal">Infinity</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> count = <span class="number">1</span>; count &lt;= max; count++) &#123; <span class="comment">// regular for loop</span></span><br><span class="line">        <span class="keyword">await</span> <span class="title function_">elapsedTime</span>(interval);            <span class="comment">// wait for time to pass</span></span><br><span class="line">        <span class="keyword">yield</span> count;                            <span class="comment">// yield the counter</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A test function that uses the async generator with for/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;                       <span class="comment">// Async so we can use for/await</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> tick <span class="keyword">of</span> <span class="title function_">clock</span>(<span class="number">300</span>, <span class="number">100</span>)) &#123; <span class="comment">// Loop 100 times every 300ms</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(tick);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-4-4-Implementing-Asynchronous-Iterators"><a href="#13-4-4-Implementing-Asynchronous-Iterators" class="headerlink" title="13.4.4 Implementing Asynchronous Iterators"></a>13.4.4 Implementing Asynchronous Iterators</h3><p>Instead of using async generators to implement asynchronous iterators, it is also possible to implement them directly by defining an object with a Symbol.asyncIterator() method that returns an object with a next() method that returns a Promise that resolves to an iterator result object. In the following code, we re-implement the clock() function from the preceding example so that it is not a generator and instead just returns an asynchronously iterable object. Notice that the next() method in this example does not explicitly return a Promise; instead, we just declare next() to be async:</p>
<blockquote>
<p>除了使用异步生成器来实现异步迭代器外，还可以通过使用 Symbol.asyncIterator() 方法定义一个对象来直接实现它们，而 Symbol.asyncIterator() 方法将返回一个对象，而 next() 方法将返回一个决议为迭代器结果对象的 Promise。在下面的代码中，我们重新实现了上一个示例中的 clock() 函数，因此它不是生成器，而仅是返回一个异步可迭代的对象。请注意，此示例中的 next() 方法未明确返回 Promise；相反，我们只声明 next() 是异步的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clock</span>(<span class="params">interval, max=<span class="literal">Infinity</span></span>) &#123;</span><br><span class="line">    <span class="comment">// A Promise-ified version of setTimeout that we can use await with.</span></span><br><span class="line">    <span class="comment">// Note that this takes an absolute time instead of an interval.</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">until</span>(<span class="params">time</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time - <span class="title class_">Date</span>.<span class="title function_">now</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return an asynchronously iterable object</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">startTime</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>(),  <span class="comment">// Remember when we started</span></span><br><span class="line">        <span class="attr">count</span>: <span class="number">1</span>,               <span class="comment">// Remember which iteration we&#x27;re on</span></span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">next</span>(<span class="params"></span>) &#123;          <span class="comment">// The next() method makes this an iterator</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">count</span> &gt; max) &#123;     <span class="comment">// Are we done?</span></span><br><span class="line">                <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;  <span class="comment">// Iteration result indicating done</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Figure out when the next iteration should begin,</span></span><br><span class="line">            <span class="keyword">let</span> targetTime = <span class="variable language_">this</span>.<span class="property">startTime</span> + <span class="variable language_">this</span>.<span class="property">count</span> * interval;</span><br><span class="line">            <span class="comment">// wait until that time,</span></span><br><span class="line">            <span class="keyword">await</span> <span class="title function_">until</span>(targetTime);</span><br><span class="line">            <span class="comment">// and return the count value in an iteration result object.</span></span><br><span class="line">            <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">count</span>++ &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// This method means that this iterator object is also an iterable.</span></span><br><span class="line">        [<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This iterator-based version of the clock() function fixes a flaw in the generator-based version. Note that, in this newer code, we target the absolute time at which each iteration should begin and subtract the current time from that in order to compute the interval that we pass to setTimeout(). If we use clock() with a for&#x2F;await loop, this version will run loop iterations more precisely at the specified interval because it accounts for the time required to actually run the body of the loop. But this fix isn’t just about timing accuracy. The for&#x2F;await loop always waits for the Promise returned by one iteration to be fulfilled before it begins the next iteration. But if you use an asynchronous iterator without a for&#x2F;await loop, there is nothing to prevent you from calling the next() method whenever you want. With the generator-based version of clock(), if you call the next() method three times sequentially, you’ll get three Promises that will all fulfill at almost exactly the same time, which is probably not what you want. The iterator-based version we’ve implemented here does not have that problem.</p>
<blockquote>
<p>这个基于迭代器版本的 clock() 函数修复了基于生成器版本中的一个缺陷。请注意，在此代码中，我们在每次迭代开始时设置了绝对目标时间，并将其与当前时间的差值作为间隔传递给 setTimeout()。如果我们将 clock() 与 for&#x2F;await 循环一起使用，则此版本将在指定的时间间隔内更精确地运行循环迭代，因为它考虑了实际运行循环主体所需的时间。但是，此修补程序不仅涉及定时精度。for&#x2F;await 循环始终在开始下一次迭代之前等待一次迭代返回的 Promise 被兑现。但是，如果使用不带 for&#x2F;await 循环的异步迭代器，则没有什么可以阻止在需要时调用 next() 方法。使用基于生成器的 clock() 版本，如果依次调用 next() 方法三遍，将获得三个 Promise，这些 Promise 几乎都在同一时间完成，这可能不是想要的结果。我们在这里实现的基于迭代器的版本没有这个问题。</p>
</blockquote>
<p>The benefit of asynchronous iterators is that they allow us to represent streams of asynchronous events or data. The clock() function discussed previously was fairly simple to write because the source of the asynchrony was the setTimeout() calls we were making ourselves. But when we are trying to work with other asynchronous sources, such as the triggering of event handlers, it becomes substantially harder to implement asynchronous iterators—we typically have a single event handler function that responds to events, but each call to the iterator’s next() method must return a distinct Promise object, and multiple calls to next() may occur before the first Promise resolves. This means that any asynchronous iterator method must be able to maintain an internal queue of Promises that it resolves in order as asynchronous events are occurring. If we encapsulate this Promise-queueing behavior into an AsyncQueue class, then it becomes much easier to write asynchronous iterators based on AsyncQueue. [^3]</p>
<blockquote>
<p>异步迭代器的好处在于，它们允许我们表示异步事件或数据流。前面讨论的 clock() 函数编写起来非常简单，因为异步源是我们自己进行的 setTimeout() 调用。但是，当我们尝试与其他异步源一起使用时，例如事件处理程序的触发，实现异步迭代器的难度将大大提高————我们通常只有一个事件处理程序函数来响应事件，但是每次调用迭代器的 next() 方法一定返回一个不同的 Promise 对象，并且在第一个 Promise 决议之前，可能会多次调用 next()。这意味着，任何异步迭代器方法都必须能够维护一个内部的 Promise 队列，该队列将在响应异步事件时按顺序进行决议。如果我们将此 Promise 有序列的行为封装到 AsyncQueue 类中，那么基于 AsyncQueue 编写异步迭代器将变得更加容易。 [^3]</p>
</blockquote>
<p>The AsyncQueue class that follows has enqueue() and dequeue() methods as you’d expect for a queue class. The dequeue() method returns a Promise rather than an actual value, however, which means that it is OK to call dequeue() before enqueue() has ever been called. The AsyncQueue class is also an asynchronous iterator, and is intended to be used with a for&#x2F;await loop whose body runs once each time a new value is asynchronously enqueued. (AsyncQueue has a close() method. Once called, no more values can be enqueued. When a closed queue is empty, the for&#x2F;await loop will stop looping.)</p>
<blockquote>
<p>正如期望的那样，后面的 AsyncQueue 类具有 enqueue() 和 dequeue() 方法。但是，dequeue() 方法返回 Promise 而不是实际值，这意味着可以在调用 enqueue() 之前调用 dequeue()。AsyncQueue 类也是一个异步迭代器，旨在与 for&#x2F;await 循环一起使用，该循环的主体在每次将新值异步排队时都运行一次。（AsyncQueue 有一个 close() 方法。一旦被调用，就不能将更多的值加入队列。当关闭的队列为空时，for&#x2F;await 循环将停止遍历。）</p>
</blockquote>
<p>Note that the implementation of AsyncQueue does not use async or await and instead works directly with Promises. The code is somewhat complicated, and you can use it to test your understanding of the material we’ve covered in this long chapter. Even if you don’t fully understand the AsyncQueue implementation, do take a look at the shorter example that follows it: it implements a simple but very interesting asynchronous iterator on top of AsyncQueue.</p>
<blockquote>
<p>请注意，AsyncQueue 的实现不使用异步或等待，而是直接与 Promise 一起使用。该代码有些复杂，可以使用它来测试对本长篇文章所涉及内容的理解。即使您不完全了解 AsyncQueue 的实现，也请看一下它后面的简短示例：它在 AsyncQueue 之上实现了一个简单但非常有趣的异步迭代器。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An asynchronously iterable queue class. Add values with enqueue()</span></span><br><span class="line"><span class="comment"> * and remove them with dequeue(). dequeue() returns a Promise, which</span></span><br><span class="line"><span class="comment"> * means that values can be dequeued before they are enqueued. The</span></span><br><span class="line"><span class="comment"> * class implements [Symbol.asyncIterator] and next() so that it can</span></span><br><span class="line"><span class="comment"> * be used with the for/await loop (which will not terminate until</span></span><br><span class="line"><span class="comment"> * the close() method is called.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncQueue</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// Values that have been queued but not dequeued yet are stored here</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">values</span> = [];</span><br><span class="line">        <span class="comment">// When Promises are dequeued before their corresponding values are</span></span><br><span class="line">        <span class="comment">// queued, the resolve methods for those Promises are stored here.</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">resolvers</span> = [];</span><br><span class="line">        <span class="comment">// Once closed, no more values can be enqueued, and no more unfulfilled</span></span><br><span class="line">        <span class="comment">// Promises returned.</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">closed</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">enqueue</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">closed</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;AsyncQueue closed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If this value has already been promised, resolve that Promise</span></span><br><span class="line">            <span class="keyword">const</span> resolve = <span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise, queue it up</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">values</span>.<span class="title function_">push</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">values</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If there is a queued value, return a resolved Promise for it</span></span><br><span class="line">            <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">values</span>.<span class="title function_">shift</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">closed</span>) &#123;</span><br><span class="line">            <span class="comment">// If no queued values and we&#x27;re closed, return a resolved</span></span><br><span class="line">            <span class="comment">// Promise for the &quot;end-of-stream&quot; marker</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title class_">AsyncQueue</span>.<span class="property">EOS</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Otherwise, return an unresolved Promise,</span></span><br><span class="line">            <span class="comment">// queuing the resolver function for later use</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; <span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="title function_">push</span>(resolve); &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">close</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// Once the queue is closed, no more values will be enqueued.</span></span><br><span class="line">        <span class="comment">// So resolve any pending Promises with the end-of-stream marker</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">resolvers</span>.<span class="title function_">shift</span>()(<span class="title class_">AsyncQueue</span>.<span class="property">EOS</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">closed</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define the method that makes this class asynchronously iterable</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">asyncIterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define the method that makes this an asynchronous iterator. The</span></span><br><span class="line">    <span class="comment">// dequeue() Promise resolves to a value or the EOS sentinel if we&#x27;re</span></span><br><span class="line">    <span class="comment">// closed. Here, we need to return a Promise that resolves to an</span></span><br><span class="line">    <span class="comment">// iterator result object.</span></span><br><span class="line">    <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">dequeue</span>().<span class="title function_">then</span>(<span class="function"><span class="params">value</span> =&gt;</span> (value === <span class="title class_">AsyncQueue</span>.<span class="property">EOS</span>)</span><br><span class="line">                                   ? &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">                                   : &#123; <span class="attr">value</span>: value, <span class="attr">done</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A sentinel value returned by dequeue() to mark &quot;end of stream&quot; when closed</span></span><br><span class="line"><span class="title class_">AsyncQueue</span>.<span class="property">EOS</span> = <span class="title class_">Symbol</span>(<span class="string">&quot;end-of-stream&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>Because this AsyncQueue class defines the asynchronous iteration basics, we can create our own, more interesting asynchronous iterators simply by asynchronously queueing values. Here’s an example that uses AsyncQueue to produce a stream of web browser events that can be handled with a for&#x2F;await loop:</p>
<blockquote>
<p>因为 AsyncQueue 类定义了异步迭代基础，所以我们可以简单地通过异步排队值来创建更有趣的自定义异步迭代器。这是一个使用 AsyncQueue 生成可通过 for&#x2F;await 循环处理的 web 浏览器事件流的示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Push events of the specified type on the specified document element</span></span><br><span class="line"><span class="comment">// onto an AsyncQueue object, and return the queue for use as an event stream</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">eventStream</span>(<span class="params">elt, type</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> q = <span class="keyword">new</span> <span class="title class_">AsyncQueue</span>();                  <span class="comment">// Create a queue</span></span><br><span class="line">    elt.<span class="title function_">addEventListener</span>(type, <span class="function"><span class="params">e</span>=&gt;</span>q.<span class="title function_">enqueue</span>(e)); <span class="comment">// Enqueue events</span></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleKeys</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Get a stream of keypress events and loop once for each one</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> event <span class="keyword">of</span> <span class="title function_">eventStream</span>(<span class="variable language_">document</span>, <span class="string">&quot;keypress&quot;</span>)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">key</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-5-Summary"><a href="#13-5-Summary" class="headerlink" title="13.5 Summary"></a>13.5 Summary</h2><p>In this chapter, you have learned:</p>
<blockquote>
<p>在本章中，您学习了：</p>
</blockquote>
<ul>
<li>Most real-world JavaScript programming is asynchronous.</li>
</ul>
<blockquote>
<p>大多数真实的 JavaScript 程序都是异步的。</p>
</blockquote>
<ul>
<li>Traditionally, asynchrony has been handled with events and callback functions. This can get complicated, however, because you can end up with multiple levels of callbacks nested inside other callbacks, and because it is difficult to do robust error handling.</li>
</ul>
<blockquote>
<p>传统上，异步是通过事件和回调函数来处理的。但是，这可能会变得复杂，因为最终可能会嵌套在其他回调中嵌套的多个级别的回调，并且因为很难进行可靠的异常处理。</p>
</blockquote>
<ul>
<li>Promises provide a new way of structuring callback functions. If used correctly (and unfortunately, Promises are easy to use incorrectly), they can convert asynchronous code that would have been nested into linear chains of then() calls where one asynchronous step of a computation follows another. Also, Promises allow you to centralize your error-handling code into a single catch() call at the end of a chain of then() calls.</li>
</ul>
<blockquote>
<p>Promise 提供了构造回调函数的新方法。如果正确使用（不幸的是，Promise 易于错误使用），它们可以将异步代码转换为嵌套在调用 then() 的线性链中的代码，一个计算的异步步骤跟随在其他之后。而且，Promise 允许将异常处理代码集中到一个 then() 调用链末尾的单个 catch() 调用中。</p>
</blockquote>
<ul>
<li>The async and await keywords allow us to write asynchronous code that is Promise-based under the hood but that looks like synchronous code. This makes the code easier to understand and reason about. If a function is declared async, it will implicitly return a Promise. Inside an async function, you can await a Promise (or a function that returns a Promise) as if the Promise value was synchronously computed.</li>
</ul>
<blockquote>
<p>async 和 await 关键字允许我们编写异步代码，该代码基于 Promise，但看起来像同步代码。这使代码更易于理解和推理。如果一个函数被声明为 async，它将隐式返回一个 Promise。在异步函数内部，可以 await Promise（或返回 Promise 的函数），就像 Promise 值是同步计算的一样。</p>
</blockquote>
<ul>
<li>Objects that are asynchronously iterable can be used with a for&#x2F;await loop. You can create asynchronously iterable objects by implementing a <a href="">Symbol.asyncIterator</a> method or by invoking an async function * generator function. Asynchronous iterators provide an alternative to “data” events on streams in Node and can be used to represent a stream of user input events in client-side JavaScript.</li>
</ul>
<blockquote>
<p>异步可迭代的对象可以与 for&#x2F;await 循环一起使用。可以通过实现 [Symbol.asyncIterator]() 方法或调用 async function* 生成器函数来创建异步可迭代对象。异步迭代器为 Node 中流的“data”事件提供了一种替代方法，可用于表示客户端 JavaScript 中的用户输入事件的流。</p>
</blockquote>
<p>[^1]: The XMLHttpRequest class has nothing in particular to do with XML. In modern client-side JavaScript, it has largely been replaced by the fetch() API, which is covered in §15.11.1. The code example shown here is the last XMLHttpRequest-based example remaining in this book.<br>[^2]: You can typically use await at the top level in a browser’s developer console. And there is a pending proposal to allow top-level await in a future version of JavaScript.<br>[^3]: I learned about this approach to asynchronous iteration from the blog of Dr. Axel Rauschmayer, <a href="">https://2ality.com</a>.</p>
<blockquote>
<p>[^1]: XMLHttpRequest 类与 XML 无关。在现代的客户端 JavaScript 中，它已被 fetch() API 取代，该 API 已在 §15.11.1 中进行了介绍。此处显示的代码示例是本书中最后一个基于 XMLHttpRequest 的示例。<br>[^2]: 通常，可以在浏览器的开发人员控制台的顶层使用 await。还有一个悬而未决的建议，允许在将来的 JavaScript 版本中进行顶级 await。<br>[^3]: 我从 Dr. Axel Rauschmayer 的博客<a href="">https://2ality.com</a>中了解了这种异步迭代方法。</p>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Jack hou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/')">第13章 异步 JavaScript</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wechat/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=第13章 异步 JavaScript&amp;url=http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/&amp;pic=https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover3.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.houyanbin.com" target="_blank">Jackhou Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>《JavaScript权威指南》<span class="tagsPageCount">17</span></a><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">17</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch14/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第14章 元编程</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch12/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover4.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第12章 迭代器和生成器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch1/" title="第1章 JavaScript 概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第1章 JavaScript 概述</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch10/" title="第10章 模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第10章 模块</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch11/" title="第11章 JavaScript 标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第11章 JavaScript 标准库</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch14/" title="第14章 元编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第14章 元编程</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch12/" title="第12章 迭代器和生成器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第12章 迭代器和生成器</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch2/" title="第2章 词法结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第2章 词法结构</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">Hi，这是我的博客网站，欢迎你能到访~</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">我会在这里分享我的<b style="color:#fff">技术知识</b>、<b style="color:#fff">日常生活</b>和<b style="color:#fff">人生经验。</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Jack hou</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/YingxueSec" target="_blank" title="Github"><i class="fab fa-github faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/478589474" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=jackhou921@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wxgzh12.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(undefined) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-Asynchronous-Programming-with-Callbacks"><span class="toc-text">13.1 Asynchronous Programming with Callbacks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1-Timers"><span class="toc-text">13.1.1 Timers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-Events"><span class="toc-text">13.1.2 Events</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-3-Network-Events"><span class="toc-text">13.1.3 Network Events</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-4-Callbacks-and-Events-in-Node"><span class="toc-text">13.1.4 Callbacks and Events in Node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-Promises"><span class="toc-text">13.2 Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IMPORTANT"><span class="toc-text">IMPORTANT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-1-Using-Promises"><span class="toc-text">13.2.1 Using Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HANDLING-ERRORS-WITH-PROMISES"><span class="toc-text">HANDLING ERRORS WITH PROMISES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PROMISE-TERMINOLOGY"><span class="toc-text">PROMISE TERMINOLOGY</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-2-Chaining-Promises"><span class="toc-text">13.2.2 Chaining Promises</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-3-Resolving-Promises"><span class="toc-text">13.2.3 Resolving Promises</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-4-More-on-Promises-and-Errors"><span class="toc-text">13.2.4 More on Promises and Errors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#THE-CATCH-AND-FINALLY-METHODS"><span class="toc-text">THE CATCH AND FINALLY METHODS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RETURNING-FROM-A-PROMISE-CALLBACK"><span class="toc-text">RETURNING FROM A PROMISE CALLBACK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-5-Promises-in-Parallel"><span class="toc-text">13.2.5 Promises in Parallel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-6-Making-Promises"><span class="toc-text">13.2.6 Making Promises</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PROMISES-BASED-ON-OTHER-PROMISES"><span class="toc-text">PROMISES BASED ON OTHER PROMISES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PROMISES-BASED-ON-SYNCHRONOUS-VALUES"><span class="toc-text">PROMISES BASED ON SYNCHRONOUS VALUES</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PROMISES-FROM-SCRATCH"><span class="toc-text">PROMISES FROM SCRATCH</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-7-Promises-in-Sequence"><span class="toc-text">13.2.7 Promises in Sequence</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-async-and-await"><span class="toc-text">13.3 async and await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-1-await-Expressions"><span class="toc-text">13.3.1 await Expressions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-2-async-Functions"><span class="toc-text">13.3.2 async Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-3-Awaiting-Multiple-Promises"><span class="toc-text">13.3.3 Awaiting Multiple Promises</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-4-Implementation-Details"><span class="toc-text">13.3.4 Implementation Details</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-Asynchronous-Iteration"><span class="toc-text">13.4 Asynchronous Iteration</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-1-The-for-x2F-await-Loop"><span class="toc-text">13.4.1 The for&#x2F;await Loop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-2-Asynchronous-Iterators"><span class="toc-text">13.4.2 Asynchronous Iterators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-3-Asynchronous-Generators"><span class="toc-text">13.4.3 Asynchronous Generators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-4-Implementing-Asynchronous-Iterators"><span class="toc-text">13.4.4 Implementing Asynchronous Iterators</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-Summary"><span class="toc-text">13.5 Summary</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="做情人真的没有好下场吗？"/></a><div class="content"><a class="title" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？">做情人真的没有好下场吗？</a><time datetime="2023-08-14T16:00:00.000Z" title="发表于 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不爱前行"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行">不爱前行</a><time datetime="2023-07-29T16:00:00.000Z" title="发表于 2023-07-30 00:00:00">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="租房时光"/></a><div class="content"><a class="title" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光">租房时光</a><time datetime="2023-07-21T16:00:00.000Z" title="发表于 2023-07-22 00:00:00">2023-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="故宫记"/></a><div class="content"><a class="title" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记">故宫记</a><time datetime="2023-06-10T16:00:00.000Z" title="发表于 2023-06-11 00:00:00">2023-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息收集道道之外网信息收集"/></a><div class="content"><a class="title" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集">信息收集道道之外网信息收集</a><time datetime="2023-05-28T16:00:00.000Z" title="发表于 2023-05-29 00:00:00">2023-05-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 By <a class="footer-bar-link" href="/" title="Jack hou" target="_blank">Jack hou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 0.88rem; color: rgb(173, 116, 189);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem; color: rgb(172, 13, 64);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem; color: rgb(33, 117, 72);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem; color: rgb(88, 174, 86);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; color: rgb(125, 194, 51);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem; color: rgb(42, 170, 99);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 0.88rem; color: rgb(185, 178, 62);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem; color: rgb(155, 65, 84);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 0.88rem; color: rgb(122, 156, 196);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem; color: rgb(128, 177, 171);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 0.88rem; color: rgb(69, 117, 152);">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 0.88rem; color: rgb(156, 27, 95);">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem; color: rgb(179, 76, 189);">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem; color: rgb(109, 193, 73);">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 0.88rem; color: rgb(72, 77, 180);">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 0.88rem; color: rgb(55, 40, 89);">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 0.88rem; color: rgb(33, 170, 5);">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem; color: rgb(192, 64, 93);">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 0.88rem; color: rgb(187, 112, 12);">越权<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8868465080" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8868465080&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("4/15/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Jack hou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("4/15/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.houyanbin.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>