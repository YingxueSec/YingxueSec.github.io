<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript | Jackhou Blog</title><meta name="keywords" content="ã€ŠJavaScriptæƒå¨æŒ‡å—ã€‹,JavaScript"><meta name="author" content="Jack hou"><meta name="copyright" content="Jack hou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript"><meta name="application-name" content="ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript"><meta property="og:url" content="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch16/index.html"><meta property="og:site_name" content="Jackhou Blog"><meta property="og:description" content="Node is JavaScript with bindings to the underlying operating system, making it possible to write JavaScript programs that read and write files, ex"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg"><meta property="article:author" content="Jack hou"><meta property="article:tag" content="Jackhou, blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg"><meta name="description" content="Node is JavaScript with bindings to the underlying operating system, making it possible to write JavaScript programs that read and write files, ex"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch16/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ï¾ŸĞ”ï¾Ÿ)w ä¸è¦èµ°ï¼å†çœ‹çœ‹å˜›ï¼","backTitle":"â™ª(^âˆ‡^*)æ¬¢è¿è‚¥æ¥ï¼"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.houyanbin.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"æ‰¾ä¸åˆ°æ‚¨æŸ¥è¯¢çš„å†…å®¹ï¼š${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"ç¹","msgToSimplifiedChinese":"ç®€","rightMenuMsgToTraditionalChinese":"è½¬ä¸ºç¹ä½“","rightMenuMsgToSimplifiedChinese":"è½¬ä¸ºç®€ä½“"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: 'å¤åˆ¶æˆåŠŸ',
    error: 'å¤åˆ¶é”™è¯¯',
    noSupport: 'æµè§ˆå™¨ä¸æ”¯æŒ'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: 'å¤©',
  date_suffix: {
    just: 'åˆšåˆš',
    min: 'åˆ†é’Ÿå‰',
    hour: 'å°æ—¶å‰',
    day: 'å¤©å‰',
    month: 'ä¸ªæœˆå‰'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"ä½œè€…: Jack hou","link":"é“¾æ¥: ","source":"æ¥æº: Jackhou Blog","info":"è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚","copySuccess":"å¤åˆ¶æˆåŠŸï¼Œå¤åˆ¶å’Œè½¬è½½è¯·æ ‡æ³¨æœ¬æ–‡åœ°å€"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"ä½ å·²åˆ‡æ¢ä¸ºç¹ä½“","cht_to_chs":"ä½ å·²åˆ‡æ¢ä¸ºç®€ä½“","day_to_night":"ä½ å·²åˆ‡æ¢ä¸ºæ·±è‰²æ¨¡å¼","night_to_day":"ä½ å·²åˆ‡æ¢ä¸ºæµ…è‰²æ¨¡å¼","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Jackhou Blog',
  title: 'ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript',
  postAI: '',
  pageFillDescription: 'INSTALLING NODE, 16.1 Node Programming Basics, 16.1.1 Console Output, 16.1.2 Command-Line Arguments and Environment Variables, 16.1.3 Program Life Cycle, 16.1.4 Node Modules, 16.1.5 The Node Package Manager, 16.2 Node Is Asynchronous by Default, 16.3 Buffers, 16.4 Events and EventEmitter, 16.5 Streams, 16.5.1 Pipes, 16.5.2 Asynchronous Iteration, 16.5.3 Writing to Streams and Handling Backpressure, 16.5.4 Reading Streams with Events, 16.6 Process CPU and Operating System Details, 16.7 Working with Files, 16.7.1 Paths File Descriptors and FileHandles, 16.7.2 Reading Files, 16.7.3 Writing Files, 16.7.4 File Operations, 16.7.5 File Metadata, 16.7.6 Working with Directories, 16.8 HTTP Clients and Servers, 16.9 Non-HTTP Network Servers and Clients, 16.10 Working with Child Processes, 16.10.1 execSync() and execFileSync(), 16.10.2 exec() and execFile(), 16.10.3 spawn(), 16.10.4 fork(), 16.11 Worker Threads, 16.11.1 Creating Workers and Passing Messages, 16.11.2 The Worker Execution Environment, 16.11.3 Communication Channels and MessagePorts, 16.11.4 Transferring MessagePorts and Typed Arrays, 16.11.5 Sharing Typed Arrays Between Threads, 16.12 Summaryæ˜¯ç»‘å®šåˆ°åº•å±‚æ“ä½œç³»ç»Ÿçš„ä½¿ç¼–å†™ç¨‹åºèƒ½å¤Ÿè¯»å†™æ–‡ä»¶æ‰§è¡Œå­è¿›ç¨‹å’Œé€šè¿‡ç½‘ç»œé€šä¿¡è¿™ä½¿å¾—å¯ä»¥ç”¨ä½œä¸å—å’Œå…¶ä»–çš„ç¥ç§˜è¯­æ³•å½±å“çš„è„šæœ¬çš„ç°ä»£æ›¿ä»£æ–¹æ¡ˆé€šç”¨ç¨‹å¼è®¾è®¡è¯­è¨€ç”¨ä»¥è¿è¡Œå—ä¿¡ä»»çš„ç¨‹å¼è€Œä¸å—ç½‘é¡µæµè§ˆå™¨å¯¹ä¸å—ä¿¡ä»»çš„ç¨‹å¼æ‰€æ–½åŠ çš„ä¿å®‰é™åˆ¶ç¼–å†™é«˜æ•ˆå’Œé«˜å¹¶å‘æœåŠ¡å™¨çš„æµè¡Œç¯å¢ƒçš„å®šä¹‰ç‰¹æ€§æ˜¯å®ƒçš„å•çº¿ç¨‹çš„åŸºäºäº‹ä»¶çš„å¹¶å‘æ€§è¿™æ˜¯é€šè¿‡ä¸€ä¸ªé»˜è®¤å¼‚æ­¥çš„å®ç°çš„å¦‚æœæ‚¨ä½¿ç”¨å…¶ä»–è¯­è¨€ç¼–å†™è¿‡ç¨‹åºä½†æ²¡æœ‰è¿›è¡Œè¿‡å¤šçš„ç¼–ç æˆ–è€…å¦‚æœæ‚¨æ˜¯ä¸€åç»éªŒä¸°å¯Œçš„å®¢æˆ·ç«¯ç¨‹åºå‘˜ä¹ æƒ¯äºä¸ºæµè§ˆå™¨ç¼–å†™ä»£ç é‚£ä¹ˆä½¿ç”¨å°±éœ€è¦ä¸€ç‚¹è°ƒæ•´ä»»ä½•æ–°çš„ç¼–ç¨‹è¯­è¨€æˆ–ç¯å¢ƒéƒ½æ˜¯å¦‚æ­¤æœ¬ç« ä»è§£é‡ŠèŠ‚ç‚¹ç¼–ç¨‹æ¨¡å‹å¼€å§‹é‡ç‚¹ä»‹ç»å¹¶å‘æ€§å¤„ç†æµæ•°æ®çš„èŠ‚ç‚¹å’Œå¤„ç†äºŒè¿›åˆ¶æ•°æ®çš„èŠ‚ç‚¹ç¼“å†²åŒºç±»å‹åœ¨è¿™äº›åˆå§‹éƒ¨åˆ†ä¹‹åæ˜¯çªå‡ºæ˜¾ç¤ºå’Œæ¼”ç¤ºä¸€äº›æœ€é‡è¦çš„èŠ‚ç‚¹çš„éƒ¨åˆ†åŒ…æ‹¬é‚£äº›ç”¨äºå¤„ç†æ–‡ä»¶ç½‘ç»œè¿›ç¨‹å’Œçº¿ç¨‹çš„ä¸€ç« ä¸è¶³ä»¥è®°å½•æ‰€æœ‰çš„ä½†æˆ‘å¸Œæœ›è¿™ä¸€ç« èƒ½å¤Ÿè§£é‡Šè¶³å¤Ÿå¤šçš„åŸºç¡€çŸ¥è¯†ä½¿æ‚¨èƒ½å¤Ÿé«˜æ•ˆåœ°ä½¿ç”¨å¹¶ç¡®ä¿¡æ‚¨èƒ½å¤ŸæŒæ¡æ‰€éœ€çš„ä»»ä½•æ–°çš„æ˜¯å¼€æºè½¯ä»¶è®¿é—®ä¸‹è½½å¹¶å®‰è£…ç”¨äºå’Œçš„èŠ‚ç‚¹åœ¨ä¸Šæ‚¨å¯ä»¥ä½¿ç”¨æ™®é€šçš„åŒ…ç®¡ç†å™¨å®‰è£…æˆ–è€…æ‚¨å¯ä»¥è®¿é—®æ¥ç›´æ¥ä¸‹è½½äºŒè¿›åˆ¶æ–‡ä»¶å¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯å®¹å™¨åŒ–è½¯ä»¶æ‚¨å¯ä»¥åœ¨æ‰¾åˆ°å®˜æ–¹èŠ‚ç‚¹é•œåƒé™¤äº†èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶ä¹‹å¤–èŠ‚ç‚¹å®‰è£…è¿˜åŒ…æ‹¬è¿™æ˜¯ä¸€ä¸ªåŒ…ç®¡ç†å™¨å¯ä»¥æ–¹ä¾¿åœ°è®¿é—®å¤§é‡çš„å·¥å…·å’Œåº“æœ¬ç« ä¸­çš„ç¤ºä¾‹å°†åªä½¿ç”¨çš„å†…ç½®åŒ…è€Œä¸éœ€è¦æˆ–ä»»ä½•å¤–éƒ¨åº“æœ€åä¸è¦å¿½è§†å®˜æ–¹èŠ‚ç‚¹æ–‡æ¡£å¯ä»¥ä»å’Œè·å¾—æˆ‘å‘ç°å®ƒç»„ç»‡å¾—å¾ˆå¥½å†™å¾—ä¹Ÿå¾ˆå¥½åœ¨æœ¬ç« çš„å¼€å§‹æˆ‘ä»¬å°†å¿«é€Ÿäº†è§£èŠ‚ç‚¹ç¨‹åºæ˜¯å¦‚ä½•æ„å»ºçš„ä»¥åŠå®ƒä»¬å¦‚ä½•ä¸æ“ä½œç³»ç»Ÿäº¤äº’å¦‚æœæ‚¨ä¹ æƒ¯äº†æµè§ˆå™¨çš„ç¼–ç¨‹é‚£ä¹ˆçš„ä¸€ä¸ªå°æƒŠå–œå°±æ˜¯ä¸ä»…ç”¨äºè°ƒè¯•è€Œä¸”æ˜¯å‘ç”¨æˆ·æ˜¾ç¤ºæ¶ˆæ¯çš„æœ€ç®€å•çš„æ–¹å¼æˆ–è€…æ›´ä¸€èˆ¬åœ°å°†è¾“å‡ºå‘é€åˆ°æµçš„æœ€ç®€å•æ–¹å¼ä¸‹é¢æ˜¯ä¸­çš„ç»å…¸ç¨‹åºæœ‰ä¸€äº›ä½çº§åˆ«çš„æ–¹æ³•å¯ä»¥å†™å…¥ä½†æ˜¯æ²¡æœ‰æ¯”ç®€å•åœ°è°ƒç”¨æ›´é«˜çº§æˆ–æ›´æ­£å¼çš„æ–¹æ³•äº†åœ¨æµè§ˆå™¨ä¸­å’Œé€šå¸¸åœ¨å¼€å‘äººå‘˜æ§åˆ¶å°ä¸­å®ƒä»¬çš„è¾“å‡ºæ—è¾¹æ˜¾ç¤ºå°å›¾æ ‡ä»¥æŒ‡ç¤ºæ—¥å¿—æ¶ˆæ¯çš„ç§ç±»ä¸è¿™æ ·åšä½†æ˜¯ä½¿ç”¨æ˜¾ç¤ºçš„è¾“å‡ºä¸ä½¿ç”¨æ˜¾ç¤ºçš„è¾“å‡ºæ˜¯ä¸åŒçš„å› ä¸ºå†™å…¥æµå¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨ç¼–å†™ä¸€ä¸ªç¨‹åºè¯¥ç¨‹åºè®¾è®¡ä¸ºå°†é‡å®šå‘åˆ°æ–‡ä»¶æˆ–ç®¡é“é‚£ä¹ˆæ‚¨å¯ä»¥ä½¿ç”¨å°†æ–‡æœ¬æ˜¾ç¤ºåˆ°æ§åˆ¶å°ç”¨æˆ·å°†åœ¨é‚£é‡Œçœ‹åˆ°å®ƒå³ä½¿ä½¿ç”¨æ‰“å°çš„æ–‡æœ¬æ˜¯éšè—çš„',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:46:30',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="åŠ è½½å¤´åƒ" src="/null"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">ç½‘é¡µ</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="åšå®¢"><img class="back-menu-item-icon" src="/img/favicon.png" alt="åšå®¢"/><span class="back-menu-item-text">åšå®¢</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">é¡¹ç›®</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="å®‰çŸ¥é±¼å›¾åºŠ"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="å®‰çŸ¥é±¼å›¾åºŠ"/><span class="back-menu-item-text">å®‰çŸ¥é±¼å›¾åºŠ</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Jackhou Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> æ–‡ç« </span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> éš§é“</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> åˆ†ç±»</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> æ ‡ç­¾</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> å‹é“¾</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> å‹äººå¸</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> ç•™è¨€æ¿</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> æˆ‘çš„</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> éŸ³ä¹é¦†</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> è¿½ç•ªé¡µ</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> ç›¸å†Œé›†</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> å…³äº</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> å…³äºæœ¬äºº</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> é—²è¨€ç¢è¯­</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> éšä¾¿é€›é€›</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="éšæœºå‰å¾€ä¸€ä¸ªå¼€å¾€é¡¹ç›®ç½‘ç«™"><a class="site-page" onclick="anzhiyu.totraveling()" title="éšæœºå‰å¾€ä¸€ä¸ªå¼€å¾€é¡¹ç›®ç½‘ç«™" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="éšæœºå‰å¾€ä¸€ä¸ªæ–‡ç« " href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="æœç´¢ğŸ”" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> æœç´¢</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="ä¸­æ§å°" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">äº’åŠ¨</div><span class="author-content-item-title"> æœ€æ–°è¯„è®º</span></div><div class="aside-list"><span>æ­£åœ¨åŠ è½½ä¸­...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">å…´è¶£ç‚¹</div><span class="author-content-item-title">å¯»æ‰¾ä½ æ„Ÿå…´è¶£çš„é¢†åŸŸ</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 1.05rem; color: rgb(109, 105, 196);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem; color: rgb(92, 106, 34);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem; color: rgb(182, 3, 38);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem; color: rgb(122, 61, 111);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem; color: rgb(90, 45, 52);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem; color: rgb(37, 160, 28);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 1.05rem; color: rgb(133, 195, 75);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem; color: rgb(178, 108, 107);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 1.05rem; color: rgb(78, 139, 37);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem; color: rgb(160, 25, 21);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 1.05rem; color: rgb(78, 57, 33);">ã€ŠJavaScriptæƒå¨æŒ‡å—ã€‹<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 1.05rem; color: rgb(84, 120, 148);">åŒ¿å<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem; color: rgb(164, 80, 172);">åšå®¢<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem; color: rgb(152, 51, 77);">å®‰å…¨<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 1.05rem; color: rgb(59, 32, 16);">æ”¯ä»˜<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 1.05rem; color: rgb(104, 2, 134);">æ”»é˜²<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.05rem; color: rgb(173, 108, 167);">æ—…è¡Œ<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem; color: rgb(88, 7, 53);">è™šæ‹Ÿæœº<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 1.05rem; color: rgb(192, 129, 151);">è¶Šæƒ<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>æ–‡ç« </span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>å½’æ¡£</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">å…«æœˆ 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>ç¯‡</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">ä¸ƒæœˆ 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>ç¯‡</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">å…­æœˆ 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>ç¯‡</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">äº”æœˆ 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>ç¯‡</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">å››æœˆ 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">37</span><span>ç¯‡</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">ä¸‰æœˆ 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>ç¯‡</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="è¾¹æ æ˜¾ç¤ºæ§åˆ¶"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="çƒ­è¯„å¼€å…³"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="éŸ³ä¹å¼€å…³"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="åˆ‡æ¢"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">åŸåˆ›</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">æŠ€æœ¯</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>ã€ŠJavaScriptæƒå¨æŒ‡å—ã€‹</span></a><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">å‘è¡¨äº</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:45.000Z" title="å‘è¡¨äº 2023-04-26 00:00:45">2023-04-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">æ›´æ–°äº</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-04-26T13:46:30.000Z" title="æ›´æ–°äº 2023-04-26 21:46:30">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="é˜…è¯»é‡">é˜…è¯»é‡:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="ä½œè€…IPå±åœ°ä¸ºé•¿æ²™"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>é•¿æ²™</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch16/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">æŠ€æœ¯</a><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url">ã€ŠJavaScriptæƒå¨æŒ‡å—ã€‹</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><h1 id="CrawlerTitle" itemprop="name headline">ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jack hou</span><time itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:45.000Z" title="å‘è¡¨äº 2023-04-26 00:00:45">2023-04-26</time><time itemprop="dateCreated datePublished" datetime="2023-04-26T13:46:30.000Z" title="æ›´æ–°äº 2023-04-26 21:46:30">2023-04-26</time></header><meta name="referrer" content="no-referrer"/>



<p>Node is JavaScript with bindings to the underlying operating system, making it possible to write JavaScript programs that read and write files, execute child processes, and communicate over the network. This makes Node useful as a:</p>
<blockquote>
<p>Nodeæ˜¯ç»‘å®šåˆ°åº•å±‚æ“ä½œç³»ç»Ÿçš„JavaScriptï¼Œä½¿ç¼–å†™JavaScriptç¨‹åºèƒ½å¤Ÿè¯»å†™æ–‡ä»¶ã€æ‰§è¡Œå­è¿›ç¨‹å’Œé€šè¿‡ç½‘ç»œé€šä¿¡ã€‚è¿™ä½¿å¾—Nodeå¯ä»¥ç”¨ä½œ:</p>
</blockquote>
<ul>
<li>Modern alternative to shell scripts that does not suffer from the arcane syntax of bash and other Unix shells.</li>
<li>General-purpose programming language for running trusted programs, not subject to the security constraints imposed by web browsers on untrusted code.</li>
<li>Popular environment for writing efficient and highly concurrent web servers.</li>
</ul>
<hr>
<blockquote>
<ul>
<li>ä¸å—bashå’Œå…¶ä»–Unix shellçš„ç¥ç§˜è¯­æ³•å½±å“çš„shellè„šæœ¬çš„ç°ä»£æ›¿ä»£æ–¹æ¡ˆã€‚</li>
<li>é€šç”¨ç¨‹å¼è®¾è®¡è¯­è¨€ï¼Œç”¨ä»¥è¿è¡Œå—ä¿¡ä»»çš„ç¨‹å¼ï¼Œè€Œä¸å—ç½‘é¡µæµè§ˆå™¨å¯¹ä¸å—ä¿¡ä»»çš„ç¨‹å¼æ‰€æ–½åŠ çš„ä¿å®‰é™åˆ¶ã€‚</li>
<li>ç¼–å†™é«˜æ•ˆå’Œé«˜å¹¶å‘webæœåŠ¡å™¨çš„æµè¡Œç¯å¢ƒã€‚</li>
</ul>
</blockquote>
<p>The defining feature of Node is its single-threaded event-based concurrency enabled by an asynchronous-by-default API. If you have programmed in other languages but have not done much JavaScript coding, or if youâ€™re an experienced client-side JavaScript programmer used to writing code for web browers, using Node will be a bit of an adjustment, as is any new programming language or environment. This chapter begins by explaining the Node programming model, with an emphasis on concurrency, Nodeâ€™s API for working with streaming data, and Nodeâ€™s Buffer type for working with binary data. These initial sections are followed by sections that highlight and demonstrate some of the most important Node APIs, including those for working with files, networks, processes, and threads.</p>
<blockquote>
<p>Nodeçš„å®šä¹‰ç‰¹æ€§æ˜¯å®ƒçš„å•çº¿ç¨‹çš„åŸºäºäº‹ä»¶çš„å¹¶å‘æ€§ï¼Œè¿™æ˜¯é€šè¿‡ä¸€ä¸ªé»˜è®¤å¼‚æ­¥çš„APIå®ç°çš„ã€‚å¦‚æœæ‚¨ä½¿ç”¨å…¶ä»–è¯­è¨€ç¼–å†™è¿‡ç¨‹åºï¼Œä½†æ²¡æœ‰è¿›è¡Œè¿‡å¤šçš„JavaScriptç¼–ç ï¼Œæˆ–è€…å¦‚æœæ‚¨æ˜¯ä¸€åç»éªŒä¸°å¯Œçš„å®¢æˆ·ç«¯JavaScriptç¨‹åºå‘˜ï¼Œä¹ æƒ¯äºä¸ºwebæµè§ˆå™¨ç¼–å†™ä»£ç ï¼Œé‚£ä¹ˆä½¿ç”¨Nodeå°±éœ€è¦ä¸€ç‚¹è°ƒæ•´ï¼Œä»»ä½•æ–°çš„ç¼–ç¨‹è¯­è¨€æˆ–ç¯å¢ƒéƒ½æ˜¯å¦‚æ­¤ã€‚æœ¬ç« ä»è§£é‡ŠèŠ‚ç‚¹ç¼–ç¨‹æ¨¡å‹å¼€å§‹ï¼Œé‡ç‚¹ä»‹ç»å¹¶å‘æ€§ã€å¤„ç†æµæ•°æ®çš„èŠ‚ç‚¹APIå’Œå¤„ç†äºŒè¿›åˆ¶æ•°æ®çš„èŠ‚ç‚¹ç¼“å†²åŒºç±»å‹ã€‚åœ¨è¿™äº›åˆå§‹éƒ¨åˆ†ä¹‹åæ˜¯çªå‡ºæ˜¾ç¤ºå’Œæ¼”ç¤ºä¸€äº›æœ€é‡è¦çš„èŠ‚ç‚¹apiçš„éƒ¨åˆ†ï¼ŒåŒ…æ‹¬é‚£äº›ç”¨äºå¤„ç†æ–‡ä»¶ã€ç½‘ç»œã€è¿›ç¨‹å’Œçº¿ç¨‹çš„apiã€‚</p>
</blockquote>
<p>One chapter is not enough to document all of Nodeâ€™s APIs, but my hope is that this chapter will explain enough of the fundamentals to make you productive with Node, and confident that you can master any new APIs you need.</p>
<blockquote>
<p>ä¸€ç« ä¸è¶³ä»¥è®°å½•æ‰€æœ‰çš„Node apiï¼Œä½†æˆ‘å¸Œæœ›è¿™ä¸€ç« èƒ½å¤Ÿè§£é‡Šè¶³å¤Ÿå¤šçš„åŸºç¡€çŸ¥è¯†ï¼Œä½¿æ‚¨èƒ½å¤Ÿé«˜æ•ˆåœ°ä½¿ç”¨Nodeï¼Œå¹¶ç¡®ä¿¡æ‚¨èƒ½å¤ŸæŒæ¡æ‰€éœ€çš„ä»»ä½•æ–°çš„apiã€‚</p>
</blockquote>
<h4 id="INSTALLING-NODE"><a href="#INSTALLING-NODE" class="headerlink" title="INSTALLING NODE"></a>INSTALLING NODE</h4><p>Node is open source software. Visit <a target="_blank" rel="noopener" href="https://nodejs.org/">https://nodejs.org</a> to download and install Node for Windows and MacOS. On Linux, you may be able to install Node with your normal package manager, or you can visit <a target="_blank" rel="noopener" href="https://nodejs.org/en/download">https://nodejs.org/en/download</a> to download the binaries directly. If you work on containerized software, you can find official Node Docker images at <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com</a>.</p>
<blockquote>
<p>Nodeæ˜¯å¼€æºè½¯ä»¶ã€‚è®¿é—®<a target="_blank" rel="noopener" href="https://nodejs.orgä¸‹è½½å¹¶å®‰è£…ç”¨äºwindowså’Œmacosçš„èŠ‚ç‚¹.åœ¨linuxä¸Š,æ‚¨å¯ä»¥ä½¿ç”¨æ™®é€šçš„åŒ…ç®¡ç†å™¨å®‰è£…node,æˆ–è€…æ‚¨å¯ä»¥è®¿é—®https//nodejs.org/en/download%E6%9D%A5%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BD%AF%E4%BB%B6%EF%BC%8C%E6%82%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8https://hub.docker.com%E6%89%BE%E5%88%B0%E5%AE%98%E6%96%B9%E8%8A%82%E7%82%B9Docker%E9%95%9C%E5%83%8F%E3%80%82">https://nodejs.orgä¸‹è½½å¹¶å®‰è£…ç”¨äºWindowså’ŒMacOSçš„èŠ‚ç‚¹ã€‚åœ¨Linuxä¸Šï¼Œæ‚¨å¯ä»¥ä½¿ç”¨æ™®é€šçš„åŒ…ç®¡ç†å™¨å®‰è£…Nodeï¼Œæˆ–è€…æ‚¨å¯ä»¥è®¿é—®https://nodejs.org/en/downloadæ¥ç›´æ¥ä¸‹è½½äºŒè¿›åˆ¶æ–‡ä»¶ã€‚å¦‚æœæ‚¨ä½¿ç”¨çš„æ˜¯å®¹å™¨åŒ–è½¯ä»¶ï¼Œæ‚¨å¯ä»¥åœ¨https://hub.docker.comæ‰¾åˆ°å®˜æ–¹èŠ‚ç‚¹Dockeré•œåƒã€‚</a></p>
</blockquote>
<p>In addition to the Node executable, a Node installation also includes npm, a package manager that enables easy access to a vast ecosystem of JavaScript tools and libraries. The examples in this chapter will use only Nodeâ€™s built-in packages and will not require npm or any external libraries.</p>
<blockquote>
<p>é™¤äº†èŠ‚ç‚¹å¯æ‰§è¡Œæ–‡ä»¶ä¹‹å¤–ï¼ŒèŠ‚ç‚¹å®‰è£…è¿˜åŒ…æ‹¬npmï¼Œè¿™æ˜¯ä¸€ä¸ªåŒ…ç®¡ç†å™¨ï¼Œå¯ä»¥æ–¹ä¾¿åœ°è®¿é—®å¤§é‡çš„JavaScriptå·¥å…·å’Œåº“ã€‚æœ¬ç« ä¸­çš„ç¤ºä¾‹å°†åªä½¿ç”¨Nodeçš„å†…ç½®åŒ…ï¼Œè€Œä¸éœ€è¦npmæˆ–ä»»ä½•å¤–éƒ¨åº“ã€‚</p>
</blockquote>
<p>Finally, do not overlook the official Node documentation, available at <a target="_blank" rel="noopener" href="https://nodejs.org/api">https://nodejs.org/api</a> and <a target="_blank" rel="noopener" href="https://nodejs.org/docs/guides">https://nodejs.org/docs/guides</a>. I have found it to be well organized and well written.</p>
<blockquote>
<p>æœ€åï¼Œä¸è¦å¿½è§†å®˜æ–¹èŠ‚ç‚¹æ–‡æ¡£ï¼Œå¯ä»¥ä»<a target="_blank" rel="noopener" href="https://nodejs.org/api%E5%92%8Chttps://nodejs.org/docs/guides%E8%8E%B7%E5%BE%97%E3%80%82%E6%88%91%E5%8F%91%E7%8E%B0%E5%AE%83%E7%BB%84%E7%BB%87%E5%BE%97%E5%BE%88%E5%A5%BD%EF%BC%8C%E5%86%99%E5%BE%97%E4%B9%9F%E5%BE%88%E5%A5%BD%E3%80%82">https://nodejs.org/apiå’Œhttps://nodejs.org/docs/guidesè·å¾—ã€‚æˆ‘å‘ç°å®ƒç»„ç»‡å¾—å¾ˆå¥½ï¼Œå†™å¾—ä¹Ÿå¾ˆå¥½ã€‚</a></p>
</blockquote>
<h2 id="16-1-Node-Programming-Basics"><a href="#16-1-Node-Programming-Basics" class="headerlink" title="16.1 Node Programming Basics"></a>16.1 Node Programming Basics</h2><p>Weâ€™ll begin this chapter with a quick look at how Node programs are structured and how they interact with the operating system.</p>
<blockquote>
<p>åœ¨æœ¬ç« çš„å¼€å§‹ï¼Œæˆ‘ä»¬å°†å¿«é€Ÿäº†è§£èŠ‚ç‚¹ç¨‹åºæ˜¯å¦‚ä½•æ„å»ºçš„ï¼Œä»¥åŠå®ƒä»¬å¦‚ä½•ä¸æ“ä½œç³»ç»Ÿäº¤äº’ã€‚</p>
</blockquote>
<h3 id="16-1-1-Console-Output"><a href="#16-1-1-Console-Output" class="headerlink" title="16.1.1 Console Output"></a>16.1.1 Console Output</h3><p>If you are used to JavaScript programming for web browsers, one of the minor surprises about Node is that console.log() is not just for debugging, but is Nodeâ€™s easiest way to display a message to the user, or, more generally, to send output to the stdout stream. Hereâ€™s the classic â€œHello Worldâ€ program in Node:</p>
<blockquote>
<p>å¦‚æœæ‚¨ä¹ æƒ¯äº†webæµè§ˆå™¨çš„JavaScriptç¼–ç¨‹ï¼Œé‚£ä¹ˆNodeçš„ä¸€ä¸ªå°æƒŠå–œå°±æ˜¯console.log()ä¸ä»…ç”¨äºè°ƒè¯•ï¼Œè€Œä¸”æ˜¯Nodeå‘ç”¨æˆ·æ˜¾ç¤ºæ¶ˆæ¯çš„æœ€ç®€å•çš„æ–¹å¼ï¼Œæˆ–è€…æ›´ä¸€èˆ¬åœ°ï¼Œå°†è¾“å‡ºå‘é€åˆ°stdoutæµçš„æœ€ç®€å•æ–¹å¼ã€‚ä¸‹é¢æ˜¯Nodeä¸­çš„ç»å…¸â€œHello Worldâ€ç¨‹åº:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>There are lower-level ways to write to stdout, but no fancier or more official way than simply calling console.log().</p>
<blockquote>
<p>æœ‰ä¸€äº›ä½çº§åˆ«çš„æ–¹æ³•å¯ä»¥å†™å…¥stdoutï¼Œä½†æ˜¯æ²¡æœ‰æ¯”ç®€å•åœ°è°ƒç”¨console.log()æ›´é«˜çº§æˆ–æ›´æ­£å¼çš„æ–¹æ³•äº†ã€‚</p>
</blockquote>
<p>In web browsers, console.log(), console.warn(), and console.error() typically display little icons next to their output in the developer console to indicate the variety of the log message. Node does not do this, but output displayed with console.error() is distinguished from output displayed with console.log() because console.error() writes to the stderr stream. If youâ€™re using Node to write a program that is designed to have stdout redirected to a file or a pipe, you can use console.error() to display text to the console where the user will see it, even though text printed with console.log() is hidden.</p>
<blockquote>
<p>åœ¨webæµè§ˆå™¨ä¸­ï¼Œconsole.log()ã€console.warn()å’Œconsole.error()é€šå¸¸åœ¨å¼€å‘äººå‘˜æ§åˆ¶å°ä¸­å®ƒä»¬çš„è¾“å‡ºæ—è¾¹æ˜¾ç¤ºå°å›¾æ ‡ï¼Œä»¥æŒ‡ç¤ºæ—¥å¿—æ¶ˆæ¯çš„ç§ç±»ã€‚Nodeä¸è¿™æ ·åšï¼Œä½†æ˜¯ä½¿ç”¨console.error()æ˜¾ç¤ºçš„è¾“å‡ºä¸ä½¿ç”¨console.log()æ˜¾ç¤ºçš„è¾“å‡ºæ˜¯ä¸åŒçš„ï¼Œå› ä¸ºconsole.error()å†™å…¥stderræµã€‚å¦‚æœæ‚¨æ­£åœ¨ä½¿ç”¨Nodeç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè¯¥ç¨‹åºè®¾è®¡ä¸ºå°†stdouté‡å®šå‘åˆ°æ–‡ä»¶æˆ–ç®¡é“ï¼Œé‚£ä¹ˆæ‚¨å¯ä»¥ä½¿ç”¨console.error()å°†æ–‡æœ¬æ˜¾ç¤ºåˆ°æ§åˆ¶å°ï¼Œç”¨æˆ·å°†åœ¨é‚£é‡Œçœ‹åˆ°å®ƒï¼Œå³ä½¿ä½¿ç”¨console.log()æ‰“å°çš„æ–‡æœ¬æ˜¯éšè—çš„ã€‚</p>
</blockquote>
<h3 id="16-1-2-Command-Line-Arguments-and-Environment-Variables"><a href="#16-1-2-Command-Line-Arguments-and-Environment-Variables" class="headerlink" title="16.1.2 Command-Line Arguments and Environment Variables"></a>16.1.2 Command-Line Arguments and Environment Variables</h3><p>If you have previously written Unix-style programs designed to be invoked from a terminal or other command-line interface, you know that these programs typically get their input primarily from command-line arguments and secondarily from environment variables.</p>
<p>Node follows these Unix conventions. A Node program can read its command-line arguments from the array of strings process.argv. The first element of this array is always the path to the Node executable. The second argument is the path to the file of JavaScript code that Node is executing. Any remaining elements in this array are the space-separated arguments that you passed on the command-line when you invoked Node.</p>
<p>For example, suppose you save this very short Node program to the file argv.js:</p>
<p>console.log(process.argv);<br>You can then execute the program and see output like this:</p>
<p>$ node â€“trace-uncaught argv.js â€“arg1 â€“arg2 filename<br>[<br>  â€˜&#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodeâ€™,<br>  â€˜&#x2F;private&#x2F;tmp&#x2F;argv.jsâ€™,<br>  â€˜â€“arg1â€™,<br>  â€˜â€“arg2â€™,<br>  â€˜filenameâ€™<br>]<br>There are a couple of things to note here:</p>
<p>The first and second elements of process.argv will be fully qualified filesystem paths to the Node executable and the file of JavaScript that is being executed, even if you did not type them that way.</p>
<p>Command-line arguments that are intended for and interpreted by the Node executable itself are consumed by the Node executable and do not appear in process.argv. (The â€“trace-uncaught command-line argument isnâ€™t actually doing anything useful in the previous example; it is just there to demonstrate that it does not appear in the output.) Any arguments (such as â€“arg1 and filename) that appear after the name of the JavaScript file will appear in process.argv.</p>
<p>Node programs can also take input from Unix-style environment variables. Node makes these available though the process.env object. The property names of this object are environment variable names, and the property values (always strings) are the values of those variables.</p>
<p>Here is a partial list of environment variables on my system:</p>
<p>$ node -p -e â€˜process.envâ€™<br>{<br>  SHELL: â€˜&#x2F;bin&#x2F;bashâ€™,<br>  USER: â€˜davidâ€™,<br>  PATH: â€˜&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbinâ€™,<br>  PWD: â€˜&#x2F;tmpâ€™,<br>  LANG: â€˜en_US.UTF-8â€™,<br>  HOME: â€˜&#x2F;Users&#x2F;davidâ€™,<br>}<br>You can use node -h or node â€“help to find out what the -p and -e command-line arguments do. However, as a hint, note that you could rewrite the line above as node â€“eval â€˜process.envâ€™ â€“print.</p>
<h3 id="16-1-3-Program-Life-Cycle"><a href="#16-1-3-Program-Life-Cycle" class="headerlink" title="16.1.3 Program Life Cycle"></a>16.1.3 Program Life Cycle</h3><p>The node command expects a command-line argument that specifies the file of JavaScript code to be run. This initial file typically imports other modules of JavaScript code, and may also define its own classes and functions. Fundamentally, however, Node executes the JavaScript code in the specified file from top to bottom. Some Node programs exit when they are done executing the last line of code in the file. Often, however, a Node program will keep running long after the initial file has been executed. As weâ€™ll discuss in the following sections, Node programs are often asynchronous and based on callbacks and event handlers. Node programs do not exit until they are done running the initial file and until all callbacks have been called and there are no more pending events. A Node-based server program that listens for incoming network connections will theoretically run forever because it will always be waiting for more events.</p>
<p>A program can force itself to exit by calling process.exit(). Users can usually terminate a Node program by typing Ctrl-C in the terminal window where the program is running. A program can ignore Ctrl-C by registering a signal handler function with process.on(â€œSIGINTâ€, ()&#x3D;&gt;{}).</p>
<p>If code in your program throws an exception and no catch clause catches it, the program will print a stack trace and exit. Because of Nodeâ€™s asynchronous nature, exceptions that occur in callbacks or event handlers must be handled locally or not handled at all, which means that handling exceptions that occur in the asynchronous parts of your program can be a difficult problem. If you donâ€™t want these exceptions to cause your program to completely crash, register a global handler function that will be invoked instead of crashing:</p>
<p>process.setUncaughtExceptionCaptureCallback(e &#x3D;&gt; {<br>    console.error(â€œUncaught exception:â€, e);<br>});<br>A similar situation arises if a Promise created by your program is rejected and there is no .catch() invocation to handle it. As of Node 13, this is not a fatal error that causes your program to exit, but it does print a verbose error message to the console. In some future version of Node, unhandled Promise rejections are expected to become fatal errors. If you do not want unhandled rejections, to print error messages or terminate your program, register a global handler function:</p>
<p>process.on(â€œunhandledRejectionâ€, (reason, promise) &#x3D;&gt; {<br>    &#x2F;&#x2F; reason is whatever value would have been passed to a .catch() function<br>    &#x2F;&#x2F; promise is the Promise object that rejected<br>});</p>
<h3 id="16-1-4-Node-Modules"><a href="#16-1-4-Node-Modules" class="headerlink" title="16.1.4 Node Modules"></a>16.1.4 Node Modules</h3><p>Chapter 10 documented JavaScript module systems, covering both Node modules and ES6 modules. Because Node was created before JavaScript had a module system, Node had to create its own. Nodeâ€™s module system uses the require() function to import values into a module and the exports object or the module.exports property to export values from a module. These are a fundamental part of the Node programming model, and they are covered in detail in Â§10.2.</p>
<p>Node 13 adds support for standard ES6 modules as well as require-based modules (which Node calls â€œCommonJS modulesâ€). The two module systems are not fully compatible, so this is somewhat tricky to do. Node needs to knowâ€”before it loads a moduleâ€”whether that module will be using require() and module.exports or if it will be using import and export. When Node loads a file of JavaScript code as a CommonJS module, it automatically defines the require() function along with identifiers exports and module, and it does not enable the import and export keywords. On the other hand, when Node loads a file of code as an ES6 module, it must enable the import and export declarations, and it must not define extra identifiers like require, module, and exports.</p>
<p>The simplest way to tell Node what kind of module it is loading is to encode this information in the file extension. If you save your JavaScript code in a file that ends with .mjs, then Node will always load it as an ES6 module, will expect it to use import and export, and will not provide a require() function. And if you save your code in a file that ends with .cjs, then Node will always treat it as a CommonJS module, will provide a require() function, and will throw a SyntaxError if you use import or export declarations.</p>
<p>For files that do not have an explicit .mjs or .cjs extension, Node looks for a file named package.json in the same directory as the file and then in each of the containing directories. Once the nearest package.json file is found, Node checks for a top-level type property in the JSON object. If the value of the type property is â€œmoduleâ€, then Node loads the file as an ES6 module. If the value of that property is â€œcommonjsâ€, then Node loads the file as a CommonJS module. Note that you do not need to have a package.json file to run Node programs: when no such file is found (or when the file is found but it does not have a type property), Node defaults to using CommonJS modules. This package.json trick only becomes necessary if you want to use ES6 modules with Node and do not want to use the .mjs file extension.</p>
<p>Because there is an enormous amount of existing Node code written using CommonJS module format, Node allows ES6 modules to load CommonJS modules using the import keyword. The reverse is not true, however: a CommonJS module cannot use require() to load an ES6 module.</p>
<h3 id="16-1-5-The-Node-Package-Manager"><a href="#16-1-5-The-Node-Package-Manager" class="headerlink" title="16.1.5 The Node Package Manager"></a>16.1.5 The Node Package Manager</h3><p>When you install Node, you typically get a program named npm as well. This is the Node Package Manager, and it helps you download and manage libraries that your program depends on. npm keeps track of those dependencies (as well as other information about your program) in a file named package.json in the root directory of your project. This package.json file created by npm is where you would add â€œtypeâ€:â€moduleâ€ if you wanted to use ES6 modules for your project.</p>
<p>This chapter does not cover npm in any detail (but see Â§17.4 for a little more depth). Iâ€™m mentioning it here because unless you write programs that do not use any external libraries, you will almost certainly be using npm or a tool like it. Suppose, for example, that you are going to be developing a web server and plan to use the Express framework (<a target="_blank" rel="noopener" href="https://expressjs.com/">https://expressjs.com</a>) to simplify the task. To get started, you might create a directory for your project, and then, in that directory type npm init. npm will ask you for your project name, version number, etc., and will then create an initial package.json file based on your responses.</p>
<p>Now to start using Express, youâ€™d type npm install express. This tells npm to download the Express library along with all of its dependencies and install all the packages in a local node_modules&#x2F; directory:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">npm WARN my-server@1.0.0 No description</span><br><span class="line">npm WARN my-server@1.0.0 No repository field.</span><br><span class="line"></span><br><span class="line">+ express@4.17.1</span><br><span class="line">added 50 packages from 37 contributors and audited 126 packages <span class="keyword">in</span> 3.058s</span><br><span class="line">found 0 vulnerabilities</span><br></pre></td></tr></table></figure>
<p>When you install a package with npm, npm records this dependencyâ€”that your project depends on Expressâ€”in the package.json file. With this dependency recorded in package.json, you could give another programmer a copy of your code and your package.json, and they could simply type npm install to automatically download and install all of the libraries that your program needs in order to run.</p>
<h2 id="16-2-Node-Is-Asynchronous-by-Default"><a href="#16-2-Node-Is-Asynchronous-by-Default" class="headerlink" title="16.2 Node Is Asynchronous by Default"></a>16.2 Node Is Asynchronous by Default</h2><p>JavaScript is a general-purpose programming language, so it is perfectly possible to write CPU-intensive programs that multiply large matrices or perform complicated statistical analyses. But Node was designed and optimized for programsâ€”like network serversâ€”that are I&#x2F;O intensive. And in particular, Node was designed to make it possible to easily implement highly concurrent servers that can handle many requests at the same time.</p>
<p>Unlike many programming languages, however, Node does not achieve concurrency with threads. Multithreaded programming is notoriously hard to do correctly, and difficult to debug. Also, threads are a relatively heavyweight abstraction and if you want to write a server that can handle hundreds of concurrent requests, using hundreds of threads may require a prohibitive amount of memory. So Node adopts the single-threaded JavaScript programming model that the web uses, and this turns out to be a vast simplification that makes the creation of network servers a routine skill rather than an arcane one.</p>
<p>TRUE PARALLELISM WITH NODE<br>Node programs can run multiple operating system processes, and Node 10 and later support Worker objects (Â§16.11), which are a kind of thread borrowed from web browsers. If you use multiple processes or create one or more Worker threads and run your program on a system with more than one CPU, then your program will no longer be single-threaded and your program will truly be executing multiple streams of code in parallel. These techniques can be valuable for CPU-intensive operations but are not commonly used for I&#x2F;O-intensive programs like servers.</p>
<p>It is worth noting, however, that Nodeâ€™s processes and Workers avoid the typical complexity of multithreaded programming because interprocess and inter-Worker communication is via message passing and they cannot easily share memory with each other.</p>
<p>Node achieves high levels of concurrency while maintaining a single-threaded programming model by making its API asynchronous and nonblocking by default. Node takes its nonblocking approach very seriously and to an extreme that may surprise you. You probably expect functions that read from and write to the network to be asynchronous, but Node goes further and defines nonblocking asynchronous functions for reading and writing files from the local filesystem. This makes sense, when you think about it: the Node API was designed in the days when spinning hard drives were still the norm and there really were milliseconds of blocking â€œseek timeâ€ while waiting for the disc to spin around before a file operation could begin. And in modern datacenters, the â€œlocalâ€ filesystem may actually be across the network somewhere with network latencies on top of drive latencies. But even if reading a file asynchronously seems normal to you, Node takes it still further: the default functions for initiating a network connection or looking up a file modification time, for example, are also nonblocking.</p>
<p>Some functions in Nodeâ€™s API are synchronous but nonblocking: they run to completion and return without ever needing to block. But most of the interesting functions perform some kind of input or output, and these are asynchronous functions so they can avoid even the tiniest amount of blocking. Node was created before JavaScript had a Promise class, so asynchronous Node APIs are callback-based. (If you have not yet read or have already forgotten Chapter 13, this would be a good time to skip back to that chapter.) Generally, the last argument you pass to an asynchronous Node function is a callback. Node uses error-first callbacks, which are typically invoked with two arguments. The first argument to an error-first callback is normally null in the case where no error occurred, and the second argument is whatever data or response was produced by the original asynchronous function you called. The reason for putting the error argument first is to make it impossible for you to omit it, and you should always check for a non-null value in this argument. If it is an Error object, or even an integer error code or string error message, then something went wrong. In this case, the second argument to your callback function is likely to be null.</p>
<p>The following code demonstrates how to use the nonblocking readFile() function to read a configuration file, parse it as JSON, and then pass the parsed configuration object to another callback:</p>
<p>const fs &#x3D; require(â€œfsâ€);  &#x2F;&#x2F; Require the filesystem module</p>
<p>&#x2F;&#x2F; Read a config file, parse its contents as JSON, and pass the<br>&#x2F;&#x2F; resulting value to the callback. If anything goes wrong,<br>&#x2F;&#x2F; print an error message to stderr and invoke the callback with null<br>function readConfigFile(path, callback) {<br>    fs.readFile(path, â€œutf8â€, (err, text) &#x3D;&gt; {<br>        if (err) {    &#x2F;&#x2F; Something went wrong reading the file<br>            console.error(err);<br>            callback(null);<br>            return;<br>        }<br>        let data &#x3D; null;<br>        try {<br>            data &#x3D; JSON.parse(text);<br>        } catch(e) {  &#x2F;&#x2F; Something went wrong parsing the file contents<br>            console.error(e);<br>        }<br>        callback(data);<br>    });<br>}<br>Node predates standardized promises, but because it is fairly consistent about its error-first callbacks, it is easy to create Promise-based variants of its callback-based APIs using the util.promisify() wrapper. Hereâ€™s how we could rewrite the readConfigFile() function to return a Promise:</p>
<p>const util &#x3D; require(â€œutilâ€);<br>const fs &#x3D; require(â€œfsâ€);  &#x2F;&#x2F; Require the filesystem module<br>const pfs &#x3D; {              &#x2F;&#x2F; Promise-based variants of some fs functions<br>    readFile: util.promisify(fs.readFile)<br>};</p>
<p>function readConfigFile(path) {<br>    return pfs.readFile(path, â€œutf-8â€).then(text &#x3D;&gt; {<br>        return JSON.parse(text);<br>    });<br>}<br>We can also simpify the preceding Promise-based function using async and await (again, if you have not yet read through Chapter 13, this would be a good time to do so):</p>
<p>async function readConfigFile(path) {<br>    let text &#x3D; await pfs.readFile(path, â€œutf-8â€);<br>    return JSON.parse(text);<br>}<br>The util.promisify() wrapper can produce a Promise-based version of many Node functions. In Node 10 and later, the fs.promises object has a number of predefined Promise-based functions for working with the filesystem. Weâ€™ll discuss them later in this chapter, but note that in the preceding code, we could replace pfs.readFile() with fs.promises.readFile().</p>
<p>We had said that Nodeâ€™s programming model is async-by-default. But for programmer convenience, Node does define blocking, synchronous variants of many of its functions, especially in the filesystem module. These functions typically have names that are clearly labeled with Sync at the end.</p>
<p>When a server is first starting up and is reading its configuration files, it is not handling network requests yet, and little or no concurrency is actually possible. So in this situation, there is really no need to avoid blocking, and we can safely use blocking functions like fs.readFileSync(). We can drop the async and await from this code and write a purely synchronous version of our readConfigFile() function. Instead of invoking a callback or returning a Promise, this function simply returns the parsed JSON value or throws an exception:</p>
<p>const fs &#x3D; require(â€œfsâ€);<br>function readConfigFileSync(path) {<br>    let text &#x3D; fs.readFileSync(path, â€œutf-8â€);<br>    return JSON.parse(text);<br>}<br>In addition to its error-first two-argument callbacks, Node also has a number of APIs that use event-based asynchrony, typically for handling streaming data. Weâ€™ll cover Node events in more detail later.</p>
<p>Now that weâ€™ve discussed Nodeâ€™s aggressively nonblocking API, letâ€™s turn back to the topic of concurrency. Nodeâ€™s built-in nonblocking functions work using the operating systemâ€™s version of callbacks and event handlers. When you call one of these functions, Node takes action to get the operation started, then registers some kind of event handler with the operating system so that it will be notified when the operation is complete. The callback you passed to the Node function gets stored internally so that Node can invoke your callback when the operating system sends the appropriate event to Node.</p>
<p>This kind of concurrency is often called event-based concurrency. At its core, Node has a single thread that runs an â€œevent loop.â€ When a Node program starts, it runs whatever code youâ€™ve told it to run. This code presumably calls at least one nonblocking function causing a callback or event handler to be registered with the operating system. (If not, then youâ€™ve written a synchronous Node program, and Node simply exits when it reaches the end.) When Node reaches the end of your program, it blocks until an event happens, at which time the OS starts it running again. Node maps the OS event to the JavaScript callback you registered and then invokes that function. Your callback function may invoke more nonblocking Node functions, causing more OS event handlers to be registered. Once your callback function is done running, Node goes back to sleep again and the cycle repeats.</p>
<p>For web servers and other I&#x2F;O-intensive applications that spend most of their time waiting for input and output, this style of event-based concurrency is efficient and effective. A web server can concurrently handle requests from 50 different clients without needing 50 different threads as long as it uses nonblocking APIs and there is some kind of internal mapping from network sockets to JavaScript functions to invoke when activity occurs on those sockets.</p>
<h2 id="16-3-Buffers"><a href="#16-3-Buffers" class="headerlink" title="16.3 Buffers"></a>16.3 Buffers</h2><p>One of the datatypes youâ€™re likely to use frequently in Nodeâ€”especially when reading data from files or from the networkâ€”is the Buffer class. A Buffer is a lot like a string, except that it is a sequence of bytes instead of a sequence of characters. Node was created before core JavaScript supported typed arrays (see Â§11.2) and there was no Uint8Array to represent an array of unsigned bytes. Node defined the Buffer class to fill that need. Now that Uint8Array is part of the JavaScript language, Nodeâ€™s Buffer class is a subclass of Uint8Array.</p>
<p>What distinguishes Buffer from its Uint8Array superclass is that it is designed to interoperate with JavaScript strings: the bytes in a buffer can be initialized from character strings or converted to character strings. A character encoding maps each character in some set of characters to an integer. Given a string of text and a character encoding, we can encode the characters in the string into a sequence of bytes. And given a (properly encoded) sequence of bytes and a character encoding, we can decode those bytes into a sequence of characters. Nodeâ€™s Buffer class has methods that perform both encoding and decoding, and you can recognize these methods because they expect an encoding argument that specifies the encoding to be used.</p>
<p>Encodings in Node are specified by name, as strings. The supported encodings are:</p>
<p>â€œutf8â€<br>This is the default when no encoding is specified, and is the Unicode encoding you are most likely to use.</p>
<p>â€œutf16leâ€<br>Two-byte Unicode characters, with little-endian ordering. Codepoints above \uffff are encoded as a pair of two-byte sequences. Encoding â€œucs2â€ is an alias.</p>
<p>â€œlatin1â€<br>The one-byte-per-character ISO-8859-1 encoding that defines a character set suitable for many Western European languages. Because there is a one-to-one mapping between bytes and latin-1 characters, this encoding is also known as â€œbinaryâ€.</p>
<p>â€œasciiâ€<br>The 7-bit English-only ASCII encoding, a strict subset of the â€œutf8â€ encoding.</p>
<p>â€œhexâ€<br>This encoding converts each byte to a pair of ASCII hexadecimal digits.</p>
<p>â€œbase64â€<br>This encoding converts each sequence of three bytes into a sequence of four ascii characters.</p>
<p>Here is some example code that demonstrates how to work with Buffers and how to convert to and from strings:</p>
<p>let b &#x3D; Buffer.from([0x41, 0x42, 0x43]);          &#x2F;&#x2F; &lt;Buffer 41 42 43&gt;<br>b.toString()                                      &#x2F;&#x2F; &#x3D;&gt; â€œABCâ€; default â€œutf8â€<br>b.toString(â€œhexâ€)                                 &#x2F;&#x2F; &#x3D;&gt; â€œ414243â€</p>
<p>let computer &#x3D; Buffer.from(â€œIBM3111â€, â€œasciiâ€);   &#x2F;&#x2F; Convert string to Buffer<br>for(let i &#x3D; 0; i &lt; computer.length; i++) {        &#x2F;&#x2F; Use Buffer as byte array<br>    computer[i]â€“;                                &#x2F;&#x2F; Buffers are mutable<br>}<br>computer.toString(â€œasciiâ€)                        &#x2F;&#x2F; &#x3D;&gt; â€œHAL2000â€<br>computer.subarray(0,3).map(x&#x3D;&gt;x+1).toString()     &#x2F;&#x2F; &#x3D;&gt; â€œIBMâ€</p>
<p>&#x2F;&#x2F; Create new â€œemptyâ€ buffers with Buffer.alloc()<br>let zeros &#x3D; Buffer.alloc(1024);                   &#x2F;&#x2F; 1024 zeros<br>let ones &#x3D; Buffer.alloc(128, 1);                  &#x2F;&#x2F; 128 ones<br>let dead &#x3D; Buffer.alloc(1024, â€œDEADBEEFâ€, â€œhexâ€); &#x2F;&#x2F; Repeating pattern of bytes</p>
<p>&#x2F;&#x2F; Buffers have methods for reading and writing multi-byte values<br>&#x2F;&#x2F; from and to a buffer at any specified offset.<br>dead.readUInt32BE(0)       &#x2F;&#x2F; &#x3D;&gt; 0xDEADBEEF<br>dead.readUInt32BE(1)       &#x2F;&#x2F; &#x3D;&gt; 0xADBEEFDE<br>dead.readBigUInt64BE(6)    &#x2F;&#x2F; &#x3D;&gt; 0xBEEFDEADBEEFDEADn<br>dead.readUInt32LE(1020)    &#x2F;&#x2F; &#x3D;&gt; 0xEFBEADDE<br>If you write a Node program that actually manipulates binary data, you may find yourself using the Buffer class extensively. On the other hand, if you are just working with text that is read from or written to a file or the network, then you may only encounter Buffer as an intermediate representation of your data. A number of Node APIs can take input or return output as either strings or Buffer objects. Typically, if you pass a string, or expect a string to be returned, from one of these APIs, youâ€™ll need to specify the name of the text encoding you want to use. And if you do this, then you may not need to use a Buffer object at all.</p>
<h2 id="16-4-Events-and-EventEmitter"><a href="#16-4-Events-and-EventEmitter" class="headerlink" title="16.4 Events and EventEmitter"></a>16.4 Events and EventEmitter</h2><p>As described, all of Nodeâ€™s APIs are asynchronous by default. For many of them, this asynchrony takes the form of two-argument error-first callbacks that are invoked when the requested operation is complete. But some of the more complicated APIs are event-based instead. This is typically the case when the API is designed around an object rather than a function, or when a callback function needs to be invoked multiple times, or when there are multiple types of callback functions that may be required. Consider the net.Server class, for example: an object of this type is a server socket that is used to accept incoming connections from clients. It emits a â€œlisteningâ€ event when it first starts listening for connections, a â€œconnectionâ€ event every time a client connects, and a â€œcloseâ€ event when it has been closed and is no longer listening.</p>
<p>In Node, objects that emit events are instances of EventEmitter or a subclass of EventEmitter:</p>
<p>const EventEmitter &#x3D; require(â€œeventsâ€); &#x2F;&#x2F; Module name does not match class name<br>const net &#x3D; require(â€œnetâ€);<br>let server &#x3D; new net.Server();          &#x2F;&#x2F; create a Server object<br>server instanceof EventEmitter          &#x2F;&#x2F; &#x3D;&gt; true: Servers are EventEmitters<br>The main feature of EventEmitters is that they allow you to register event handler functions with the on() method. EventEmitters can emit multiple types of events, and event types are identified by name. To register an event handler, call the on() method, passing the name of the event type and the function that should be invoked when an event of that type occurs. EventEmitters can invoke handler functions with any number of arguments, and you need to read the documentation for a specific kind of event from a specific EventEmitter to know what arguments you should expect to be passed:</p>
<p>const net &#x3D; require(â€œnetâ€);<br>let server &#x3D; new net.Server();          &#x2F;&#x2F; create a Server object<br>server.on(â€œconnectionâ€, socket &#x3D;&gt; {     &#x2F;&#x2F; Listen for â€œconnectionâ€ events<br>    &#x2F;&#x2F; Server â€œconnectionâ€ events are passed a socket object<br>    &#x2F;&#x2F; for the client that just connected. Here we send some data<br>    &#x2F;&#x2F; to the client and disconnect.<br>    socket.end(â€œHello Worldâ€, â€œutf8â€);<br>});<br>If you prefer more explicit method names for registering event listeners, you can also use addListener(). And you can remove a previously registered event listener with off() or removeListener(). As a special case, you can register an event listener that will be automatically removed after it is triggered for the first time by calling once() instead of on().</p>
<p>When an event of a particular type occurs for a particular EventEmitter object, Node invokes all of the handler functions that are currently registered on that EventEmitter for events of that type. They are invoked in order from the first registered to the last registered. If there is more than one handler function, they are invoked sequentially on a single thread: there is no parallelism in Node, remember. And, importantly, event handling functions are invoked synchronously, not asynchronously. What this means is that the emit() method does not queue up event handlers to be invoked at some later time. emit() invokes all the registered handlers, one after the other, and does not return until the last event handler has returned.</p>
<p>What this means, in effect, is that when one of the built-in Node APIs emits an event, that API is basically blocking on your event handlers. If you write an event handler that calls a blocking function like fs.readFileSync(), no further event handling will happen until your synchronous file read is complete. If your program is oneâ€”like a network serverâ€”that needs to be responsive, then it is important that you keep your event handler functions nonblocking and fast. If you need to do a lot of computation when an event occurs, it is often best to use the handler to schedule that computation asynchronously using setTimeout() (see Â§11.10). Node also defines setImmediate(), which schedules a function to be invoked immediately after all pending callbacks and events have been handled.</p>
<p>The EventEmitter class also defines an emit() method that causes the registered event handler functions to be invoked. This is useful if you are defining your own event-based API, but is not commonly used when youâ€™re just programming with existing APIs. emit() must be invoked with the name of the event type as its first argument. Any additional arguments that are passed to emit() become arguments to the registered event handler functions. The handler functions are also invoked with the this value set to the EventEmitter object itself, which is often convenient. (Remember, though, that arrow functions always use the this value of the context in which they are defined, and they cannot be invoked with any other this value. Nevertheless, arrow functions are often the most convenient way to write event handlers.)</p>
<p>Any value returned by an event handler function is ignored. If an event handler function throws an exception, however, it propagates out from the emit() call and prevents the execution of any handler functions that were registered after the one that threw the exception.</p>
<p>Recall that Nodeâ€™s callback-based APIs use error-first callbacks, and it is important that you always check the first callback argument to see if an error occurred. With event-based APIs, the equivalent is â€œerrorâ€ events. Since event-based APIs are often used for networking and other forms of streaming I&#x2F;O, they are vulnerable to unpredictable asynchronous errors, and most EventEmitters define an â€œerrorâ€ event that they emit when an error occurs. Whenever you use an event-based API, you should make it a habit to register a handler for â€œerrorâ€ events. â€œErrorâ€ events get special treatment by the EventEmitter class. If emit() is called to emit an â€œerrorâ€ event, and if there are no handlers registered for that event type, then an exception will be thrown. Since this occurs asynchronously, there is no way for you to handle the exception in a catch block, so this kind of error typically causes your program to exit.</p>
<h2 id="16-5-Streams"><a href="#16-5-Streams" class="headerlink" title="16.5 Streams"></a>16.5 Streams</h2><p>When implementing an algorithm to process data, it is almost always easiest to read all the data into memory, do the processing, and then write the data out. For example, you could write a Node function to copy a file like this.1</p>
<p>const fs &#x3D; require(â€œfsâ€);</p>
<p>&#x2F;&#x2F; An asynchronous but nonstreaming (and therefore inefficient) function.<br>function copyFile(sourceFilename, destinationFilename, callback) {<br>    fs.readFile(sourceFilename, (err, buffer) &#x3D;&gt; {<br>        if (err) {<br>            callback(err);<br>        } else {<br>            fs.writeFile(destinationFilename, buffer, callback);<br>        }<br>    });<br>}<br>This copyFile() function uses asynchronous functions and callbacks, so it does not block and is suitable for use in concurrent programs like servers. But notice that it must allocate enough memory to hold the entire contents of the file in memory at once. This may be fine in some use cases, but it starts to fail if the files to be copied are very large, or if your program is highly concurrent and there may be many files being copied at the same time. Another shortcoming of this copyFile() implementation is that it cannot start writing the new file until it has finished reading the old file.</p>
<p>The solution to these problems is to use streaming algorithms where data â€œflowsâ€ into your program, is processed, and then flows out of your program. The idea is that your algorithm processes the data in small chunks and the full dataset is never held in memory at once. When streaming solutions are possible, they are more memory efficient and can also be faster. Nodeâ€™s networking APIs are stream-based and Nodeâ€™s filesystem module defines streaming APIs for reading and writing files, so you are likely to use a streaming API in many of the Node programs that you write. Weâ€™ll see a streaming version of the copyFile() function in â€œFlowing modeâ€.</p>
<p>Node supports four basic stream types:</p>
<p>Readable<br>Readable streams are sources of data. The stream returned by fs.createReadStream(), for example, is a stream from which the content of a specified file can be read. process.stdin is another Readable stream that returns data from standard input.</p>
<p>Writable<br>Writable streams are sinks or destinations for data. The return value of fs.createWriteStream(), for example, is a Writable stream: it allows data to be written to it in chunks, and outputs all of that data to a specified file.</p>
<p>Duplex<br>Duplex streams combine a Readable stream and a Writable stream into one object. The Socket objects returned by net.connect() and other Node networking APIs, for example, are Duplex streams. If you write to a socket, your data is sent across the network to whatever computer the socket is connected to. And if you read from a socket, you access the data written by that other computer.</p>
<p>Transform<br>Transform streams are also readable and writable, but they differ from Duplex streams in an important way: data written to a Transform stream becomes readableâ€”usually in some transformed formâ€”from the same stream. The zlib.createGzip() function, for example, returns a Transform stream that compresses (with the gzip algorithm) the data written to it. In a similar way, the crypto.createCipheriv() function returns a Transform stream that encrypts or decrypts data that is written to it.</p>
<p>By default, streams read and write buffers. If you call the setEncoding() method of a Readable stream, it will return decoded strings to you instead of Buffer objects. And if you write a string to a Writable buffer, it will be automatically encoded using the bufferâ€™s default encoding or whatever encoding you specify. Nodeâ€™s stream API also supports an â€œobject modeâ€ where streams read and write objects more complex than buffers and strings. None of Nodeâ€™s core APIs use this object mode, but you may encounter it in other libraries.</p>
<p>Readable streams have to read their data from somewhere, and Writable streams have to write their data to somewhere, so every stream has two ends: an input and an output or a source and a destination. The tricky thing about stream-based APIs is that the two ends of the stream will almost always flow at different speeds. Perhaps the code that reads from a stream wants to read and process data more quickly than the data is actually being written into the stream. Or the reverse: perhaps data is written to a stream more quickly than it can be read and pulled out of the stream on the other end. Stream implementations almost always include an internal buffer to hold data that has been written but not yet read. Buffering helps to ensure that there is data available to read when itâ€™s requested, and that there is space to hold data when it is written. But neither of these things can ever be guaranteed, and it is the nature of stream-based programming that readers will sometimes have to wait for data to be written (because the stream buffer is empty), and writers will sometimes have to wait for data to be read (because the stream buffer is full).</p>
<p>In programming environments that use thread-based concurrency, stream APIs typically have blocking calls: a call to read data does not return until data arrives in the stream and a call to write data blocks until there is enough room in the streamâ€™s internal buffer to accommodate the new data. With an event-based concurrency model, however, blocking calls do not make sense, and Nodeâ€™s stream APIs are event- and callback-based. Unlike other Node APIs, there are not â€œSyncâ€ versions of the methods that will be described later in this chapter.</p>
<p>The need to coordinate stream readability (buffer not empty) and writability (buffer not full) via events makes Nodeâ€™s stream APIs somewhat complicated. This is compounded by the fact that these APIs have evolved and changed over the years: for Readable streams, there are two completely distinct APIs that you can use. Despite the complexity, it is worth understanding and mastering Nodeâ€™s streaming APIs because they enable high-throughput I&#x2F;O in your programs.</p>
<p>The subsections that follow demonstrate how to read and write from Nodeâ€™s stream classes.</p>
<h3 id="16-5-1-Pipes"><a href="#16-5-1-Pipes" class="headerlink" title="16.5.1 Pipes"></a>16.5.1 Pipes</h3><p>Sometimes, you need to read data from a stream simply to turn around and write that same data to another stream. Imagine, for example, that you are writing a simple HTTP server that serves a directory of static files. In this case, you will need to read data from a file input stream and write it out to a network socket. But instead of writing your own code to handle the reading and writing, you can instead simply connect the two sockets together as a â€œpipeâ€ and let Node handle the complexities for you. Simply pass the Writable stream to the pipe() method of the Readable stream:</p>
<p>const fs &#x3D; require(â€œfsâ€);</p>
<p>function pipeFileToSocket(filename, socket) {<br>    fs.createReadStream(filename).pipe(socket);<br>}<br>The following utility function pipes one stream to another and invokes a callback when done or when an error occurs:</p>
<p>function pipe(readable, writable, callback) {<br>    &#x2F;&#x2F; First, set up error handling<br>    function handleError(err) {<br>        readable.close();<br>        writable.close();<br>        callback(err);<br>    }</p>
<pre><code>// Next define the pipe and handle the normal termination case
readable
    .on(&quot;error&quot;, handleError)
    .pipe(writable)
    .on(&quot;error&quot;, handleError)
    .on(&quot;finish&quot;, callback);
</code></pre>
<p>}<br>Transform streams are particularly useful with pipes, and create pipelines that involve more than two streams. Hereâ€™s an example function that compresses a file:</p>
<p>const fs &#x3D; require(â€œfsâ€);<br>const zlib &#x3D; require(â€œzlibâ€);</p>
<p>function gzip(filename, callback) {<br>    &#x2F;&#x2F; Create the streams<br>    let source &#x3D; fs.createReadStream(filename);<br>    let destination &#x3D; fs.createWriteStream(filename + â€œ.gzâ€);<br>    let gzipper &#x3D; zlib.createGzip();</p>
<pre><code>// Set up the pipeline
source
    .on(&quot;error&quot;, callback)   // call callback on read error
    .pipe(gzipper)
    .pipe(destination)
    .on(&quot;error&quot;, callback)   // call callback on write error
    .on(&quot;finish&quot;, callback); // call callback when writing is complete
</code></pre>
<p>}<br>Using the pipe() method to copy data from a Readable stream to a Writable stream is easy, but in practice, you often need to process the data somehow as it streams through your program. One way to do this is to implement your own Transform stream to do that processing, and this approach allows you to avoid manually reading and writing the streams. Here, for example, is a function that works like the Unix grep utility: it reads lines of text from an input stream, but writes only the lines that match a specified regular expression:</p>
<p>const stream &#x3D; require(â€œstreamâ€);</p>
<p>class GrepStream extends stream.Transform {<br>    constructor(pattern) {<br>        super({decodeStrings: false});&#x2F;&#x2F; Donâ€™t convert strings back to buffers<br>        this.pattern &#x3D; pattern;       &#x2F;&#x2F; The regular expression we want to match<br>        this.incompleteLine &#x3D; â€œâ€;     &#x2F;&#x2F; Any remnant of the last chunk of data<br>    }</p>
<pre><code>// This method is invoked when there is a string ready to be
// transformed. It should pass transformed data to the specified
// callback function. We expect string input so this stream should
// only be connected to readable streams that have had
// setEncoding() called on them.
_transform(chunk, encoding, callback) &#123;
    if (typeof chunk !== &quot;string&quot;) &#123;
        callback(new Error(&quot;Expected a string but got a buffer&quot;));
        return;
    &#125;
    // Add the chunk to any previously incomplete line and break
    // everything into lines
    let lines = (this.incompleteLine + chunk).split(&quot;\n&quot;);

    // The last element of the array is the new incomplete line
    this.incompleteLine = lines.pop();

    // Find all matching lines
    let output = lines                     // Start with all complete lines,
        .filter(l =&gt; this.pattern.test(l)) // filter them for matches,
        .join(&quot;\n&quot;);                       // and join them back up.

    // If anything matched, add a final newline
    if (output) &#123;
        output += &quot;\n&quot;;
    &#125;

    // Always call the callback even if there is no output
    callback(null, output);
&#125;

// This is called right before the stream is closed.
// It is our chance to write out any last data.
_flush(callback) &#123;
    // If we still have an incomplete line, and it matches
    // pass it to the callback
    if (this.pattern.test(this.incompleteLine)) &#123;
        callback(null, this.incompleteLine + &quot;\n&quot;);
    &#125;
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Now we can write a program like â€˜grepâ€™ with this class.<br>let pattern &#x3D; new RegExp(process.argv[2]); &#x2F;&#x2F; Get a RegExp from command line.<br>process.stdin                              &#x2F;&#x2F; Start with standard input,<br>    .setEncoding(â€œutf8â€)                   &#x2F;&#x2F; read it as Unicode strings,<br>    .pipe(new GrepStream(pattern))         &#x2F;&#x2F; pipe it to our GrepStream,<br>    .pipe(process.stdout)                  &#x2F;&#x2F; and pipe that to standard out.<br>    .on(â€œerrorâ€, () &#x3D;&gt; process.exit());    &#x2F;&#x2F; Exit gracefully if stdout closes.</p>
<h3 id="16-5-2-Asynchronous-Iteration"><a href="#16-5-2-Asynchronous-Iteration" class="headerlink" title="16.5.2 Asynchronous Iteration"></a>16.5.2 Asynchronous Iteration</h3><p>In Node 12 and later, Readable streams are asynchronous iterators, which means that within an async function you can use a for&#x2F;await loop to read string or Buffer chunks from a stream using code that is structured like synchronous code would be. (See Â§13.4 for more on asynchronous iterators and for&#x2F;await loops.)</p>
<p>Using an asynchronous iterator is almost as easy as using the pipe() method, and is probably easier when you need to process each chunk you read in some way. Hereâ€™s how we could rewrite the grep program in the previous section using an async function and a for&#x2F;await loop:</p>
<p>&#x2F;&#x2F; Read lines of text from the source stream, and write any lines<br>&#x2F;&#x2F; that match the specified pattern to the destination stream.<br>async function grep(source, destination, pattern, encoding&#x3D;â€utf8â€) {<br>    &#x2F;&#x2F; Set up the source stream for reading strings, not Buffers<br>    source.setEncoding(encoding);</p>
<pre><code>// Set an error handler on the destination stream in case standard
// output closes unexpectedly (when piping output to `head`, e.g.)
destination.on(&quot;error&quot;, err =&gt; process.exit());

// The chunks we read are unlikely to end with a newline, so each will
// probably have a partial line at the end. Track that here
let incompleteLine = &quot;&quot;;

// Use a for/await loop to asynchronously read chunks from the input stream
for await (let chunk of source) &#123;
    // Split the end of the last chunk plus this one into lines
    let lines = (incompleteLine + chunk).split(&quot;\n&quot;);
    // The last line is incomplete
    incompleteLine = lines.pop();
    // Now loop through the lines and write any matches to the destination
    for(let line of lines) &#123;
        if (pattern.test(line)) &#123;
            destination.write(line + &quot;\n&quot;, encoding);
        &#125;
    &#125;
&#125;
// Finally, check for a match on any trailing text.
if (pattern.test(incompleteLine)) &#123;
    destination.write(incompleteLine + &quot;\n&quot;, encoding);
&#125;
</code></pre>
<p>}</p>
<p>let pattern &#x3D; new RegExp(process.argv[2]);   &#x2F;&#x2F; Get a RegExp from command line.<br>grep(process.stdin, process.stdout, pattern) &#x2F;&#x2F; Call the async grep() function.<br>    .catch(err &#x3D;&gt; {                          &#x2F;&#x2F; Handle asynchronous exceptions.<br>        console.error(err);<br>        process.exit();<br>    });</p>
<h3 id="16-5-3-Writing-to-Streams-and-Handling-Backpressure"><a href="#16-5-3-Writing-to-Streams-and-Handling-Backpressure" class="headerlink" title="16.5.3 Writing to Streams and Handling Backpressure"></a>16.5.3 Writing to Streams and Handling Backpressure</h3><p>The async grep() function in the preceding code example demonstrated how to use a Readable stream as an asynchronous iterator, but it also demonstrated that you can write data to a Writable stream simply by passing it to the write() method. The write() method takes a buffer or string as the first argument. (Object streams expect other kinds of objects, but are beyond the scope of this chapter.) If you pass a buffer, the bytes of that buffer will be written directly. If you pass a string, it will be encoded to a buffer of bytes before being written. Writable streams have a default encoding that is used when you pass a string as the only argument to write(). The default encoding is typically â€œutf8,â€ but you can set it explicitly by calling setDefaultEncoding() on the Writable stream. Alternatively, when you pass a string as the first argument to write() you can pass an encoding name as the second argument.</p>
<p>write() optionally takes a callback function as its third argument. This will be invoked when the data has actually been written and is no longer in the Writable streamâ€™s internal buffer. (This callback may also be invoked if an error occurs, but this is not guaranteed. You should register an â€œerrorâ€ event handler on the Writable stream to detect errors.)</p>
<p>The write() method has a very important return value. When you call write() on a stream, it will always accept and buffer the chunk of data you have passed. It then returns true if the internal buffer is not yet full. Or, if the buffer is now full or overfull, it returns false. This return value is advisory, and you can ignore itâ€”Writable streams will enlarge their internal buffer as much as needed if you keep calling write(). But remember that the reason to use a streaming API in the first place is to avoid the cost of keeping lots of data in memory at once.</p>
<p>A return value of false from the write() method is a form of backpressure: a message from the stream that you have written data more quickly than it can be handled. The proper response to this kind of backpressure is to stop calling write() until the stream emits a â€œdrainâ€ event, signaling that there is once again room in the buffer. Here, for example, is a function that writes to a stream, and then invokes a callback when it is OK to write more data to the stream:</p>
<p>function write(stream, chunk, callback) {<br>    &#x2F;&#x2F; Write the specified chunk to the specified stream<br>    let hasMoreRoom &#x3D; stream.write(chunk);</p>
<pre><code>// Check the return value of the write() method:
if (hasMoreRoom) &#123;                  // If it returned true, then
    setImmediate(callback);         // invoke callback asynchronously.
&#125; else &#123;                            // If it returned false, then
    stream.once(&quot;drain&quot;, callback); // invoke callback on drain event.
&#125;
</code></pre>
<p>}<br>The fact that it is sometimes OK to call write() multiple times in a row and sometimes you have to wait for an event between writes makes for awkward algorithms. This is one of the reasons that using the pipe() method is so appealing: when you use pipe(), Node handles backpressure for you automatically.</p>
<p>If you are using await and async in your program, and are treating Readable streams as asynchronous iterators, it is straightforward to implement a Promise-based version of the write() utility function above to properly handle backpressure. In the async grep() function we just looked at, we did not handle backpressure. The async copy() function in the following example demonstrates how it can be done correctly. Note that this function just copies chunks from a source stream to a destination stream and calling copy(source, destination) is much like calling source.pipe(destination):</p>
<p>&#x2F;&#x2F; This function writes the specified chunk to the specified stream and<br>&#x2F;&#x2F; returns a Promise that will be fulfilled when it is OK to write again.<br>&#x2F;&#x2F; Because it returns a Promise, it can be used with await.<br>function write(stream, chunk) {<br>    &#x2F;&#x2F; Write the specified chunk to the specified stream<br>    let hasMoreRoom &#x3D; stream.write(chunk);</p>
<pre><code>if (hasMoreRoom) &#123;                     // If buffer is not full, return
    return Promise.resolve(null);      // an already resolved Promise object
&#125; else &#123;
    return new Promise(resolve =&gt; &#123;    // Otherwise, return a Promise that
        stream.once(&quot;drain&quot;, resolve); // resolves on the drain event.
    &#125;);
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Copy data from the source stream to the destination stream<br>&#x2F;&#x2F; respecting backpressure from the destination stream.<br>&#x2F;&#x2F; This is much like calling source.pipe(destination).<br>async function copy(source, destination) {<br>    &#x2F;&#x2F; Set an error handler on the destination stream in case standard<br>    &#x2F;&#x2F; output closes unexpectedly (when piping output to <code>head</code>, e.g.)<br>    destination.on(â€œerrorâ€, err &#x3D;&gt; process.exit());</p>
<pre><code>// Use a for/await loop to asynchronously read chunks from the input stream
for await (let chunk of source) &#123;
    // Write the chunk and wait until there is more room in the buffer.
    await write(destination, chunk);
&#125;
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Copy standard input to standard output<br>copy(process.stdin, process.stdout);<br>Before we conclude this discussion of writing to streams, note again that failing to respond to backpressure can cause your program to use more memory than it should when the internal buffer of a Writable stream overflows and grows larger and larger. If you are writing a network server, this can be a remotely exploitable security issue. Suppose you write an HTTP server that delivers files over the network, but you didnâ€™t use pipe() and you didnâ€™t take the time to handle backpressure from the write() method. An attacker could write an HTTP client that initiates requests for large files (such as images) but never actually reads the body of the request. Since the client is not reading the data over the network, and the server isnâ€™t responding to backpressure, buffers on the server are going to overflow. With enough concurrent connections from the attacker, this can turn into a denial-of-service attack that slows your server down or even crashes it.</p>
<h3 id="16-5-4-Reading-Streams-with-Events"><a href="#16-5-4-Reading-Streams-with-Events" class="headerlink" title="16.5.4 Reading Streams with Events"></a>16.5.4 Reading Streams with Events</h3><p>Nodeâ€™s readable streams have two modes, each of which has its own API for reading. If you canâ€™t use pipes or asynchronous iteration in your program, you will need to pick one of these two event-based APIs for handling streams. It is important that you use only one or the other and do not mix the two APIs.</p>
<p>FLOWING MODE<br>In flowing mode, when readable data arrives, it is immediately emitted in the form of a â€œdataâ€ event. To read from a stream in this mode, simply register an event handler for â€œdataâ€ events, and the stream will push chunks of data (buffers or strings) to you as soon as they becomes available. Note that there is no need to call the read() method in flowing mode: you only need to handle â€œdataâ€ events. Note that newly created streams do not start off in flowing mode. Registering a â€œdataâ€ event handler switches a stream into flowing mode. Conveniently, this means that a stream does not emit â€œdataâ€ events until you register the first â€œdataâ€ event handler.</p>
<p>If you are using flowing mode to read data from a Readable stream, process it, then write it to a Writable stream, then you may need to handle backpressure from the Writable stream. If the write() method returns false to indicate that the write buffer is full, you can call pause() on the Readable stream to temporarily stop data events. Then, when you get a â€œdrainâ€ event from the Writable stream, you can call resume() on the Readable stream to start the â€œdataâ€ events flowing again.</p>
<p>A stream in flowing mode emits an â€œendâ€ event when the end of the stream is reached. This event indicates that no more â€œdataâ€ events will ever be emitted. And, as with all streams, an â€œerrorâ€ event is emitted if an error occurs.</p>
<p>At the beginning of this section on streams, we showed a nonstreaming copyFile() function and promised a better version to come. The following code shows how to implement a streaming copyFile() function that uses the flowing mode API and handles backpressure. This would have been easier to implement with a pipe() call, but it serves here as a useful demonstration of the multiple event handlers that are used to coordinate data flow from one stream to the other.</p>
<p>const fs &#x3D; require(â€œfsâ€);</p>
<p>&#x2F;&#x2F; A streaming file copy function, using â€œflowing modeâ€.<br>&#x2F;&#x2F; Copies the contents of the named source file to the named destination file.<br>&#x2F;&#x2F; On success, invokes the callback with a null argument. On error,<br>&#x2F;&#x2F; invokes the callback with an Error object.<br>function copyFile(sourceFilename, destinationFilename, callback) {<br>    let input &#x3D; fs.createReadStream(sourceFilename);<br>    let output &#x3D; fs.createWriteStream(destinationFilename);</p>
<pre><code>input.on(&quot;data&quot;, (chunk) =&gt; &#123;          // When we get new data,
    let hasRoom = output.write(chunk); // write it to the output stream.
    if (!hasRoom) &#123;                    // If the output stream is full
        input.pause();                 // then pause the input stream.
    &#125;
&#125;);
input.on(&quot;end&quot;, () =&gt; &#123;                // When we reach the end of input,
    output.end();                      // tell the output stream to end.
&#125;);
input.on(&quot;error&quot;, err =&gt; &#123;             // If we get an error on the input,
    callback(err);                     // call the callback with the error
    process.exit();                    // and quit.
&#125;);

output.on(&quot;drain&quot;, () =&gt; &#123;             // When the output is no longer full,
    input.resume();                    // resume data events on the input
&#125;);
output.on(&quot;error&quot;, err =&gt; &#123;            // If we get an error on the output,
    callback(err);                     // call the callback with the error
    process.exit();                    // and quit.
&#125;);
output.on(&quot;finish&quot;, () =&gt; &#123;            // When output is fully written
    callback(null);                    // call the callback with no error.
&#125;);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Hereâ€™s a simple command-line utility to copy files<br>let from &#x3D; process.argv[2], to &#x3D; process.argv[3];<br>console.log(<code>Copying file $&#123;from&#125; to $&#123;to&#125;...</code>);<br>copyFile(from, to, err &#x3D;&gt; {<br>    if (err) {<br>        console.error(err);<br>    } else {<br>        console.log(â€œdone.â€);<br>    }<br>});<br>PAUSED MODE<br>The other mode for Readable streams is â€œpaused mode.â€ This is the mode that streams start in. If you never register a â€œdataâ€ event handler and never call the pipe() method, then a Readable stream remains in paused mode. In paused mode, the stream does not push data to you in the form of â€œdataâ€ events. Instead, you pull data from the stream by explicitly calling its read() method. This is not a blocking call, and if there is no data available to read on the stream, it will return null. Since there is not a synchronous API to wait for data, the paused mode API is also event-based. A Readable stream in paused mode emits â€œreadableâ€ events when data becomes available to read on the stream. In response, your code should call the read() method to read that data. You must do this in a loop, calling read() repeatedly until it returns null. It is necessary to completely drain the streamâ€™s buffer like this in order to trigger a new â€œreadableâ€ event in the future. If you stop calling read() while there is still readable data, you will not get another â€œreadableâ€ event and your program is likely to hang.</p>
<p>Streams in paused mode emit â€œendâ€ and â€œerrorâ€ events just like flowing mode streams do. If you are writing a program that reads data from a Readable stream and writes it to a Writable stream, then paused mode may not be a good choice. In order to properly handle backpressure, you only want to read when the input stream is readable and the output stream is not backed up. In paused mode, that means reading and writing until read() returns null or write() returns false, and then starting reading or writing again on a readable or drain event. This is inelegant, and you may find that flowing mode (or pipes) is easier in this case.</p>
<p>The following code demonstrates how you can compute a SHA256 hash for the contents of a specified file. It uses a Readable stream in paused mode to read the contents of a file in chunks, then passes each chunk to the object that computes the hash. (Note that in Node 12 and later, it would be simpler to write this function using a for&#x2F;await loop.)</p>
<p>const fs &#x3D; require(â€œfsâ€);<br>const crypto &#x3D; require(â€œcryptoâ€);</p>
<p>&#x2F;&#x2F; Compute a sha256 hash of the contents of the named file and pass the<br>&#x2F;&#x2F; hash (as a string) to the specified error-first callback function.<br>function sha256(filename, callback) {<br>    let input &#x3D; fs.createReadStream(filename); &#x2F;&#x2F; The data stream.<br>    let hasher &#x3D; crypto.createHash(â€œsha256â€);  &#x2F;&#x2F; For computing the hash.</p>
<pre><code>input.on(&quot;readable&quot;, () =&gt; &#123;         // When there is data ready to read
    let chunk;
    while(chunk = input.read()) &#123;    // Read a chunk, and if non-null,
        hasher.update(chunk);        // pass it to the hasher,
    &#125;                                // and keep looping until not readable
&#125;);
input.on(&quot;end&quot;, () =&gt; &#123;              // At the end of the stream,
    let hash = hasher.digest(&quot;hex&quot;); // compute the hash,
    callback(null, hash);            // and pass it to the callback.
&#125;);
input.on(&quot;error&quot;, callback);         // On error, call callback
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; Hereâ€™s a simple command-line utility to compute the hash of a file<br>sha256(process.argv[2], (err, hash) &#x3D;&gt; { &#x2F;&#x2F; Pass filename from command line.<br>    if (err) {                           &#x2F;&#x2F; If we get an error<br>        console.error(err.toString());   &#x2F;&#x2F; print it as an error.<br>    } else {                             &#x2F;&#x2F; Otherwise,<br>        console.log(hash);               &#x2F;&#x2F; print the hash string.<br>    }<br>});</p>
<h2 id="16-6-Process-CPU-and-Operating-System-Details"><a href="#16-6-Process-CPU-and-Operating-System-Details" class="headerlink" title="16.6 Process, CPU, and Operating System Details"></a>16.6 Process, CPU, and Operating System Details</h2><p>The global Process object has a number of useful properties and functions that generally relate to the state of the currently running Node process. Consult the Node documentation for complete details, but here are some properties and functions you should be aware of:</p>
<p>process.argv            &#x2F;&#x2F; An array of command-line arguments.<br>process.arch            &#x2F;&#x2F; The CPU architecture: â€œx64â€, for example.<br>process.cwd()           &#x2F;&#x2F; Returns the current working directory.<br>process.chdir()         &#x2F;&#x2F; Sets the current working directory.<br>process.cpuUsage()      &#x2F;&#x2F; Reports CPU usage.<br>process.env             &#x2F;&#x2F; An object of environment variables.<br>process.execPath        &#x2F;&#x2F; The absolute filesystem path to the node executable.<br>process.exit()          &#x2F;&#x2F; Terminates the program.<br>process.exitCode        &#x2F;&#x2F; An integer code to be reported when the program exits.<br>process.getuid()        &#x2F;&#x2F; Return the Unix user id of the current user.<br>process.hrtime.bigint() &#x2F;&#x2F; Return a â€œhigh-resolutionâ€ nanosecond timestamp.<br>process.kill()          &#x2F;&#x2F; Send a signal to another process.<br>process.memoryUsage()   &#x2F;&#x2F; Return an object with memory usage details.<br>process.nextTick()      &#x2F;&#x2F; Like setImmediate(), invoke a function soon.<br>process.pid             &#x2F;&#x2F; The process id of the current process.<br>process.ppid            &#x2F;&#x2F; The parent process id.<br>process.platform        &#x2F;&#x2F; The OS: â€œlinuxâ€, â€œdarwinâ€, or â€œwin32â€, for example.<br>process.resourceUsage() &#x2F;&#x2F; Return an object with resource usage details.<br>process.setuid()        &#x2F;&#x2F; Sets the current user, by id or name.<br>process.title           &#x2F;&#x2F; The process name that appears in <code>ps</code> listings.<br>process.umask()         &#x2F;&#x2F; Set or return the default permissions for new files.<br>process.uptime()        &#x2F;&#x2F; Return Nodeâ€™s uptime in seconds.<br>process.version         &#x2F;&#x2F; Nodeâ€™s version string.<br>process.versions        &#x2F;&#x2F; Version strings for the libraries Node depends on.<br>The â€œosâ€ module (which, unlike process, needs to be explicitly loaded with require()) provides access to similarly low-level details about the computer and operating system that Node is running on. You may never need to use any of these features, but it is worth knowing that Node makes them available:</p>
<p>const os &#x3D; require(â€œosâ€);<br>os.arch()              &#x2F;&#x2F; Returns CPU architecture. â€œx64â€ or â€œarmâ€, for example.<br>os.constants           &#x2F;&#x2F; Useful constants such as os.constants.signals.SIGINT.<br>os.cpus()              &#x2F;&#x2F; Data about system CPU cores, including usage times.<br>os.endianness()        &#x2F;&#x2F; The CPUâ€™s native endianness â€œBEâ€ or â€œLEâ€.<br>os.EOL                 &#x2F;&#x2F; The OS native line terminator: â€œ\nâ€ or â€œ\r\nâ€.<br>os.freemem()           &#x2F;&#x2F; Returns the amount of free RAM in bytes.<br>os.getPriority()       &#x2F;&#x2F; Returns the OS scheduling priority of a process.<br>os.homedir()           &#x2F;&#x2F; Returns the current userâ€™s home directory.<br>os.hostname()          &#x2F;&#x2F; Returns the hostname of the computer.<br>os.loadavg()           &#x2F;&#x2F; Returns the 1, 5, and 15-minute load averages.<br>os.networkInterfaces() &#x2F;&#x2F; Returns details about available network. connections.<br>os.platform()          &#x2F;&#x2F; Returns OS: â€œlinuxâ€, â€œdarwinâ€, or â€œwin32â€, for example.<br>os.release()           &#x2F;&#x2F; Returns the version number of the OS.<br>os.setPriority()       &#x2F;&#x2F; Attempts to set the scheduling priority for a process.<br>os.tmpdir()            &#x2F;&#x2F; Returns the default temporary directory.<br>os.totalmem()          &#x2F;&#x2F; Returns the total amount of RAM in bytes.<br>os.type()              &#x2F;&#x2F; Returns OS: â€œLinuxâ€, â€œDarwinâ€, or â€œWindows_NTâ€, e.g.<br>os.uptime()            &#x2F;&#x2F; Returns the system uptime in seconds.<br>os.userInfo()          &#x2F;&#x2F; Returns uid, username, home, and shell of current user.</p>
<h2 id="16-7-Working-with-Files"><a href="#16-7-Working-with-Files" class="headerlink" title="16.7 Working with Files"></a>16.7 Working with Files</h2><p>Nodeâ€™s â€œfsâ€ module is a comprehensive API for working with files and directories. It is complemented by the â€œpathâ€ module, which defines utility functions for working with file and directory names. The â€œfsâ€ module contains a handful of high-level functions for easily reading, writing, and copying files. But most of the functions in the module are low-level JavaScript bindings to Unix system calls (and their equivalents on Windows). If you have worked with low-level filesystem calls before (in C or other languages), then the Node API will be familiar to you. If not, you may find parts of the â€œfsâ€ API to be terse and unintuitive. The function to delete a file, for example, is called unlink().</p>
<p>The â€œfsâ€ module defines a large API, mainly because there are usually multiple variants of each fundamental operation. As discussed at the beginning of the chapter, most functions such as fs.readFile() are nonblocking, callback-based, and asynchronous. Typically, though, each of these functions has a synchronous blocking variant, such as fs.readFileSync(). In Node 10 and later, many of these functions also have a Promise-based asynchronous variant such as fs.promises.readFile(). Most â€œfsâ€ functions take a string as their first argument, specifying the path (filename plus optional directory names) to the file that is to be operated on. But a number of these functions also support a variant that takes an integer â€œfile descriptorâ€ as the first argument instead of a path. These variants have names that begin with the letter â€œf.â€ For example, fs.truncate() truncates a file specified by path, and fs.ftruncate() truncates a file specified by file descriptor. There is a Promise-based fs.promises.truncate() that expects a path and another Promise-based version that is implemented as a method of a FileHandle object. (The FileHandle class is the equivalent of a file descriptor in the Promise-based API.) Finally, there are a handful of functions in the â€œfsâ€ module that have variants whose names are prefixed with the letter â€œl.â€ These â€œlâ€ variants are like the base function but do not follow symbolic links in the filesystem and instead operate directly on the symbolic links themselves.</p>
<h3 id="16-7-1-Paths-File-Descriptors-and-FileHandles"><a href="#16-7-1-Paths-File-Descriptors-and-FileHandles" class="headerlink" title="16.7.1 Paths, File Descriptors, and FileHandles"></a>16.7.1 Paths, File Descriptors, and FileHandles</h3><p>In order to use the â€œfsâ€ module to work with files, you first need to be able to name the file you want to work with. Files are most often specified by path, which means the name of the file itself, plus the hierarchy of directories in which the file appears. If a path is absolute, it means that directories all the way up to the filesystem root are specified. Otherwise, the path is relative and is only meaningful in relation to some other path, usually the current working directory. Working with paths can be a little tricky because different operating systems use different characters to separate directory names, it is easy to accidentally double those separator characters when concatenating paths, and because ..&#x2F; parent directory path segments need special handling. Nodeâ€™s â€œpathâ€ module and a couple of other important Node features help:</p>
<p>&#x2F;&#x2F; Some important paths<br>process.cwd()      &#x2F;&#x2F; Absolute path of the current working directory.<br>__filename         &#x2F;&#x2F; Absolute path of the file that holds the current code.<br>__dirname          &#x2F;&#x2F; Absolute path of the directory that holds __filename.<br>os.homedir()       &#x2F;&#x2F; The userâ€™s home directory.</p>
<p>const path &#x3D; require(â€œpathâ€);</p>
<p>path.sep                         &#x2F;&#x2F; Either â€œ&#x2F;â€œ or â€œ&quot; depending on your OS</p>
<p>&#x2F;&#x2F; The path module has simple parsing functions<br>let p &#x3D; â€œsrc&#x2F;pkg&#x2F;test.jsâ€;       &#x2F;&#x2F; An example path<br>path.basename(p)                 &#x2F;&#x2F; &#x3D;&gt; â€œtest.jsâ€<br>path.extname(p)                  &#x2F;&#x2F; &#x3D;&gt; â€œ.jsâ€<br>path.dirname(p)                  &#x2F;&#x2F; &#x3D;&gt; â€œsrc&#x2F;pkgâ€<br>path.basename(path.dirname(p))   &#x2F;&#x2F; &#x3D;&gt; â€œpkgâ€<br>path.dirname(path.dirname(p))    &#x2F;&#x2F; &#x3D;&gt; â€œsrcâ€</p>
<p>&#x2F;&#x2F; normalize() cleans up paths:<br>path.normalize(â€œa&#x2F;b&#x2F;c&#x2F;..&#x2F;d&#x2F;â€œ)    &#x2F;&#x2F; &#x3D;&gt; â€œa&#x2F;b&#x2F;d&#x2F;â€œ: handles ..&#x2F; segments<br>path.normalize(â€œa&#x2F;.&#x2F;bâ€)          &#x2F;&#x2F; &#x3D;&gt; â€œa&#x2F;bâ€: strips â€œ.&#x2F;â€œ segments<br>path.normalize(â€œ&#x2F;&#x2F;a&#x2F;&#x2F;b&#x2F;&#x2F;â€œ)       &#x2F;&#x2F; &#x3D;&gt; â€œ&#x2F;a&#x2F;b&#x2F;â€œ: removes duplicate &#x2F;</p>
<p>&#x2F;&#x2F; join() combines path segments, adding separators, then normalizes<br>path.join(â€œsrcâ€, â€œpkgâ€, â€œt.jsâ€)  &#x2F;&#x2F; &#x3D;&gt; â€œsrc&#x2F;pkg&#x2F;t.jsâ€</p>
<p>&#x2F;&#x2F; resolve() takes one or more path segments and returns an absolute<br>&#x2F;&#x2F; path. It starts with the last argument and works backward, stopping<br>&#x2F;&#x2F; when it has built an absolute path or resolving against process.cwd().<br>path.resolve()                   &#x2F;&#x2F; &#x3D;&gt; process.cwd()<br>path.resolve(â€œt.jsâ€)             &#x2F;&#x2F; &#x3D;&gt; path.join(process.cwd(), â€œt.jsâ€)<br>path.resolve(â€œ&#x2F;tmpâ€, â€œt.jsâ€)     &#x2F;&#x2F; &#x3D;&gt; â€œ&#x2F;tmp&#x2F;t.jsâ€<br>path.resolve(â€œ&#x2F;aâ€, â€œ&#x2F;bâ€, â€œt.jsâ€) &#x2F;&#x2F; &#x3D;&gt; â€œ&#x2F;b&#x2F;t.jsâ€<br>Note that path.normalize() is simply a string manipulation function that has no access to the actual filesystem. The fs.realpath() and fs.realpathSync() functions perform filesystem-aware canonicalization: they resolve symbolic links and interpret relative pathnames relative to the current working directory.</p>
<p>In the previous examples, we assumed that the code is running on a Unix-based OS and path.sep is â€œ&#x2F;.â€ If you want to work with Unix-style paths even when on a Windows system, then use path.posix instead of path. And conversely, if you want to work with Windows paths even when on a Unix system, path.win32. path.posix and path.win32 define the same properties and functions as path itself.</p>
<p>Some of the â€œfsâ€ functions weâ€™ll be covering in the next sections expect a file descriptor instead of a file name. File descriptors are integers used as OS-level references to â€œopenâ€ files. You obtain a descriptor for a given name by calling the fs.open() (or fs.openSync()) function. Processes are only allowed to have a limited number of files open at one time, so it is important that you call fs.close() on your file descriptors when you are done with them. You need to open files if you want to use the lowest-level fs.read() and fs.write() functions that allow you to jump around within a file, reading and writing bits of it at different times. There are other functions in the â€œfsâ€ module that use file descriptors, but they all have name-based versions, and it only really makes sense to use the descriptor-based functions if you were going to open the file to read or write anyway.</p>
<p>Finally, in the Promise-based API defined by fs.promises, the equivalent of fs.open() is fs.promises.open(), which returns a Promise that resolves to a FileHandle object. This FileHandle object serves the same purpose as a file descriptor. Again, however, unless you need to use the lowest-level read() and write() methods of a FileHandle, there is really no reason to create one. And if you do create a FileHandle, you should remember to call its close() method once you are done with it.</p>
<h3 id="16-7-2-Reading-Files"><a href="#16-7-2-Reading-Files" class="headerlink" title="16.7.2 Reading Files"></a>16.7.2 Reading Files</h3><p>Node allows you to read file content all at once, via a stream, or with the low-level API.</p>
<p>If your files are small, or if memory usage and performance are not the highest priority, then it is often easiest to read the entire content of a file with a single call. You can do this synchronously, with a callback, or with a Promise. By default, youâ€™ll get the bytes of the file as a buffer, but if you specify an encoding, youâ€™ll get a decoded string instead.</p>
<p>const fs &#x3D; require(â€œfsâ€);<br>let buffer &#x3D; fs.readFileSync(â€œtest.dataâ€);      &#x2F;&#x2F; Synchronous, returns buffer<br>let text &#x3D; fs.readFileSync(â€œdata.csvâ€, â€œutf8â€); &#x2F;&#x2F; Synchronous, returns string</p>
<p>&#x2F;&#x2F; Read the bytes of the file asynchronously<br>fs.readFile(â€œtest.dataâ€, (err, buffer) &#x3D;&gt; {<br>    if (err) {<br>        &#x2F;&#x2F; Handle the error here<br>    } else {<br>        &#x2F;&#x2F; The bytes of the file are in buffer<br>    }<br>});</p>
<p>&#x2F;&#x2F; Promise-based asynchronous read<br>fs.promises<br>    .readFile(â€œdata.csvâ€, â€œutf8â€)<br>    .then(processFileText)<br>    .catch(handleReadError);</p>
<p>&#x2F;&#x2F; Or use the Promise API with await inside an async function<br>async function processText(filename, encoding&#x3D;â€utf8â€) {<br>    let text &#x3D; await fs.promises.readFile(filename, encoding);<br>    &#x2F;&#x2F; â€¦ process the text hereâ€¦<br>}<br>If you are able to process the contents of a file sequentially and do not need to have the entire content of the file in memory at the same time, then reading a file via a stream may be the most efficient approach. Weâ€™ve covered streams extensively: here is how you might use a stream and the pipe() method to write the contents of a file to standard output:</p>
<p>function printFile(filename, encoding&#x3D;â€utf8â€) {<br>    fs.createReadStream(filename, encoding).pipe(process.stdout);<br>}<br>Finally, if you need low-level control over exactly what bytes you read from a file and when you read them, you can open a file to get a file descriptor and then use fs.read(), fs.readSync(), or fs.promises.read() to read a specified number of bytes from a specified source location of the file into a specified buffer at the specified destination position:</p>
<p>const fs &#x3D; require(â€œfsâ€);</p>
<p>&#x2F;&#x2F; Reading a specific portion of a data file<br>fs.open(â€œdataâ€, (err, fd) &#x3D;&gt; {<br>    if (err) {<br>        &#x2F;&#x2F; Report error somehow<br>        return;<br>    }<br>    try {<br>        &#x2F;&#x2F; Read bytes 20 through 420 into a newly allocated buffer.<br>        fs.read(fd, Buffer.alloc(400), 0, 400, 20, (err, n, b) &#x3D;&gt; {<br>            &#x2F;&#x2F; err is the error, if any.<br>            &#x2F;&#x2F; n is the number of bytes actually read<br>            &#x2F;&#x2F; b is the buffer that they bytes were read into.<br>        });<br>    }<br>    finally {          &#x2F;&#x2F; Use a finally clause so we always<br>        fs.close(fd);  &#x2F;&#x2F; close the open file descriptor<br>    }<br>});<br>The callback-based read() API is awkward to use if you need to read more than one chunk of data from a file. If you can use the synchronous API (or the Promise-based API with await), it becomes easy to read multiple chunks from a file:</p>
<p>const fs &#x3D; require(â€œfsâ€);</p>
<p>function readData(filename) {<br>    let fd &#x3D; fs.openSync(filename);<br>    try {<br>        &#x2F;&#x2F; Read the file header<br>        let header &#x3D; Buffer.alloc(12); &#x2F;&#x2F; A 12 byte buffer<br>        fs.readSync(fd, header, 0, 12, 0);</p>
<pre><code>    // Verify the file&#39;s magic number
    let magic = header.readInt32LE(0);
    if (magic !== 0xDADAFEED) &#123;
        throw new Error(&quot;File is of wrong type&quot;);
    &#125;

    // Now get the offset and length of the data from the header
    let offset = header.readInt32LE(4);
    let length = header.readInt32LE(8);

    // And read those bytes from the file
    let data = Buffer.alloc(length);
    fs.readSync(fd, data, 0, length, offset);
    return data;
&#125; finally &#123;
    // Always close the file, even if an exception is thrown above
    fs.closeSync(fd);
&#125;
</code></pre>
<p>}</p>
<h3 id="16-7-3-Writing-Files"><a href="#16-7-3-Writing-Files" class="headerlink" title="16.7.3 Writing Files"></a>16.7.3 Writing Files</h3><p>Writing files in Node is a lot like reading them, with a few extra details that you need to know about. One of these details is that the way you create a new file is simply by writing to a filename that does not already exist.</p>
<p>As with reading, there are three basic ways to write files in Node. If you have the entire content of the file in a string or a buffer, you can write the entire thing in one call with fs.writeFile() (callback-based), fs.writeFileSync() (synchronous), or fs.promises.writeFile() (Promise-based):</p>
<p>fs.writeFileSync(path.resolve(__dirname, â€œsettings.jsonâ€),<br>                 JSON.stringify(settings));<br>If the data you are writing to the file is a string, and you want to use an encoding other than â€œutf8,â€ pass the encoding as an optional third argument.</p>
<p>The related functions fs.appendFile(), fs.appendFileSync(), and fs.promises.appendFile() are similar, but when the specified file already exists, they append their data to the end rather than overwriting the existing file content.</p>
<p>If the data you want to write to a file is not all in one chunk, or if it is not all in memory at the same time, then using a Writable stream is a good approach, assuming that you plan to write the data from beginning to end without skipping around in the file:</p>
<p>const fs &#x3D; require(â€œfsâ€);<br>let output &#x3D; fs.createWriteStream(â€œnumbers.txtâ€);<br>for(let i &#x3D; 0; i &lt; 100; i++) {<br>    output.write(<code>$&#123;i&#125;\n</code>);<br>}<br>output.end();<br>Finally, if you want to write data to a file in multiple chunks, and you want to be able to control the exact position within the file at which each chunk is written, then you can open the file with fs.open(), fs.openSync(), or fs.promises.open() and then use the resulting file descriptor with the fs.write() or fs.writeSync() functions. These functions come in different forms for strings and buffers. The string variant takes a file descriptor, a string, and the file position at which to write that string (with an encoding as an optional fourth argument). The buffer variant takes a file descriptor, a buffer, an offset, and a length that specify a chunk of data within the buffer, and a file position at which to write the bytes of that chunk. And if you have an array of Buffer objects that you want to write, you can do this with a single fs.writev() or fs.writevSync(). Similar low-level functions exist for writing buffers and strings using fs.promises.open() and the FileHandle object it produces.</p>
<p>FILE MODE STRINGS<br>We saw the fs.open() and fs.openSync() methods before when using the low-level API to read files. In that use case, it was sufficient to just pass the filename to the open function. When you want to write a file, however, you must also specify a second string argument that specifies how you intend to use the file descriptor. Some of the available flag strings are as follows:</p>
<p>â€œwâ€<br>Open the file for writing</p>
<p>â€œw+â€<br>Open for writing and reading</p>
<p>â€œwxâ€<br>Open for creating a new file; fails if the named file already exists</p>
<p>â€œwx+â€<br>Open for creation, and also allow reading; fails if the named file already exists</p>
<p>â€œaâ€<br>Open the file for appending; existing content wonâ€™t be overwritten</p>
<p>â€œa+â€<br>Open for appending, but also allow reading</p>
<p>If you do not pass one of these flag strings to fs.open() or fs.openSync(), they use the default â€œrâ€ flag, making the file descriptor read-only. Note that it can also be useful to pass these flags to other file-writing methods:</p>
<p>&#x2F;&#x2F; Write to a file in one call, but append to anything that is already there.<br>&#x2F;&#x2F; This works like fs.appendFileSync()<br>fs.writeFileSync(â€œmessages.logâ€, â€œhelloâ€, { flag: â€œaâ€ });</p>
<p>&#x2F;&#x2F; Open a write stream, but throw an error if the file already exists.<br>&#x2F;&#x2F; We donâ€™t want to accidentally overwrite something!<br>&#x2F;&#x2F; Note that the option above is â€œflagâ€ and is â€œflagsâ€ here<br>fs.createWriteStream(â€œmessages.logâ€, { flags: â€œwxâ€ });<br>You can chop off the end of a file with fs.truncate(), fs.truncateSync(), or fs.promises.truncate(). These functions take a path as their first argument and a length as their second, and modify the file so that it has the specified length. If you omit the length, zero is used and the file becomes empty. Despite the name of these functions, they can also be used to extend a file: if you specify a length that is longer than the current file size, the file is extended with zero bytes to the new size. If you have already opened the file you wish to modify, you can use ftruncate() or ftruncateSync() with the file descriptor or FileHandle.</p>
<p>The various file-writing functions described here return or invoke their callback or resolve their Promise when the data has been â€œwrittenâ€ in the sense that Node has handed it off to the operating system. But this does not necessarily mean that the data has actually been written to persistent storage yet: at least some of your data may still be buffered somewhere in the operating system or in a device driver waiting to be written to disk. If you call fs.writeSync() to synchronously write some data to a file, and if there is a power outage immediately after the function returns, you may still lose data. If you want to force your data out to disk so you know for sure that it has been safely saved, use fs.fsync() or fs.fsyncSync(). These functions only work with file descriptors: there is no path-based version.</p>
<h3 id="16-7-4-File-Operations"><a href="#16-7-4-File-Operations" class="headerlink" title="16.7.4 File Operations"></a>16.7.4 File Operations</h3><p>The preceding discussion of Nodeâ€™s stream classes included two examples of copyFile() functions. These are not practical utilities that you would actually use because the â€œfsâ€ module defines its own fs.copyFile() method (and also fs.copyFileSync() and fs.promises.copyFile(), of course).</p>
<p>These functions take the name of the original file and the name of the copy as their first two arguments. These can be specified as strings or as URL or Buffer objects. An optional third argument is an integer whose bits specify flags that control details of the copy operation. And for the callback-based fs.copyFile(), the final argument is a callback function that will be called with no arguments when the copy is complete, or that will be called with an error argument if something fails. Following are some examples:</p>
<p>&#x2F;&#x2F; Basic synchronous file copy.<br>fs.copyFileSync(â€œch15.txtâ€, â€œch15.bakâ€);</p>
<p>&#x2F;&#x2F; The COPYFILE_EXCL argument copies only if the new file does not already<br>&#x2F;&#x2F; exist. It prevents copies from overwriting existing files.<br>fs.copyFile(â€œch15.txtâ€, â€œch16.txtâ€, fs.constants.COPYFILE_EXCL, err &#x3D;&gt; {<br>    &#x2F;&#x2F; This callback will be called when done. On error, err will be non-null.<br>});</p>
<p>&#x2F;&#x2F; This code demonstrates the Promise-based version of the copyFile function.<br>&#x2F;&#x2F; Two flags are combined with the bitwise OR opeartor |. The flags mean that<br>&#x2F;&#x2F; existing files wonâ€™t be overwritten, and that if the filesystem supports<br>&#x2F;&#x2F; it, the copy will be a copy-on-write clone of the original file, meaning<br>&#x2F;&#x2F; that no additional storage space will be required until either the original<br>&#x2F;&#x2F; or the copy is modified.<br>fs.promises.copyFile(â€œImportant dataâ€,<br>                     &#96;Important data ${new Date().toISOString()}â€<br>                     fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE)<br>    .then(() &#x3D;&gt; {<br>        console.log(â€œBackup completeâ€);<br>    });<br>    .catch(err &#x3D;&gt; {<br>        console.error(â€œBackup failedâ€, err);<br>    });<br>The fs.rename() function (along with the usual synchronous and Promise-based variants) moves and&#x2F;or renames a file. Call it with the current path to the file and the desired new path to the file. There is no flags argument, but the callback-based version takes a callback as the third argument:</p>
<p>fs.renameSync(â€œch15.bakâ€, â€œbackups&#x2F;ch15.bakâ€);<br>Note that there is no flag to prevent renaming from overwriting an existing file. Also keep in mind that files can only be renamed within a filesystem.</p>
<p>The functions fs.link() and fs.symlink() and their variants have the same signatures as fs.rename() and behave something like fs.copyFile() except that they create hard links and symbolic links, respectively, rather than creating a copy.</p>
<p>Finally, fs.unlink(), fs.unlinkSync(), and fs.promises.unlink() are Nodeâ€™s functions for deleting a file. (The unintuitive naming is inherited from Unix where deleting a file is basically the opposite of creating a hard link to it.) Call this function with the string, buffer, or URL path to the file to be deleted, and pass a callback if you are using the callback-based version:</p>
<p>fs.unlinkSync(â€œbackups&#x2F;ch15.bakâ€);</p>
<h3 id="16-7-5-File-Metadata"><a href="#16-7-5-File-Metadata" class="headerlink" title="16.7.5 File Metadata"></a>16.7.5 File Metadata</h3><p>The fs.stat(), fs.statSync(), and fs.promises.stat() functions allow you to obtain metadata for a specified file or directory. For example:</p>
<p>const fs &#x3D; require(â€œfsâ€);<br>let stats &#x3D; fs.statSync(â€œbook&#x2F;ch15.mdâ€);<br>stats.isFile()         &#x2F;&#x2F; &#x3D;&gt; true: this is an ordinary file<br>stats.isDirectory()    &#x2F;&#x2F; &#x3D;&gt; false: it is not a directory<br>stats.size             &#x2F;&#x2F; file size in bytes<br>stats.atime            &#x2F;&#x2F; access time: Date when it was last read<br>stats.mtime            &#x2F;&#x2F; modification time: Date when it was last written<br>stats.uid              &#x2F;&#x2F; the user id of the fileâ€™s owner<br>stats.gid              &#x2F;&#x2F; the group id of the fileâ€™s owner<br>stats.mode.toString(8) &#x2F;&#x2F; the fileâ€™s permissions, as an octal string<br>The returned Stats object contains other, more obscure properties and methods, but this code demonstrates those that you are most likely to use.</p>
<p>fs.lstat() and its variants work just like fs.stat(), except that if the specified file is a symbolic link, Node will return metadata for the link itself rather than following the link.</p>
<p>If you have opened a file to produce a file descriptor or a FileHandle object, then you can use fs.fstat() or its variants to get metadata information for the opened file without having to specify the filename again.</p>
<p>In addition to querying metadata with fs.stat() and all of its variants, there are also functions for changing metadata.</p>
<p>fs.chmod(), fs.lchmod(), and fs.fchmod() (along with synchronous and Promise-based versions) set the â€œmodeâ€ or permissions of a file or directory. Mode values are integers in which each bit has a specific meaning and are easiest to think about in octal notation. For example, to make a file read-only to its owner and inaccessible to everyone else, use 0o400:</p>
<p>fs.chmodSync(â€œch15.mdâ€, 0o400);  &#x2F;&#x2F; Donâ€™t delete it accidentally!<br>fs.chown(), fs.lchown(), and fs.fchown() (along with synchronous and Promise-based versions) set the owner and group (as IDs) for a file or directory. (These matter because they interact with the file permissions set by fs.chmod().)</p>
<p>Finally, you can set the access time and modification time of a file or directory with fs.utimes() and fs.futimes() and their variants.</p>
<h3 id="16-7-6-Working-with-Directories"><a href="#16-7-6-Working-with-Directories" class="headerlink" title="16.7.6 Working with Directories"></a>16.7.6 Working with Directories</h3><p>To create a new directory in Node, use fs.mkdir(), fs.mkdirSync(), or fs.promises.mkdir(). The first argument is the path of the directory to be created. The optional second argument can be an integer that specifies the mode (permissions bits) for the new directory. Or you can pass an object with optional mode and recursive properties. If recursive is true, then this function will create any directories in the path that do not already exist:</p>
<p>&#x2F;&#x2F; Ensure that dist&#x2F; and dist&#x2F;lib&#x2F; both exist.<br>fs.mkdirSync(â€œdist&#x2F;libâ€, { recursive: true });<br>fs.mkdtemp() and its variants take a path prefix you provide, append some random characters to it (this is important for security), create a directory with that name, and return (or pass to a callback) the directory path to you.</p>
<p>To delete a directory, use fs.rmdir() or one of its variants. Note that directories must be empty before they can be deleted:</p>
<p>&#x2F;&#x2F; Create a random temporary directory and get its path, then<br>&#x2F;&#x2F; delete it when we are done<br>let tempDirPath;<br>try {<br>    tempDirPath &#x3D; fs.mkdtempSync(path.join(os.tmpdir(), â€œdâ€));<br>    &#x2F;&#x2F; Do something with the directory here<br>} finally {<br>    &#x2F;&#x2F; Delete the temporary directory when weâ€™re done with it<br>    fs.rmdirSync(tempDirPath);<br>}<br>The â€œfsâ€ module provides two distinct APIs for listing the contents of a directory. First, fs.readdir(), fs.readdirSync(), and fs.promises.readdir() read the entire directory all at once and give you an array of strings or an array of Dirent objects that specify the names and types (file or directory) of each item. Filenames returned by these functions are just the local name of the file, not the entire path. Here are examples:</p>
<p>let tempFiles &#x3D; fs.readdirSync(â€œ&#x2F;tmpâ€);  &#x2F;&#x2F; returns an array of strings</p>
<p>&#x2F;&#x2F; Use the Promise-based API to get a Dirent array, and then<br>&#x2F;&#x2F; print the paths of subdirectories<br>fs.promises.readdir(â€œ&#x2F;tmpâ€, {withFileTypes: true})<br>    .then(entries &#x3D;&gt; {<br>        entries.filter(entry &#x3D;&gt; entry.isDirectory())<br>            .map(entry &#x3D;&gt; entry.name)<br>            .forEach(name &#x3D;&gt; console.log(path.join(â€œ&#x2F;tmp&#x2F;â€œ, name)));<br>    })<br>    .catch(console.error);<br>If you anticipate needing to list directories that might have thousands of entries, you might prefer the streaming approach of fs.opendir() and its variants. These functions return a Dir object representing the specified directory. You can use the read() or readSync() methods of the Dir object to read one Dirent at a time. If you pass a callback function to read(), it will call the callback. And if you omit the callback argument, it will return a Promise. When there are no more directory entries, youâ€™ll get null instead of a Dirent object.</p>
<p>The easiest way to use Dir objects is as async iterators with a for&#x2F;await loop. Here, for example, is a function that uses the streaming API to list directory entries, calls stat() on each entry, and prints file and directory names and sizes:</p>
<p>const fs &#x3D; require(â€œfsâ€);<br>const path &#x3D; require(â€œpathâ€);</p>
<p>async function listDirectory(dirpath) {<br>    let dir &#x3D; await fs.promises.opendir(dirpath);<br>    for await (let entry of dir) {<br>        let name &#x3D; entry.name;<br>        if (entry.isDirectory()) {<br>            name +&#x3D; â€œ&#x2F;â€œ;  &#x2F;&#x2F; Add a trailing slash to subdirectories<br>        }<br>        let stats &#x3D; await fs.promises.stat(path.join(dirpath, name));<br>        let size &#x3D; stats.size;<br>        console.log(String(size).padStart(10), name);<br>    }<br>}</p>
<h2 id="16-8-HTTP-Clients-and-Servers"><a href="#16-8-HTTP-Clients-and-Servers" class="headerlink" title="16.8 HTTP Clients and Servers"></a>16.8 HTTP Clients and Servers</h2><p>Nodeâ€™s â€œhttp,â€ â€œhttps,â€ and â€œhttp2â€ modules are full-featured but relatively low-level implementations of the HTTP protocols. They define comprehensive APIs for implementing HTTP clients and servers. Because the APIs are relatively low-level, there is not room in this chapter to cover all the features. But the examples that follow demonstrate how to write basic clients and servers.</p>
<p>The simplest way to make a basic HTTP GET request is with http.get() or https.get(). The first argument to these functions is the URL to fetch. (If it is an http:&#x2F;&#x2F; URL, you must use the â€œhttpâ€ module, and if it is an https:&#x2F;&#x2F; URL you must use the â€œhttpsâ€ module.) The second argument is a callback that will be invoked with an IncomingMessage object when the serverâ€™s response has started to arrive. When the callback is called, the HTTP status and headers are available, but the body may not be ready yet. The IncomingMessage object is a Readable stream, and you can use the techniques demonstrated earlier in this chapter to read the response body from it.</p>
<p>The getJSON() function at the end of Â§13.2.6 used the http.get() function as part of a demonstration of the Promise() constructor. Now that you know about Node streams and the Node programming model more generally, it is worth revisiting that example to see how http.get() is used.</p>
<p>http.get() and https.get() are slightly simplified variants of the more general http.request() and https.request() functions. The following postJSON() function demonstrates how to use https.request() to make an HTTPS POST request that includes a JSON request body. Like the getJSON() function of Chapter 13, it expects a JSON response and returns a Promise that fulfills to the parsed version of that response:</p>
<p>const https &#x3D; require(â€œhttpsâ€);</p>
<p>&#x2F;*</p>
<ul>
<li>Convert the body object to a JSON string then HTTPS POST it to the</li>
<li>specified API endpoint on the specified host. When the response arrives,</li>
<li>parse the response body as JSON and resolve the returned Promise with</li>
<li>that parsed value.<br> *&#x2F;<br>function postJSON(host, endpoint, body, port, username, password) {<br> &#x2F;&#x2F; Return a Promise object immediately, then call resolve or reject<br> &#x2F;&#x2F; when the HTTPS request succeeds or fails.<br> return new Promise((resolve, reject) &#x3D;&gt; {<br> &#x2F;&#x2F; Convert the body object to a string<br> let bodyText &#x3D; JSON.stringify(body);<br><br> &#x2F;&#x2F; Configure the HTTPS request<br> let requestOptions &#x3D; {<br>     method: â€œPOSTâ€,       &#x2F;&#x2F; Or â€œGETâ€, â€œPUTâ€, â€œDELETEâ€, etc.<br>     host: host,           &#x2F;&#x2F; The host to connect to<br>     path: endpoint,       &#x2F;&#x2F; The URL path<br>     headers: {            &#x2F;&#x2F; HTTP headers for the request<br>         â€œContent-Typeâ€: â€œapplication&#x2F;jsonâ€,<br>         â€œContent-Lengthâ€: Buffer.byteLength(bodyText)<br>     }<br> };<br><br> if (port) {                      &#x2F;&#x2F; If a port is specified,<br>     requestOptions.port &#x3D; port;  &#x2F;&#x2F; use it for the request.<br> }<br> &#x2F;&#x2F; If credentials are specified, add an Authorization header.<br> if (username &amp;&amp; password) {<br>     requestOptions.auth &#x3D; <code>$&#123;username&#125;:$&#123;password&#125;</code>;<br> }<br><br> &#x2F;&#x2F; Now create the request based on the configuration object<br> let request &#x3D; https.request(requestOptions);<br><br> &#x2F;&#x2F; Write the body of the POST request and end the request.<br> request.write(bodyText);<br> request.end();<br><br> &#x2F;&#x2F; Fail on request errors (such as no network connection)<br> request.on(â€œerrorâ€, e &#x3D;&gt; reject(e));<br><br> &#x2F;&#x2F; Handle the response when it starts to arrive.<br> request.on(â€œresponseâ€, response &#x3D;&gt; {<br>     if (response.statusCode !&#x3D;&#x3D; 200) {<br>         reject(new Error(<code>HTTP status $&#123;response.statusCode&#125;</code>));<br>         &#x2F;&#x2F; We donâ€™t care about the response body in this case, but<br>         &#x2F;&#x2F; we donâ€™t want it to stick around in a buffer somewhere, so<br>         &#x2F;&#x2F; we put the stream into flowing mode without registering<br>         &#x2F;&#x2F; a â€œdataâ€ handler so that the body is discarded.<br>         response.resume();<br>         return;<br>     }<br><br>     &#x2F;&#x2F; We want text, not bytes. Weâ€™re assuming the text will be<br>     &#x2F;&#x2F; JSON-formatted but arenâ€™t bothering to check the<br>     &#x2F;&#x2F; Content-Type header.<br>     response.setEncoding(â€œutf8â€);<br><br>     &#x2F;&#x2F; Node doesnâ€™t have a streaming JSON parser, so we read the<br>     &#x2F;&#x2F; entire response body into a string.<br>     let body &#x3D; â€œâ€;<br>     response.on(â€œdataâ€, chunk &#x3D;&gt; { body +&#x3D; chunk; });<br><br>     &#x2F;&#x2F; And now handle the response when it is complete.<br>     response.on(â€œendâ€, () &#x3D;&gt; {          &#x2F;&#x2F; When the response is done,<br>         try {                           &#x2F;&#x2F; try to parse it as JSON<br>             resolve(JSON.parse(body));  &#x2F;&#x2F; and resolve the result.<br>         } catch(e) {                    &#x2F;&#x2F; Or, if anything goes wrong,<br>             reject(e);                  &#x2F;&#x2F; reject with the error<br>         }<br>     });<br> });<br> });</li>
</ul>
<p>}<br>In addition to making HTTP and HTTPS requests, the â€œhttpâ€ and â€œhttpsâ€ modules also allow you to write servers that respond to those requests. The basic approach is as follows:</p>
<p>Create a new Server object.</p>
<p>Call its listen() method to begin listening for requests on a specified port.</p>
<p>Register an event handler for â€œrequestâ€ events, use that handler to read the clientâ€™s request (particularly the request.url property), and write your response.</p>
<p>The code that follows creates a simple HTTP server that serves static files from the local filesystem and also implements a debugging endpoint that responds to a clientâ€™s request by echoing that request.</p>
<p>&#x2F;&#x2F; This is a simple static HTTP server that serves files from a specified<br>&#x2F;&#x2F; directory. It also implements a special &#x2F;test&#x2F;mirror endpoint that<br>&#x2F;&#x2F; echoes the incoming request, which can be useful when debugging clients.<br>const http &#x3D; require(â€œhttpâ€);   &#x2F;&#x2F; Use â€œhttpsâ€ if you have a certificate<br>const url &#x3D; require(â€œurlâ€);     &#x2F;&#x2F; For parsing URLs<br>const path &#x3D; require(â€œpathâ€);   &#x2F;&#x2F; For manipulating filesystem paths<br>const fs &#x3D; require(â€œfsâ€);       &#x2F;&#x2F; For reading files</p>
<p>&#x2F;&#x2F; Serve files from the specified root directory via an HTTP server that<br>&#x2F;&#x2F; listens on the specified port.<br>function serve(rootDirectory, port) {<br>    let server &#x3D; new http.Server();  &#x2F;&#x2F; Create a new HTTP server<br>    server.listen(port);             &#x2F;&#x2F; Listen on the specified port<br>    console.log(â€œListening on portâ€, port);</p>
<pre><code>// When requests come in, handle them with this function
server.on(&quot;request&quot;, (request, response) =&gt; &#123;
    // Get the path portion of the request URL, ignoring
    // any query parameters that are appended to it.
    let endpoint = url.parse(request.url).pathname;

    // If the request was for &quot;/test/mirror&quot;, send back the request
    // verbatim. Useful when you need to see the request headers and body.
    if (endpoint === &quot;/test/mirror&quot;) &#123;
        // Set response header
        response.setHeader(&quot;Content-Type&quot;, &quot;text/plain; charset=UTF-8&quot;);

        // Specify response status code
        response.writeHead(200);  // 200 OK

        // Begin the response body with the request
        response.write(`$&#123;request.method&#125; $&#123;request.url&#125; HTTP/$&#123;
                           request.httpVersion
                       &#125;\r\n`);

        // Output the request headers
        let headers = request.rawHeaders;
        for(let i = 0; i &lt; headers.length; i += 2) &#123;
            response.write(`$&#123;headers[i]&#125;: $&#123;headers[i+1]&#125;\r\n`);
        &#125;

        // End headers with an extra blank line
        response.write(&quot;\r\n&quot;);

        // Now we need to copy any request body to the response body
        // Since they are both streams, we can use a pipe
        request.pipe(response);
    &#125;
    // Otherwise, serve a file from the local directory.
    else &#123;
        // Map the endpoint to a file in the local filesystem
        let filename = endpoint.substring(1); // strip leading /
        // Don&#39;t allow &quot;../&quot; in the path because it would be a security
        // hole to serve anything outside the root directory.
        filename = filename.replace(/\.\.\//g, &quot;&quot;);
        // Now convert from relative to absolute filename
        filename = path.resolve(rootDirectory, filename);

        // Now guess the type file&#39;s content type based on extension
        let type;
        switch(path.extname(filename))  &#123;
        case &quot;.html&quot;:
        case &quot;.htm&quot;: type = &quot;text/html&quot;; break;
        case &quot;.js&quot;:  type = &quot;text/javascript&quot;; break;
        case &quot;.css&quot;: type = &quot;text/css&quot;; break;
        case &quot;.png&quot;: type = &quot;image/png&quot;; break;
        case &quot;.txt&quot;: type = &quot;text/plain&quot;; break;
        default:     type = &quot;application/octet-stream&quot;; break;
        &#125;

        let stream = fs.createReadStream(filename);
        stream.once(&quot;readable&quot;, () =&gt; &#123;
            // If the stream becomes readable, then set the
            // Content-Type header and a 200 OK status. Then pipe the
            // file reader stream to the response. The pipe will
            // automatically call response.end() when the stream ends.
            response.setHeader(&quot;Content-Type&quot;, type);
            response.writeHead(200);
            stream.pipe(response);
        &#125;);

        stream.on(&quot;error&quot;, (err) =&gt; &#123;
            // Instead, if we get an error trying to open the stream
            // then the file probably does not exist or is not readable.
            // Send a 404 Not Found plain-text response with the
            // error message.
            response.setHeader(&quot;Content-Type&quot;, &quot;text/plain; charset=UTF-8&quot;);
            response.writeHead(404);
            response.end(err.message);
        &#125;);
    &#125;
&#125;);
</code></pre>
<p>}</p>
<p>&#x2F;&#x2F; When weâ€™re invoked from the command line, call the serve() function<br>serve(process.argv[2] || â€œ&#x2F;tmpâ€, parseInt(process.argv[3]) || 8000);<br>Nodeâ€™s built-in modules are all you need to write simple HTTP and HTTPS servers. Note, however, that production servers are not typically built directly on top of these modules. Instead, most nontrivial servers are implemented using external librariesâ€”such as the Express frameworkâ€”that provide â€œmiddlewareâ€ and other higher-level utilities that backend web developers have come to expect.</p>
<h2 id="16-9-Non-HTTP-Network-Servers-and-Clients"><a href="#16-9-Non-HTTP-Network-Servers-and-Clients" class="headerlink" title="16.9 Non-HTTP Network Servers and Clients"></a>16.9 Non-HTTP Network Servers and Clients</h2><p>Web servers and clients have become so ubiquitous that it is easy to forget that it is possible to write clients and servers that do not use HTTP. Even though Node has a reputation as a good environment for writing web servers, Node also has full support for writing other types of network servers and clients.</p>
<p>If you are comfortable working with streams, then networking is relatively simple, because network sockets are simply a kind of Duplex stream. The â€œnetâ€ module defines Server and Socket classes. To create a server, call net.createServer(), then call the listen() method of the resulting object to tell the server what port to listen on for connections. The Server object will generate â€œconnectionâ€ events when a client connects on that port, and the value passed to the event listener will be a Socket object. The Socket object is a Duplex stream, and you can use it to read data from the client and write data to the client. Call end() on the Socket to disconnect.</p>
<p>Writing a client is even easier: pass a port number and hostname to net.createConnection() to create a socket to communicate with whatever server is running on that host and listening on that port. Then use that socket to read and write data from and to the server.</p>
<p>The following code demonstrates how to write a server with the â€œnetâ€ module. When the client connects, the server tells a knock-knock joke:</p>
<p>&#x2F;&#x2F; A TCP server that delivers interactive knock-knock jokes on port 6789.<br>&#x2F;&#x2F; (Why is six afraid of seven? Because seven ate nine!)<br>const net &#x3D; require(â€œnetâ€);<br>const readline &#x3D; require(â€œreadlineâ€);</p>
<p>&#x2F;&#x2F; Create a Server object and start listening for connections<br>let server &#x3D; net.createServer();<br>server.listen(6789, () &#x3D;&gt; console.log(â€œDelivering laughs on port 6789â€));</p>
<p>&#x2F;&#x2F; When a client connects, tell them a knock-knock joke.<br>server.on(â€œconnectionâ€, socket &#x3D;&gt; {<br>    tellJoke(socket)<br>        .then(() &#x3D;&gt; socket.end())  &#x2F;&#x2F; When the joke is done, close the socket.<br>        .catch((err) &#x3D;&gt; {<br>            console.error(err);    &#x2F;&#x2F; Log any errors that occur,<br>            socket.end();          &#x2F;&#x2F; but still close the socket!<br>        });<br>});</p>
<p>&#x2F;&#x2F; These are all the jokes we know.<br>const jokes &#x3D; {<br>    â€œBooâ€: â€œDonâ€™t cryâ€¦itâ€™s only a joke!â€,<br>    â€œLettuceâ€: â€œLet us in! Itâ€™s freezing out here!â€,<br>    â€œA little old ladyâ€: â€œWow, I didnâ€™t know you could yodel!â€<br>};</p>
<p>&#x2F;&#x2F; Interactively perform a knock-knock joke over this socket, without blocking.<br>async function tellJoke(socket) {<br>    &#x2F;&#x2F; Pick one of the jokes at random<br>    let randomElement &#x3D; a &#x3D;&gt; a[Math.floor(Math.random() * a.length)];<br>    let who &#x3D; randomElement(Object.keys(jokes));<br>    let punchline &#x3D; jokes[who];</p>
<pre><code>// Use the readline module to read the user&#39;s input one line at a time.
let lineReader = readline.createInterface(&#123;
    input: socket,
    output: socket,
    prompt: &quot;&gt;&gt; &quot;
&#125;);

// A utility function to output a line of text to the client
// and then (by default) display a prompt.
function output(text, prompt=true) &#123;
    socket.write(`$&#123;text&#125;\r\n`);
    if (prompt) lineReader.prompt();
&#125;

// Knock-knock jokes have a call-and-response structure.
// We expect different input from the user at different stages and
// take different action when we get that input at different stages.
let stage = 0;

// Start the knock-knock joke off in the traditional way.
output(&quot;Knock knock!&quot;);

// Now read lines asynchronously from the client until the joke is done.
for await (let inputLine of lineReader) &#123;
    if (stage === 0) &#123;
        if (inputLine.toLowerCase() === &quot;who&#39;s there?&quot;) &#123;
            // If the user gives the right response at stage 0
            // then tell the first part of the joke and go to stage 1.
            output(who);
            stage = 1;
        &#125; else  &#123;
            // Otherwise teach the user how to do knock-knock jokes.
            output(&#39;Please type &quot;Who\&#39;s there?&quot;.&#39;);
        &#125;
    &#125; else if (stage === 1) &#123;
        if (inputLine.toLowerCase() === `$&#123;who.toLowerCase()&#125; who?`) &#123;
            // If the user&#39;s response is correct at stage 1, then
            // deliver the punchline and return since the joke is done.
            output(`$&#123;punchline&#125;`, false);
            return;
        &#125; else &#123;
            // Make the user play along.
            output(`Please type &quot;$&#123;who&#125; who?&quot;.`);
        &#125;
    &#125;
&#125;
</code></pre>
<p>}<br>Simple text-based servers like this do not typically need a custom client. If the nc (â€œnetcatâ€) utility is installed on your system, you can use it to communicate with this server as follows:</p>
<p>$ nc localhost 6789<br>Knock knock!</p>
<blockquote>
<blockquote>
<p>Whoâ€™s there?<br>A little old lady<br>A little old lady who?<br>Wow, I didnâ€™t know you could yodel!<br>On the other hand, writing a custom client for the joke server is easy in Node. We just connect to the server, then pipe the serverâ€™s output to stdout and pipe stdin to the serverâ€™s input:</p>
</blockquote>
</blockquote>
<p>&#x2F;&#x2F; Connect to the joke port (6789) on the server named on the command line<br>let socket &#x3D; require(â€œnetâ€).createConnection(6789, process.argv[2]);<br>socket.pipe(process.stdout);              &#x2F;&#x2F; Pipe data from the socket to stdout<br>process.stdin.pipe(socket);               &#x2F;&#x2F; Pipe data from stdin to the socket<br>socket.on(â€œcloseâ€, () &#x3D;&gt; process.exit()); &#x2F;&#x2F; Quit when the socket closes.<br>In addition to supporting TCP-based servers, Nodeâ€™s â€œnetâ€ module also supports interprocess communication over â€œUnix domain socketsâ€ that are identified by a filesystem path rather than by a port number. We are not going to cover that kind of socket in this chapter, but the Node documentation has details. Other Node features that we donâ€™t have space to cover here include the â€œdgramâ€ module for UDP-based clients and servers and the â€œtlsâ€ module that is to â€œnetâ€ as â€œhttpsâ€ is to â€œhttp.â€ The tls.Server and tls.TLSSocket classes allow the creation of TCP servers (like the knock-knock joke server) that use SSL-encrypted connections like HTTPS servers do.</p>
<h2 id="16-10-Working-with-Child-Processes"><a href="#16-10-Working-with-Child-Processes" class="headerlink" title="16.10 Working with Child Processes"></a>16.10 Working with Child Processes</h2><p>In addition to writing highly concurrent servers, Node also works well for writing scripts that execute other programs. In Node the â€œchild_processâ€ module defines a number of functions for running other programs as child processes. This section demonstrates some of those functions, starting with the simplest and moving to the more complicated.</p>
<h3 id="16-10-1-execSync-and-execFileSync"><a href="#16-10-1-execSync-and-execFileSync" class="headerlink" title="16.10.1 execSync() and execFileSync()"></a>16.10.1 execSync() and execFileSync()</h3><p>The easiest way to run another program is with child_process.execSync(). This function takes the command to run as its first argument. It creates a child process, runs a shell in that process, and uses the shell to execute the command you passed. Then it blocks until the command (and the shell) exit. If the command exits with an error, then execSync() throws an exception. Otherwise, execSync() returns whatever output the command writes to its stdout stream. By default this return value is a buffer, but you can specify an encoding in an optional second argument to get a string instead. If the command writes any output to stderr, that output just gets passed through to the parent processâ€™s stderr stream.</p>
<p>So, for example, if you are writing a script and performance is not a concern, you might use child_process.execSync() to list a directory with a familiar Unix shell command rather than using the fs.readdirSync() function:</p>
<p>const child_process &#x3D; require(â€œchild_processâ€);<br>let listing &#x3D; child_process.execSync(â€œls -l web&#x2F;*.htmlâ€, {encoding: â€œutf8â€});<br>The fact that execSync() invokes a full Unix shell means that the string you pass to it can include multiple semicolon-separated commands, and can take advantage of shell features such as filename wildcards, pipes, and output redirection. This also means that you must be careful to never pass a command to execSync() if any portion of that command is user input or comes from a similar untrusted source. The complex syntax of shell commands can be easily subverted to allow an attacker to run arbitrary code.</p>
<p>If you donâ€™t need the features of a shell, you can avoid the overhead of starting a shell by using child_process.execFileSync(). This function executes a program directly, without invoking a shell. But since no shell is involved, it canâ€™t parse a command line, and you must pass the executable as the first argument and an array of command-line arguments as the second argument:</p>
<p>let listing &#x3D; child_process.execFileSync(â€œlsâ€, [â€œ-lâ€, â€œweb&#x2F;â€œ],<br>                                         {encoding: â€œutf8â€});<br>CHILD PROCESS OPTIONS<br>execSync() and many of the other child_process functions have a second or third optional argument that specifies additional details about how the child process is to run. The encoding property of this object was used earlier to specify that weâ€™d like the command output to be delivered as a string rather than as a buffer. Other important properties that you can specify include the following (note that not all options are available to all child process functions):</p>
<p>cwd specifies the working directory for the child process. If you omit this, then the child process inherits the value of process.cwd().</p>
<p>env specifies the environment variables that the child process will have access to. By default, child processes simply inherit process.env, but you can specify a different object if you want.</p>
<p>input specifies a string or buffer of input data that should be used as the standard input to the child process. This option is only available to the synchronous functions that do not return a ChildProcess object.</p>
<p>maxBuffer specifies the maximum number of bytes of output that will be collected by the exec functions. (It does not apply to spawn() and fork(), which use streams.) If a child process produces more output than this, it will be killed and will exit with an error.</p>
<p>shell specifies the path to a shell executable or true. For child process functions that normally execute a shell command, this option allows you to specify which shell to use. For functions that do not normally use a shell, this option allows you to specify that a shell should be used (by setting the property to true) or to specify exactly which shell to use.</p>
<p>timeout specifies the maximum number of milliseconds that the child process should be allowed to run. If it has not exited before this time elapses, it will be killed and will exit with an error. (This option applies to the exec functions but not to spawn() or fork().)</p>
<p>uid specifies the user ID (a number) under which the program should be run. If the parent process is running in a privileged account, it can use this option to run the child with reduced privileges.</p>
<h3 id="16-10-2-exec-and-execFile"><a href="#16-10-2-exec-and-execFile" class="headerlink" title="16.10.2 exec() and execFile()"></a>16.10.2 exec() and execFile()</h3><p>The execSync() and execFileSync() functions are, as their names indicate, synchronous: they block and do not return until the child process exits. Using these functions is a lot like typing Unix commands in a terminal window: they allow you to run a sequence of commands one at a time. But if youâ€™re writing a program that needs to accomplish a number of tasks, and those tasks donâ€™t depend on each other in any way, then you may want to parallelize them and run multiple commands at the same time. You can do this with the asynchronous functions child_process.exec() and child_process.execFile().</p>
<p>exec() and execFile() are like their synchronous variants except that they return immediately with a ChildProcess object that represents the running child process, and they take an error-first callback as their final argument. The callback is invoked when the child process exits, and it is actually called with three arguments. The first is the error, if any; it will be null if the process terminated normally. The second argument is the collected output that was sent to the childâ€™s standard output stream. And the third argument is any output that was sent to the childâ€™s standard error stream.</p>
<p>The ChildProcess object returned by exec() and execFile() allows you to terminate the child process, and to write data to it (which it can then read from its standard input). Weâ€™ll cover ChildProcess in more detail when we discuss the child_process.spawn() function.</p>
<p>If you plan to execute multiple child processes at the same time, then it may be easiest to use the â€œpromisifiedâ€ version of exec() which returns a Promise object which, if the child process exits without error, resolves to an object with stdout and stderr properties. Here, for example, is a function that takes an array of shell commands as its input and returns a Promise that resolves to the result of all of those commands:</p>
<p>const child_process &#x3D; require(â€œchild_processâ€);<br>const util &#x3D; require(â€œutilâ€);<br>const execP &#x3D; util.promisify(child_process.exec);</p>
<p>function parallelExec(commands) {<br>    &#x2F;&#x2F; Use the array of commands to create an array of Promises<br>    let promises &#x3D; commands.map(command &#x3D;&gt; execP(command, {encoding: â€œutf8â€}));<br>    &#x2F;&#x2F; Return a Promise that will fulfill to an array of the fulfillment<br>    &#x2F;&#x2F; values of each of the individual promises. (Instead of returning objects<br>    &#x2F;&#x2F; with stdout and stderr properties we just return the stdout value.)<br>    return Promise.all(promises)<br>        .then(outputs &#x3D;&gt; outputs.map(out &#x3D;&gt; out.stdout));<br>}</p>
<p>module.exports &#x3D; parallelExec;</p>
<h3 id="16-10-3-spawn"><a href="#16-10-3-spawn" class="headerlink" title="16.10.3 spawn()"></a>16.10.3 spawn()</h3><p>The various exec functions described so farâ€”both synchronous and asynchronousâ€”are designed to be used with child processes that run quickly and do not produce a lot of output. Even the asynchronous exec() and execFile() are nonstreaming: they return the process output in a single batch, only after the process has exited.</p>
<p>The child_process.spawn() function allows you streaming access to the output of the child process, while the process is still running. It also allows you to write data to the child process (which will see that data as input on its standard input stream): this means it is possible to dynamically interact with a child process, sending it input based on the output it generates.</p>
<p>spawn() does not use a shell by default, so you must invoke it like execFile() with the executable to be run and a separate array of command-line arguments to pass to it. spawn() returns a ChildProcess object like execFile() does, but it does not take a callback argument. Instead of using a callback function, you listen to events on the ChildProcess object and on its streams.</p>
<p>The ChildProcess object returned by spawn() is an event emitter. You can listen for the â€œexitâ€ event to be notified when the child process exits. A ChildProcess object also has three stream properties. stdout and stderr are Readable streams: when the child process writes to its stdout and its stderr streams, that output becomes readable through the ChildProcess streams. Note the inversion of the names here. In the child process, â€œstdoutâ€ is a Writable output stream, but in the parent process, the stdout property of a ChildProcess object is a Readable input stream.</p>
<p>Similarly, the stdin property of the ChildProcess object is a Writeable stream: anything you write to this stream becomes available to the child process on its standard input.</p>
<p>The ChildProcess object also defines a pid property that specifies the process id of the child. And it defines a kill() method that you can use to terminate a child process.</p>
<h3 id="16-10-4-fork"><a href="#16-10-4-fork" class="headerlink" title="16.10.4 fork()"></a>16.10.4 fork()</h3><p>child_process.fork() is a specialized function for running a module of JavaScript code in a child Node process. fork() expects the same arguments as spawn(), but the first argument should specify the path to a file of JavaScript code instead of an executable binary file.</p>
<p>A child process created with fork() can communicate with the parent process via its standard input and standard output streams, as described in the previous section for spawn(). But in addition, fork() enables another, much easier, communication channel between the parent and child processes.</p>
<p>When you create a child process with fork(), you can use the send() method of the returned ChildProcess object to send a copy of an object to the child process. And you can listen for the â€œmessageâ€ event on the ChildProcess to receive messages from the child. The code running in the child process can use process.send() to send a message to the parent and can listen for â€œmessageâ€ events on process to receive messages from the parent.</p>
<p>Here, for example, is some code that uses fork() to create a child process, then sends that child a message and waits for a response:</p>
<p>const child_process &#x3D; require(â€œchild_processâ€);</p>
<p>&#x2F;&#x2F; Start a new node process running the code in child.js in our directory<br>let child &#x3D; child_process.fork(<code>$&#123;__dirname&#125;/child.js</code>);</p>
<p>&#x2F;&#x2F; Send a message to the child<br>child.send({x: 4, y: 3});</p>
<p>&#x2F;&#x2F; Print the childâ€™s response when it arrives.<br>child.on(â€œmessageâ€, message &#x3D;&gt; {<br>    console.log(message.hypotenuse); &#x2F;&#x2F; This should print â€œ5â€<br>    &#x2F;&#x2F; Since we only send one message we only expect one response.<br>    &#x2F;&#x2F; After we receive it we call disconnect() to terminate the connection<br>    &#x2F;&#x2F; between parent and child. This allows both processes to exit cleanly.<br>    child.disconnect();<br>});<br>And here is the code that runs in the child process:</p>
<p>&#x2F;&#x2F; Wait for messages from our parent process<br>process.on(â€œmessageâ€, message &#x3D;&gt; {<br>    &#x2F;&#x2F; When we receive one, do a calculation and send the result<br>    &#x2F;&#x2F; back to the parent.<br>    process.send({hypotenuse: Math.hypot(message.x, message.y)});<br>});<br>Starting child processes is an expensive operation, and the child process would have to be doing orders of magnitude more computation before it would make sense to use fork() and interprocess communication in this way. If you are writing a program that needs to be very responsive to incoming events and also needs to perform time-consuming computations, then you might consider using a separate child process to perform the computations so that they donâ€™t block the event loop and reduce the responsiveness of the parent process. (Though a threadâ€”see Â§16.11â€”may be a better choice than a child process in this scenario.)</p>
<p>The first argument to send() will be serialized with JSON.stringify() and deserialized in the child process with JSON.parse(), so you should only include values that are supported by the JSON format. send() has a special second argument, however, that allows you to transfer Socket and Server objects (from the â€œnetâ€ module) to a child process. Network servers tend to be IO-bound rather than compute-bound, but if you have written a server that needs to do more computation than a single CPU can handle, and if youâ€™re running that server on a machine with multiple CPUs, then you could use fork() to create multiple child processes for handling requests. In the parent process, you might listen for â€œconnectionâ€ events on your Server object, then get the Socket object from that â€œconnectionâ€ event and send() itâ€”using the special second argumentâ€”to one of the child processes to be handled. (Note that this is an unlikely solution to an uncommon scenario. Rather than writing a server that forks child processes, it is probably simpler to keep your server single-threaded and deploy multiple instances of it in production to handle the load.)</p>
<h2 id="16-11-Worker-Threads"><a href="#16-11-Worker-Threads" class="headerlink" title="16.11 Worker Threads"></a>16.11 Worker Threads</h2><p>As explained at the beginning of this chapter, Nodeâ€™s concurrency model is single-threaded and event-based. But in version 10 and later, Node does allow true multithreaded programming, with an API that closely mirrors the Web Workers API defined by web browsers (Â§15.13). Multithreaded programming has a well-deserved reputation for being difficult. This is almost entirely because of the need to carefully synchronize access by threads to shared memory. But JavaScript threads (in both Node and browsers) do not share memory by default, so the dangers and difficulties of using threads do not apply to these â€œworkersâ€ in JavaScript.</p>
<p>Instead of using shared memory, JavaScriptâ€™s worker threads communicate by message passing. The main thread can send a message to a worker thread by calling the postMessage() method of the Worker object that represents that thread. The worker thread can receive messages from its parent by listening for â€œmessageâ€ events. And workers can send messages to the main thread with their own version of postMessage(), which the parent can receive with its own â€œmessageâ€ event handler. The example code will make it clear how this works.</p>
<p>There are three reasons why you might want to use worker threads in a Node application:</p>
<p>If your application actually needs to do more computation than one CPU core can handle, then threads allow you to distribute work across the multiple cores, which have become commonplace on computers today. If youâ€™re doing scientific computing or machine learning or graphics processing in Node, then you may want to use threads simply to throw more computing power at your problem.</p>
<p>Even if your application is not using the full power of one CPU, you may still want to use threads to maintain the responsiveness of the main thread. Consider a server that handles large but relatively infrequent requests. Suppose it gets only one request a second, but needs to spend about half a second of (blocking CPU-bound) computation to process each request. On average, it will be idle 50% of the time. But when two requests arrive within a few milliseconds of each other, the server will not even be able to begin a response to the second request until the computation of the first response is complete. Instead, if the server uses a worker thread to perform the computation, the server can begin the response to both requests immediately and provide a better experience for the serverâ€™s clients. Assuming the server has more than one CPU core, it can also compute the body of both responses in parallel, but even if there is only a single core, using workers still improves the responsiveness.</p>
<p>In general, workers allow us to turn blocking synchronous operations into nonblocking asynchronous operations. If you are writing a program that depends on legacy code that is unavoidably synchronous, you may be able to use workers to avoid blocking when you need to call that legacy code.</p>
<p>Worker threads are not nearly as heavyweight as child processes, but they are not lightweight. It does not generally make sense to create a worker unless you have significant work for it to do. And, generally speaking, if your program is not CPU-bound and is not having responsiveness problems, then you probably do not need worker threads.</p>
<h3 id="16-11-1-Creating-Workers-and-Passing-Messages"><a href="#16-11-1-Creating-Workers-and-Passing-Messages" class="headerlink" title="16.11.1 Creating Workers and Passing Messages"></a>16.11.1 Creating Workers and Passing Messages</h3><p>The Node module that defines workers is known as â€œworker_threads.â€ In this section weâ€™ll refer to it with the identifier threads:</p>
<p>const threads &#x3D; require(â€œworker_threadsâ€);<br>This module defines a Worker class to represent a worker thread, and you can create a new thread with the threads.Worker() constructor. The following code demonstrates using this constructor to create a worker, and shows how to pass messages from main thread to worker and from worker to main thread. It also demonstrates a trick that allows you to put the main thread code and the worker thread code in the same file.2</p>
<p>const threads &#x3D; require(â€œworker_threadsâ€);</p>
<p>&#x2F;&#x2F; The worker_threads module exports the boolean isMainThread property.<br>&#x2F;&#x2F; This property is true when Node is running the main thread and it is<br>&#x2F;&#x2F; false when Node is running a worker. We can use this fact to implement<br>&#x2F;&#x2F; the main and worker threads in the same file.<br>if (threads.isMainThread) {<br>    &#x2F;&#x2F; If weâ€™re running in the main thread, then all we do is export<br>    &#x2F;&#x2F; a function. Instead of performing a computationally intensive<br>    &#x2F;&#x2F; task on the main thread, this function passes the task to a worker<br>    &#x2F;&#x2F; and returns a Promise that will resolve when the worker is done.<br>    module.exports &#x3D; function reticulateSplines(splines) {<br>        return new Promise((resolve,reject) &#x3D;&gt; {<br>            &#x2F;&#x2F; Create a worker that loads and runs this same file of code.<br>            &#x2F;&#x2F; Note the use of the special __filename variable.<br>            let reticulator &#x3D; new threads.Worker(__filename);</p>
<pre><code>        // Pass a copy of the splines array to the worker
        reticulator.postMessage(splines);

        // And then resolve or reject the Promise when we get
        // a message or error from the worker.
        reticulator.on(&quot;message&quot;, resolve);
        reticulator.on(&quot;error&quot;, reject);
    &#125;);
&#125;;
</code></pre>
<p>} else {<br>    &#x2F;&#x2F; If we get here, it means weâ€™re in the worker, so we register a<br>    &#x2F;&#x2F; handler to get messages from the main thread. This worker is designed<br>    &#x2F;&#x2F; to only receive a single message, so we register the event handler<br>    &#x2F;&#x2F; with once() instead of on(). This allows the worker to exit naturally<br>    &#x2F;&#x2F; when its work is complete.<br>    threads.parentPort.once(â€œmessageâ€, splines &#x3D;&gt; {<br>        &#x2F;&#x2F; When we get the splines from the parent thread, loop<br>        &#x2F;&#x2F; through them and reticulate all of them.<br>        for(let spline of splines) {<br>            &#x2F;&#x2F; For the sake of example, assume that spline objects usually<br>            &#x2F;&#x2F; have a reticulate() method that does a lot of computation.<br>            spline.reticulate ? spline.reticulate() : spline.reticulated &#x3D; true;<br>        }</p>
<pre><code>    // When all the splines have (finally!) been reticulated
    // pass a copy back to the main thread.
    threads.parentPort.postMessage(splines);
&#125;);
</code></pre>
<p>}<br>The first argument to the Worker() constructor is the path to a file of JavaScript code that is to run in the thread. In the preceding code, we used the predefined __filename identifier to create a worker that loads and runs the same file as the main thread. In general, though, you will be passing a file path. Note that if you specify a relative path, it is relative to process.cwd(), not relative to the currently running module. If you want a path relative to the current module, use something like path.resolve(__dirname, â€˜workers&#x2F;reticulator.jsâ€™).</p>
<p>The Worker() constructor can also accept an object as its second argument, and the properties of this object provide optional configuration for the worker. Weâ€™ll cover a number of these options later, but for now note that if you pass {eval: true} as the second argument, then the first argument to Worker() is interpreted as a string of JavaScript code to be evaluated instead of a filename:</p>
<p>new threads.Worker(<code>    const threads = require(&quot;worker_threads&quot;);     threads.parentPort.postMessage(threads.isMainThread);</code>, {eval: true}).on(â€œmessageâ€, console.log);  &#x2F;&#x2F; This will print â€œfalseâ€<br>Node makes a copy of the object passed to postMessage() rather than sharing it directly with the worker thread. This prevents the worker thread and the main thread from sharing memory. You might expect that this copying would be done with JSON.stringify() and JSON.parse() (Â§11.6). But in fact, Node borrows a more robust technique known as the structured clone algorithm from web browsers.</p>
<p>The structured clone algorithm enables serialization of most JavaScript types, including Map, Set, Date, and RegExp objects and typed arrays, but it cannot, in general, copy types defined by the Node host environment, such as sockets and streams. Note, however, that Buffer objects are partially supported: if you pass a Buffer to postMessage() it will be received as a Uint8Array, and can be converted back into a Buffer with Buffer.from(). Read more about the structured clone algorithm in â€œThe Structured Clone Algorithmâ€.</p>
<h3 id="16-11-2-The-Worker-Execution-Environment"><a href="#16-11-2-The-Worker-Execution-Environment" class="headerlink" title="16.11.2 The Worker Execution Environment"></a>16.11.2 The Worker Execution Environment</h3><p>For the most part, JavaScript code in a Node worker thread runs just like it would in Nodeâ€™s main thread. There are a few differences that you should be aware of, and some of these differences involve properties of the optional second argument to the Worker() constructor:</p>
<p>As weâ€™ve seen, threads.isMainThread is true in the main thread but is always false in any worker thread.</p>
<p>In a worker thread, you can use threads.parentPort.postMessage() to send a message to the parent thread and threads.parentPort.on to register event handlers for messages from the parent thread. In the main thread, threads.parentPort is always null.</p>
<p>In a worker thread, threads.workerData is set to a copy of the workerData property of the second argument to the Worker() constructor. In the main thread, this property is always null. You can use this workerData property to pass an initial message to the worker that will be available as soon as it starts so that the worker does not have to wait for a â€œmessageâ€ event before it can start doing work.</p>
<p>By default, process.env in a worker thread is a copy of process.env in the parent thread. But the parent thread can specify a custom set of environment variables by setting the env property of the second argument to the Worker() constructor. As a special (and potentially dangerous) case, the parent thread can set the env property to threads.SHARE_ENV, which will cause the two threads to share a single set of environment variables so that a change in one thread is visible in the other.</p>
<p>By default, the process.stdin stream in a worker never has any readable data on it. You can change this default by passing stdin: true in the second argument to the Worker() constructor. If you do that, then the stdin property of the Worker object is a Writable stream. Any data that the parent writes to worker.stdin becomes readable on process.stdin in the worker.</p>
<p>By default, the process.stdout and process.stderr streams in the worker are simply piped to the corresponding streams in the parent thread. This means, for example, that console.log() and console.error() produce output in exactly the same way in a worker thread as they do in the main thread. You can override this default by passing stdout:true or stderr:true in the second argument to the Worker() constructor. If you do this, then any output the worker writes to those streams becomes readable by the parent thread on the worker.stdout and worker.stderr threads. (There is a potentially confusing inversion of stream directions here, and we saw the same thing with with child processes earlier in the chapter: the output streams of a worker thread are input streams for the parent thread, and the input stream of a worker is an output stream for the parent.)</p>
<p>If a worker thread calls process.exit(), only the thread exits, not the entire process.</p>
<p>Worker threads are not allowed to change shared state of the process they are part of. Functions like process.chdir() and process.setuid() will throw exceptions when invoked from a worker.</p>
<p>Operating system signals (like SIGINT and SIGTERM) are only delivered to the main thread; they cannot be received or handled in worker threads.</p>
<h3 id="16-11-3-Communication-Channels-and-MessagePorts"><a href="#16-11-3-Communication-Channels-and-MessagePorts" class="headerlink" title="16.11.3 Communication Channels and MessagePorts"></a>16.11.3 Communication Channels and MessagePorts</h3><p>When a new worker thread is created, a communication channel is created along with it that allows messages to be passed back and forth between the worker and the parent thread. As weâ€™ve seen, the worker thread uses threads.parentPort to send and receive messages to and from the parent thread, and the parent thread uses the Worker object to send and receive messages to and from the worker thread.</p>
<p>The worker thread API also allows the creation of custom communication channels using the MessageChannel API defined by web browsers and covered in Â§15.13.5. If you have read that section, much of what follows will sound familiar to you.</p>
<p>Suppose a worker needs to handle two different kinds of messages sent by two different modules in the main thread. These two different modules could both share the default channel and send messages with worker.postMessage(), but it would be cleaner if each module has its own private channel for sending messages to the worker. Or consider the case where the main thread creates two independent workers. A custom communication channel can allow the two workers to communicate directly with each other instead of having to send all their messages via the parent.</p>
<p>Create a new message channel with the MessageChannel() constructor. A MessageChannel object has two properties, named port1 and port2. These properties refer to a pair of MessagePort objects. Calling postMessage() on one of the ports will cause a â€œmessageâ€ event to be generated on the other with a structured clone of the Message object:</p>
<p>const threads &#x3D; require(â€œworker_threadsâ€);<br>let channel &#x3D; new threads.MessageChannel();<br>channel.port2.on(â€œmessageâ€, console.log);  &#x2F;&#x2F; Log any messages we receive<br>channel.port1.postMessage(â€œhelloâ€);        &#x2F;&#x2F; Will cause â€œhelloâ€ to be printed<br>You can also call close() on either port to break the connection between the two ports and to signal that no more messages will be exchanged. When close() is called on either port, a â€œcloseâ€ event is delivered to both ports.</p>
<p>Note that the code example above creates a pair of MessagePort objects and then uses those objects to transmit a message within the main thread. In order to use custom communication channels with workers, we must transfer one of the two ports from the thread in which it is created to the thread in which it will be used. The next section explains how to do this.</p>
<h3 id="16-11-4-Transferring-MessagePorts-and-Typed-Arrays"><a href="#16-11-4-Transferring-MessagePorts-and-Typed-Arrays" class="headerlink" title="16.11.4 Transferring MessagePorts and Typed Arrays"></a>16.11.4 Transferring MessagePorts and Typed Arrays</h3><p>The postMessage() function uses the structured clone algorithm, and as weâ€™ve noted, it cannot copy objects like SSockets and Streams. It can handle MessagePort objects, but only as a special case using a special technique. The postMessage() method (of a Worker object, of threads.parentPort, or of any MessagePort object) takes an optional second argument. This argument (called transferList) is an array of objects that are to be transferred between threads rather than being copied.</p>
<p>A MessagePort object cannot be copied by the structured clone algorithm, but it can be transferred. If the first argument to postMessage() has included one or more MessagePorts (nested arbitrarily deeply within the Message object), then those MessagePort objects must also appear as members of the array passed as the second argument. Doing this tells Node that it does not need to make a copy of the MessagePort, and can instead just give the existing object to the other thread. The key thing to understand, however, about transferring values between threads is that once a value is transferred, it can no longer be used in the thread that called postMessage().</p>
<p>Here is how you might create a new MessageChannel and transfer one of its MessagePorts to a worker:</p>
<p>&#x2F;&#x2F; Create a custom communication channel<br>const threads &#x3D; require(â€œworker_threadsâ€);<br>let channel &#x3D; new threads.MessageChannel();</p>
<p>&#x2F;&#x2F; Use the workerâ€™s default channel to transfer one end of the new<br>&#x2F;&#x2F; channel to the worker. Assume that when the worker receives this<br>&#x2F;&#x2F; message it immediately begins to listen for messages on the new channel.<br>worker.postMessage({ command: â€œchangeChannelâ€, data: channel.port1 },<br>                   [ channel.port1 ]);</p>
<p>&#x2F;&#x2F; Now send a message to the worker using our end of the custom channel<br>channel.port2.postMessage(â€œCan you hear me now?â€);</p>
<p>&#x2F;&#x2F; And listen for responses from the worker as well<br>channel.port2.on(â€œmessageâ€, handleMessagesFromWorker);<br>MessagePort objects are not the only ones that can be transferred. If you call postMessage() with a typed array as the message (or with a message that contains one or more typed arrays nested arbitrarily deep within the message), that typed array (or those typed arrays) will simply be copied by the structured clone algorithm. But typed arrays can be large; for example, if you are using a worker thread to do image processing on millions of pixels. So for efficiency, postMessage() also gives us the option to transfer typed arrays rather than copying them. (Threads share memory by default. Worker threads in JavaScript generally avoid shared memory, but when we allow this kind of controlled transfer, it can be done very efficiently.) What makes this safe is that when a typed array is transferred to another thread, it becomes unusable in the thread that transferred it. In the image-processing scenario, the main thread could transfer the pixels of an image to the worker thread, and then the worker thread could transfer the processed pixels back to the main thread when it was done. The memory would not need to be copied, but it would never be accessible by two threads at once.</p>
<p>To transfer a typed array instead of copying it, include the ArrayBuffer that backs the array in the second argument to postMessage():</p>
<p>let pixels &#x3D; new Uint32Array(1024*1024);  &#x2F;&#x2F; 4 megabytes of memory</p>
<p>&#x2F;&#x2F; Assume we read some data into this typed array, and then transfer the<br>&#x2F;&#x2F; pixels to a worker without copying. Note that we donâ€™t put the array<br>&#x2F;&#x2F; itself in the transfer list, but the arrayâ€™s Buffer object instead.<br>worker.postMessage(pixels, [ pixels.buffer ]);<br>As with transferred MessagePorts, a transferred typed array becomes unusable once transferred. No exceptions are thrown if you attempt to use a MessagePort or typed array that has been transferred; these objects simply stop doing anything when you interact with them.</p>
<h3 id="16-11-5-Sharing-Typed-Arrays-Between-Threads"><a href="#16-11-5-Sharing-Typed-Arrays-Between-Threads" class="headerlink" title="16.11.5 Sharing Typed Arrays Between Threads"></a>16.11.5 Sharing Typed Arrays Between Threads</h3><p>In addition to transferring typed arrays between threads, it is actually possible to share a typed array between threads. Simply create a SharedArrayBuffer of the desired size and then use that buffer to create a typed array. When a typed array that is backed by a SharedArrayBuffer is passed via postMessage(), the underlying memory will be shared between the threads. You should not include the shared buffer in the second argument to postMessage() in this case.</p>
<p>You really should not do this, however, because JavaScript was never designed with thread safety in mind and multithreaded programming is very difficult to get right. (And this is why SharedArrayBuffer was not covered in Â§11.2: it is a niche feature that is difficult to get right.) Even the simple ++ operator is not thread-safe because it needs to read a value, increment it, and write it back. If two threads are incrementing a value at the same time, it will often only be incremented once, as the following code demonstrates:</p>
<p>const threads &#x3D; require(â€œworker_threadsâ€);</p>
<p>if (threads.isMainThread) {<br>    &#x2F;&#x2F; In the main thread, we create a shared typed array with<br>    &#x2F;&#x2F; one element. Both threads will be able to read and write<br>    &#x2F;&#x2F; sharedArray[0] at the same time.<br>    let sharedBuffer &#x3D; new SharedArrayBuffer(4);<br>    let sharedArray &#x3D; new Int32Array(sharedBuffer);</p>
<pre><code>// Now create a worker thread, passing the shared array to it with
// as its initial workerData value so we don&#39;t have to bother with
// sending and receiving a message
let worker = new threads.Worker(__filename, &#123; workerData: sharedArray &#125;);

// Wait for the worker to start running and then increment the
// shared integer 10 million times.
worker.on(&quot;online&quot;, () =&gt; &#123;
    for(let i = 0; i &lt; 10_000_000; i++) sharedArray[0]++;

    // Once we&#39;re done with our increments, we start listening for
    // message events so we know when the worker is done.
    worker.on(&quot;message&quot;, () =&gt; &#123;
        // Although the shared integer has been incremented
        // 20 million times, its value will generally be much less.
        // On my computer the final value is typically under 12 million.
        console.log(sharedArray[0]);
    &#125;);
&#125;);
</code></pre>
<p>} else {<br>    &#x2F;&#x2F; In the worker thread, we get the shared array from workerData<br>    &#x2F;&#x2F; and then increment it 10 million times.<br>    let sharedArray &#x3D; threads.workerData;<br>    for(let i &#x3D; 0; i &lt; 10_000_000; i++) sharedArray[0]++;<br>    &#x2F;&#x2F; When weâ€™re done incrementing, let the main thread know<br>    threads.parentPort.postMessage(â€œdoneâ€);<br>}<br>One scenario in which it might be reasonable to use a SharedArrayBuffer is when the two threads operate on entirely separate sections of the shared memory. You might enforce this by creating two typed arrays that serve as views of nonoverlapping regions of the shared buffer, and then have your two threads use those two separate typed arrays. A parallel merge sort could be done like this: one thread sorts the bottom half of an array and the other thread sorts the top half, for example. Or some kinds of image-processing algorithms are also suitable for this approach: multiple threads working on disjoint regions of the image.</p>
<p>If you really must allow multiple threads to access the same region of a shared array, you can take one step toward thread safety with the functions defined by the Atomics object. Atomics was added to JavaScript when SharedArrayBuffer was to define atomic operations on the elements of a shared array. For example, the Atomics.add() function reads the specified element of a shared array, adds a specified value to it, and writes the sum back into the array. It does this atomically as if it was a single operation, and ensures that no other thread can read or write the value while the operation is taking place. Atomics.add() allows us to rewrite the parallel increment code we just looked at and get the correct result of 20 million increments of a shared array element:</p>
<p>const threads &#x3D; require(â€œworker_threadsâ€);</p>
<p>if (threads.isMainThread) {<br>    let sharedBuffer &#x3D; new SharedArrayBuffer(4);<br>    let sharedArray &#x3D; new Int32Array(sharedBuffer);<br>    let worker &#x3D; new threads.Worker(__filename, { workerData: sharedArray });</p>
<pre><code>worker.on(&quot;online&quot;, () =&gt; &#123;
    for(let i = 0; i &lt; 10_000_000; i++) &#123;
        Atomics.add(sharedArray, 0, 1);  // Threadsafe atomic increment
    &#125;

    worker.on(&quot;message&quot;, (message) =&gt; &#123;
        // When both threads are done, use a threadsafe function
        // to read the shared array and confirm that it has the
        // expected value of 20,000,000.
        console.log(Atomics.load(sharedArray, 0));
    &#125;);
&#125;);
</code></pre>
<p>} else {<br>    let sharedArray &#x3D; threads.workerData;<br>    for(let i &#x3D; 0; i &lt; 10_000_000; i++) {<br>        Atomics.add(sharedArray, 0, 1);      &#x2F;&#x2F; Threadsafe atomic increment<br>    }<br>    threads.parentPort.postMessage(â€œdoneâ€);<br>}<br>This new version of the code correctly prints the number 20,000,000. But it is about nine times slower than the incorrect code it replaces. It would be much simpler and much faster to just do all 20 million increments in one thread. Also note that atomic operations may be able to ensure thread safety for image-processing algorithms for which each array element is a value entirely independent of all other values. But in most real-world programs, multiple array elements are often related to one another and some kind of higher-level thread synchronization is required. The low-level Atomics.wait() and Atomics.notify() function can help with this, but a discussion of their use is out of scope for this book.</p>
<h2 id="16-12-Summary"><a href="#16-12-Summary" class="headerlink" title="16.12 Summary"></a>16.12 Summary</h2><p>Although JavaScript was created to run in web browsers, Node has made JavaScript into a general-purpose programming language. It is particularly popular for implementing web servers, but its deep bindings to the operating system mean that it is also a good alternative to shell scripts.</p>
<p>The most important topics covered in this long chapter include:</p>
<p>Nodeâ€™s asynchronous-by-default APIs and its single-threaded, callback, and event-based style of concurrency.</p>
<p>Nodeâ€™s fundamental datatypes, buffers, and streams.</p>
<p>Nodeâ€™s â€œfsâ€ and â€œpathâ€ modules for working with the filesystem.</p>
<p>Nodeâ€™s â€œhttpâ€ and â€œhttpsâ€ modules for writing HTTP clients and servers.</p>
<p>Nodeâ€™s â€œnetâ€ module for writing non-HTTP clients and servers.</p>
<p>Nodeâ€™s â€œchild_processâ€ module for creating and communicating with child processes.</p>
<p>Nodeâ€™s â€œworker_threadsâ€ module for true multithreaded programming using message-passing instead of shared memory.</p>
<p>1 Node defines a fs.copyFile() function that you would actually use in practice.</p>
<p>2 It is often cleaner and simpler to define the worker code in a separate file. But this trick of having two threads run different sections of the same file blew my mind when I first encountered it for the Unix fork() system call. And I think it is worth demonstrating this technique simply for its strange elegance.</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="å¤´åƒ"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/63232b7d91d22.jpg" title="å¤´åƒ" alt="å¤´åƒ"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/63232b7d91d22.jpg" title="å¤´åƒ" alt="å¤´åƒ"></a><div class="post-copyright__author_name">Jack hou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="è¯¥æ–‡ç« ä¸ºåŸåˆ›æ–‡ç« ï¼Œæ³¨æ„ç‰ˆæƒåè®®" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch16/">åŸåˆ›</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch16/')">ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="èµèµä½œè€…"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>æ‰“èµä½œè€…</div><div class="reward-main"><div class="reward-all"><span class="reward-title">æ„Ÿè°¢ä½ èµäºˆæˆ‘å‰è¿›çš„åŠ›é‡</span><ul class="reward-group"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">èµèµè€…åå•</div><div class="reward-dec">å› ä¸ºä½ ä»¬çš„æ”¯æŒè®©æˆ‘æ„è¯†åˆ°å†™æ–‡ç« çš„ä»·å€¼ğŸ™</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wechat/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>è¿è¥æ¨¡å¼ä¸è´£ä»»</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="ä½¿ç”¨æ‰‹æœºè®¿é—®è¿™ç¯‡æ–‡ç« "><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch16/"></div><div class="reward-dec">ä½¿ç”¨æ‰‹æœºè®¿é—®è¿™ç¯‡æ–‡ç« </div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=ç¬¬16ç«  æœåŠ¡å™¨ç«¯ JavaScript&amp;url=http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch16/&amp;pic=https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="å¤åˆ¶é“¾æ¥" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> è®¸å¯åè®®ã€‚è½¬è½½è¯·æ³¨æ˜æ¥è‡ª <a href="http://www.houyanbin.com" target="_blank">Jackhou Blog</a>ï¼</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>ã€ŠJavaScriptæƒå¨æŒ‡å—ã€‹<span class="tagsPageCount">17</span></a><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">17</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch17/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">ä¸Šä¸€ç¯‡</div><div class="prev_info">ç¬¬17ç«  JavaScript å·¥å…·å’Œæ‰©å±•</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch15/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">ä¸‹ä¸€ç¯‡</div><div class="next_info">ç¬¬15ç«  Web æµè§ˆå™¨ä¸­çš„ JavaScript</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>å–œæ¬¢è¿™ç¯‡æ–‡ç« çš„äººä¹Ÿçœ‹äº†</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch1/" title="ç¬¬1ç«  JavaScript æ¦‚è¿°"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">ç¬¬1ç«  JavaScript æ¦‚è¿°</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch12/" title="ç¬¬12ç«  è¿­ä»£å™¨å’Œç”Ÿæˆå™¨"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">ç¬¬12ç«  è¿­ä»£å™¨å’Œç”Ÿæˆå™¨</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch10/" title="ç¬¬10ç«  æ¨¡å—"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">ç¬¬10ç«  æ¨¡å—</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch14/" title="ç¬¬14ç«  å…ƒç¼–ç¨‹"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">ç¬¬14ç«  å…ƒç¼–ç¨‹</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch11/" title="ç¬¬11ç«  JavaScript æ ‡å‡†åº“"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">ç¬¬11ç«  JavaScript æ ‡å‡†åº“</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/" title="ç¬¬13ç«  å¼‚æ­¥ JavaScript"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">ç¬¬13ç«  å¼‚æ­¥ JavaScript</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> è¯„è®º</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">åŒ¿åè¯„è®º</a><a href="/privacy" style="margin-left: 4px">éšç§æ”¿ç­–</a></div><div class="comment-tips" id="comment-tips"><span>âœ… ä½ æ— éœ€åˆ é™¤ç©ºè¡Œï¼Œç›´æ¥è¯„è®ºä»¥è·å–æœ€ä½³å±•ç¤ºæ•ˆæœ</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/63232b7d91d22.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">Hiï¼Œè¿™æ˜¯æˆ‘çš„åšå®¢ç½‘ç«™ï¼Œæ¬¢è¿ä½ èƒ½åˆ°è®¿~</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">æˆ‘ä¼šåœ¨è¿™é‡Œåˆ†äº«æˆ‘çš„<b style="color:#fff">æŠ€æœ¯çŸ¥è¯†</b>ã€<b style="color:#fff">æ—¥å¸¸ç”Ÿæ´»</b>å’Œ<b style="color:#fff">äººç”Ÿç»éªŒã€‚</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Jack hou</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Hou-yanbin" target="_blank" title="Github"><i class="fab fa-github faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/478589474" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=jackhou921@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wxgzh1.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>æ–‡ç« ç›®å½•</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#INSTALLING-NODE"><span class="toc-text">INSTALLING NODE</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-Node-Programming-Basics"><span class="toc-text">16.1 Node Programming Basics</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-1-Console-Output"><span class="toc-text">16.1.1 Console Output</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-2-Command-Line-Arguments-and-Environment-Variables"><span class="toc-text">16.1.2 Command-Line Arguments and Environment Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-3-Program-Life-Cycle"><span class="toc-text">16.1.3 Program Life Cycle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-4-Node-Modules"><span class="toc-text">16.1.4 Node Modules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-5-The-Node-Package-Manager"><span class="toc-text">16.1.5 The Node Package Manager</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-Node-Is-Asynchronous-by-Default"><span class="toc-text">16.2 Node Is Asynchronous by Default</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-Buffers"><span class="toc-text">16.3 Buffers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-4-Events-and-EventEmitter"><span class="toc-text">16.4 Events and EventEmitter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-5-Streams"><span class="toc-text">16.5 Streams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-1-Pipes"><span class="toc-text">16.5.1 Pipes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-2-Asynchronous-Iteration"><span class="toc-text">16.5.2 Asynchronous Iteration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-3-Writing-to-Streams-and-Handling-Backpressure"><span class="toc-text">16.5.3 Writing to Streams and Handling Backpressure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-4-Reading-Streams-with-Events"><span class="toc-text">16.5.4 Reading Streams with Events</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-6-Process-CPU-and-Operating-System-Details"><span class="toc-text">16.6 Process, CPU, and Operating System Details</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-7-Working-with-Files"><span class="toc-text">16.7 Working with Files</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-1-Paths-File-Descriptors-and-FileHandles"><span class="toc-text">16.7.1 Paths, File Descriptors, and FileHandles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-2-Reading-Files"><span class="toc-text">16.7.2 Reading Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-3-Writing-Files"><span class="toc-text">16.7.3 Writing Files</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-4-File-Operations"><span class="toc-text">16.7.4 File Operations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-5-File-Metadata"><span class="toc-text">16.7.5 File Metadata</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-7-6-Working-with-Directories"><span class="toc-text">16.7.6 Working with Directories</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-8-HTTP-Clients-and-Servers"><span class="toc-text">16.8 HTTP Clients and Servers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-9-Non-HTTP-Network-Servers-and-Clients"><span class="toc-text">16.9 Non-HTTP Network Servers and Clients</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-10-Working-with-Child-Processes"><span class="toc-text">16.10 Working with Child Processes</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-10-1-execSync-and-execFileSync"><span class="toc-text">16.10.1 execSync() and execFileSync()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-10-2-exec-and-execFile"><span class="toc-text">16.10.2 exec() and execFile()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-10-3-spawn"><span class="toc-text">16.10.3 spawn()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-10-4-fork"><span class="toc-text">16.10.4 fork()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-11-Worker-Threads"><span class="toc-text">16.11 Worker Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-11-1-Creating-Workers-and-Passing-Messages"><span class="toc-text">16.11.1 Creating Workers and Passing Messages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-11-2-The-Worker-Execution-Environment"><span class="toc-text">16.11.2 The Worker Execution Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-11-3-Communication-Channels-and-MessagePorts"><span class="toc-text">16.11.3 Communication Channels and MessagePorts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-11-4-Transferring-MessagePorts-and-Typed-Arrays"><span class="toc-text">16.11.4 Transferring MessagePorts and Typed Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-11-5-Sharing-Typed-Arrays-Between-Threads"><span class="toc-text">16.11.5 Sharing Typed Arrays Between Threads</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-12-Summary"><span class="toc-text">16.12 Summary</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>æœ€è¿‘å‘å¸ƒ</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="åšæƒ…äººçœŸçš„æ²¡æœ‰å¥½ä¸‹åœºå—ï¼Ÿ"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="åšæƒ…äººçœŸçš„æ²¡æœ‰å¥½ä¸‹åœºå—ï¼Ÿ"/></a><div class="content"><a class="title" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="åšæƒ…äººçœŸçš„æ²¡æœ‰å¥½ä¸‹åœºå—ï¼Ÿ">åšæƒ…äººçœŸçš„æ²¡æœ‰å¥½ä¸‹åœºå—ï¼Ÿ</a><time datetime="2023-08-14T16:00:00.000Z" title="å‘è¡¨äº 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="ä¸çˆ±å‰è¡Œ"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ä¸çˆ±å‰è¡Œ"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="ä¸çˆ±å‰è¡Œ">ä¸çˆ±å‰è¡Œ</a><time datetime="2023-07-29T16:00:00.000Z" title="å‘è¡¨äº 2023-07-30 00:00:00">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="ç§Ÿæˆ¿æ—¶å…‰"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ç§Ÿæˆ¿æ—¶å…‰"/></a><div class="content"><a class="title" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="ç§Ÿæˆ¿æ—¶å…‰">ç§Ÿæˆ¿æ—¶å…‰</a><time datetime="2023-07-21T16:00:00.000Z" title="å‘è¡¨äº 2023-07-22 00:00:00">2023-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="æ•…å®«è®°"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="æ•…å®«è®°"/></a><div class="content"><a class="title" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="æ•…å®«è®°">æ•…å®«è®°</a><time datetime="2023-06-10T16:00:00.000Z" title="å‘è¡¨äº 2023-06-11 00:00:00">2023-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="ä¿¡æ¯æ”¶é›†é“é“ä¹‹å¤–ç½‘ä¿¡æ¯æ”¶é›†"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ä¿¡æ¯æ”¶é›†é“é“ä¹‹å¤–ç½‘ä¿¡æ¯æ”¶é›†"/></a><div class="content"><a class="title" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="ä¿¡æ¯æ”¶é›†é“é“ä¹‹å¤–ç½‘ä¿¡æ¯æ”¶é›†">ä¿¡æ¯æ”¶é›†é“é“ä¹‹å¤–ç½‘ä¿¡æ¯æ”¶é›†</a><time datetime="2023-05-28T16:00:00.000Z" title="å‘è¡¨äº 2023-05-29 00:00:00">2023-05-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/å®‰çŸ¥é±¼-ä¸Šç­æ‘¸é±¼ä¸­.svg" alt="è·ç¦»æœˆå…¥25kä¹Ÿå°±è¿˜å·®ä¸€ä¸ªå¤§ä½¬å¸¦æˆ‘~" title="è·ç¦»æœˆå…¥25kä¹Ÿå°±è¿˜å·®ä¸€ä¸ªå¤§ä½¬å¸¦æˆ‘~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 By <a class="footer-bar-link" href="/" title="Jack hou" target="_blank">Jack hou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="ä¸»é¢˜">ä¸»é¢˜</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">æ–‡ç« </div><div class="length-num">58</div></a><a href="/tags/" title="tag"><div class="headline">æ ‡ç­¾</div><div class="length-num">19</div></a><a href="/categories/" title="category"><div class="headline">åˆ†ç±»</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">åŠŸèƒ½</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="æ˜¾ç¤ºæ¨¡å¼"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>æ˜¾ç¤ºæ¨¡å¼</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">ç½‘é¡µ</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="åšå®¢"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="åšå®¢"/><span class="back-menu-item-text">åšå®¢</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">é¡¹ç›®</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="å®‰çŸ¥é±¼å›¾åºŠ"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="å®‰çŸ¥é±¼å›¾åºŠ"/><span class="back-menu-item-text">å®‰çŸ¥é±¼å›¾åºŠ</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> æ–‡ç« </span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> éš§é“</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> åˆ†ç±»</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> æ ‡ç­¾</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> å‹é“¾</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> å‹äººå¸</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> ç•™è¨€æ¿</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> æˆ‘çš„</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> éŸ³ä¹é¦†</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> è¿½ç•ªé¡µ</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> ç›¸å†Œé›†</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> å…³äº</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> å…³äºæœ¬äºº</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> é—²è¨€ç¢è¯­</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> éšä¾¿é€›é€›</span></a></li></ul></div></div><span class="sidebar-menu-item-title">æ ‡ç­¾</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 0.88rem; color: rgb(28, 13, 133);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem; color: rgb(185, 120, 196);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem; color: rgb(52, 106, 168);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem; color: rgb(9, 99, 59);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; color: rgb(187, 125, 110);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem; color: rgb(37, 161, 17);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 0.88rem; color: rgb(94, 33, 85);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem; color: rgb(41, 175, 112);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 0.88rem; color: rgb(69, 147, 18);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem; color: rgb(101, 3, 55);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 0.88rem; color: rgb(106, 13, 113);">ã€ŠJavaScriptæƒå¨æŒ‡å—ã€‹<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 0.88rem; color: rgb(187, 154, 104);">åŒ¿å<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem; color: rgb(77, 180, 25);">åšå®¢<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem; color: rgb(61, 127, 109);">å®‰å…¨<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 0.88rem; color: rgb(87, 163, 30);">æ”¯ä»˜<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 0.88rem; color: rgb(117, 29, 105);">æ”»é˜²<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 0.88rem; color: rgb(66, 52, 16);">æ—…è¡Œ<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem; color: rgb(115, 66, 146);">è™šæ‹Ÿæœº<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 0.88rem; color: rgb(14, 66, 190);">è¶Šæƒ<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="é˜…è¯»æ¨¡å¼"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="ç®€ç¹è½¬æ¢">ç¹</button><button id="darkmode" type="button" title="æµ…è‰²å’Œæ·±è‰²æ¨¡å¼è½¬æ¢"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="å•æ å’ŒåŒæ åˆ‡æ¢"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="è®¾ç½®"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="ç›®å½•"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="ç›´è¾¾è¯„è®º"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="å›åˆ°é¡¶éƒ¨"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">æ’­æ”¾éŸ³ä¹</a><div id="console-music-bg"></div><meting-js id="8868465080" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">æœç´¢</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  æ•°æ®åº“åŠ è½½ä¸­</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="æœç´¢æ–‡ç« " type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>å¤åˆ¶é€‰ä¸­æ–‡æœ¬</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>ç²˜è´´æ–‡æœ¬</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>å¼•ç”¨åˆ°è¯„è®º</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>æ–°çª—å£æ‰“å¼€</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>å¤åˆ¶é“¾æ¥åœ°å€</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>å¤åˆ¶æ­¤å›¾ç‰‡</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>ä¸‹è½½æ­¤å›¾ç‰‡</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>æ–°çª—å£æ‰“å¼€å›¾ç‰‡</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>ç«™å†…æœç´¢</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>ç™¾åº¦æœç´¢</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>æ’­æ”¾éŸ³ä¹</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>åˆ‡æ¢åˆ°ä¸Šä¸€é¦–</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>åˆ‡æ¢åˆ°ä¸‹ä¸€é¦–</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8868465080&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>æŸ¥çœ‹æ‰€æœ‰æ­Œæ›²</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>å¤åˆ¶æ­Œå</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>éšä¾¿é€›é€›</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>åšå®¢åˆ†ç±»</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>æ–‡ç« æ ‡ç­¾</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>å¤åˆ¶åœ°å€</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">å…³é—­çƒ­è¯„</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">æ·±è‰²æ¨¡å¼</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>è½‰ç‚ºç¹é«”</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// æ¶ˆé™¤æ§åˆ¶å°æ‰“å°
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //åœ¨æ¢å¤å‰è¾“å‡ºæ—¥å¿—
  const grt = new Date("4/15/2023 00:00:00"); //æ­¤å¤„ä¿®æ”¹ä½ çš„å»ºç«™æ—¶é—´æˆ–è€…ç½‘ç«™ä¸Šçº¿æ—¶é—´
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `æ¬¢è¿ä½¿ç”¨å®‰çŸ¥é±¼!`,
    `ç”Ÿæ´»æ˜æœ—, ä¸‡ç‰©å¯çˆ±`,
    `
        
       â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
      â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
      â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â•šâ–ˆâ–ˆâ•”â•  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘
      â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•
      â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•šâ•â•   â•šâ•â•    â•šâ•â•â•â•â•â•
        
        `,
    "å·²ä¸Šçº¿",
    dnum,
    "å¤©",
    "Â©2023 By å®‰çŸ¥é±¼ V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `è°ƒç”¨å‰ç½®æ‘„åƒå¤´æ‹ç…§æˆåŠŸï¼Œè¯†åˆ«ä¸ºã€å°ç¬¨è›‹ã€‘.`, `Photo captured: `, `ğŸ¤ª`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c ä½ å¥½ï¼Œå°ç¬¨è›‹.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c âš¡ Powered by å®‰çŸ¥é±¼ %c ä½ æ­£åœ¨è®¿é—® Jack hou çš„åšå®¢.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c ä½ å·²æ‰“å¼€æ§åˆ¶å°.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c ä½ ç°åœ¨æ­£å¤„äºç›‘æ§ä¸­.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("4/15/2023 00:00:00"); //è®¾ç½®ç½‘ç«™ä¸Šçº¿æ—¶é—´
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // è®¡ç®—å¹¶æ›´æ–°å¤©æ•°ã€å°æ—¶æ•°ã€åˆ†é’Ÿæ•°å’Œç§’æ•°
  function updateTime() {
    now = new Date(); // æ›´æ–° now çš„å€¼
    nowHour = now.getHours(); // æ›´æ–° nowHour çš„å€¼
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // æ›´æ–°ç½‘é¡µä¸­æ˜¾ç¤ºçš„ç½‘ç«™è¿è¡Œæ—¶é—´
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // å¦‚æœæ˜¯ä¸Šç­æ—¶é—´ï¼Œé»˜è®¤å°±æ˜¯"å®‰çŸ¥é±¼-ä¸Šç­æ‘¸é±¼ä¸­.svg"å›¾ç‰‡ï¼Œä¸éœ€è¦æ›´æ”¹
      currentTimeHtml = `æœ¬ç«™å±…ç„¶è¿è¡Œäº† ${dnum} å¤©<span id='runtime'> ${hnum} å°æ—¶ ${mnum} åˆ† ${snum} ç§’ </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // å¦‚æœæ˜¯ä¸‹ç­æ—¶é—´ï¼Œæ’å…¥"å®‰çŸ¥é±¼-ä¸‹ç­å•¦.svg"å›¾ç‰‡
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/å®‰çŸ¥é±¼-ä¸‹ç­å•¦.svg";
      img.title = "ä¸‹ç­äº†å°±è¯¥å¼€å¼€å¿ƒå¿ƒçš„ç©è€ï¼Œå˜¿å˜¿~";
      img.alt = "ä¸‹ç­äº†å°±è¯¥å¼€å¼€å¿ƒå¿ƒçš„ç©è€ï¼Œå˜¿å˜¿~";

      currentTimeHtml = `æœ¬ç«™å±…ç„¶è¿è¡Œäº† ${dnum} å¤©<span id='runtime'> ${hnum} å°æ—¶ ${mnum} åˆ† ${snum} ç§’ </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[å›¾ç‰‡]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[é“¾æ¥]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[ä»£ç ]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.houyanbin.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "æ— æ³•è·å–è¯„è®ºï¼Œè¯·ç¡®è®¤ç›¸å…³é…ç½®æ˜¯å¦æ­£ç¡®"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += 'æ²¡æœ‰è¯„è®º'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">é€šçŸ¥</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">ä½ å¥½å‘€</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>