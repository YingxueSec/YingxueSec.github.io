<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>第6章 对象 | Jackhou Blog</title><meta name="keywords" content="《JavaScript权威指南》,JavaScript"><meta name="author" content="Jack hou"><meta name="copyright" content="Jack hou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="第6章 对象"><meta name="application-name" content="第6章 对象"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="第6章 对象"><meta property="og:url" content="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/index.html"><meta property="og:site_name" content="Jackhou Blog"><meta property="og:description" content="Objects are JavaScript’s most fundamental datatype, and you have already seen them many times in the chapters that precede this one. Because objec"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg"><meta property="article:author" content="Jack hou"><meta property="article:tag" content="Jackhou, blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg"><meta name="description" content="Objects are JavaScript’s most fundamental datatype, and you have already seen them many times in the chapters that precede this one. Because objec"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.houyanbin.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Jack hou","link":"链接: ","source":"来源: Jackhou Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Jackhou Blog',
  title: '第6章 对象',
  postAI: '',
  pageFillDescription: '6.1 Introduction to Objects, 6.2 Creating Objects, 6.2.1 Object Literals, 6.2.2 Creating Objects with new, 6.2.3 Prototypes, 6.2.4 Object.create(), 6.3 Querying and Setting Properties, 6.3.1 Objects As Associative Arrays, 6.3.2 Inheritance, 6.3.3 Property Access Errors, 6.4 Deleting Properties, 6.5 Testing Properties, 6.6 Enumerating Properties, 6.6.1 Property Enumeration Order, 6.7 Extending Objects, 6.8 Serializing Objects, 6.9 Object Methods, 6.9.1 The toString() Method, 6.9.2 The toLocaleString() Method, 6.9.3 The valueOf() Method, 6.9.4 The toJSON() Method, 6.10 Extended Object Literal Syntax, 6.10.1 Shorthand Properties, 6.10.2 Computed Property Names, 6.10.3 Symbols as Property Names, 6.10.4 Spread Operator, 6.10.5 Shorthand Methods, 6.10.6 Property Getters and Setters, 6.11 Summary对象是最基本的数据类型在本章之前的章节中已经多次看到它们因为对象对语言非常重要所以了解它们的工作原理非常重要本章将提供这些细节它从对象的正式概述开始然后深入到关于创建对象以及查询设置删除测试和枚举对象属性的实用部分在这些以属性为中心的章节之后将介绍如何扩展序列化和定义对象上的重要方法最后本章以一大段关于中的新对象文字语法和该语言的最新版本结尾对象是一个复合值它聚合了多个值原始值或其他对象并允许按名称存储和获取这些值对象是属性的无序集合每个属性都有一个名称和一个值属性名通常是字符串尽管正如我们将在中看到的属性名也可以是所以我们可以说对象将字符串映射到值这种字符串到值的映射有不同的名称可能已经熟悉这种基本数据结构的别的名称散列散列表字典或关联数组然而对象不仅仅是简单的字符串到值的映射除了维护自己的属性集对象还继承另一个对象的属性即它的原型对象的方法通常是继承的属性而这种原型继承是的一个关键特性对象是动态的属性通常可以添加和删除但它们可以用来模拟静态类型语言的静态对象和结构体有时它们也用做字符串的集合忽略名值对中的值中任何不是字符串数字或或的值都是对象即使字符串数字和布尔值不是对象它们的行为和不可变对象非常类似回想一下对象是可变的通过引用而不是值来操作如果变量指向一个对象的引用执行时变量也是指向同一对象的引用而不是该对象的副本通过变量修改这个对象也会对变量造成影响对对象最常见的操作是创建它们并设置查询删除测试和枚举它们的属性这些基本的操作将在本章的开头部分进行描述之后的部分将介绍更高级的主题属性有一个名称和一个值属性名可以是任何字符串包括空字符串或任何但任何对象都不能有两个同名的属性值可以是任何值也可以是或函数或两者都是我们将在中学习和函数有时能够区分直接在对象上定义的属性和从原型对象继承的属性是很重要的使用术语自有属性来指代非继承属性除了名称和值之外每个属性还有三个属性属性属性指定是否可以设置属性的值属性指定循环是否返回属性名称可配置属性指定该属性是否可以删除是否可以修改其属性许多的内置对象具有只读不可枚举或不可配置的属性但是在默认情况下创建的对象的所有属性都是可写可枚举和可配置的解释了为对象指定非默认属性属性值的技巧对象可以用对象字面量创建也可以用关键字和函数来创建接下来的几部分对这些技术一一讲述创建对象最简单的方式就是在代码中使用对象直接量对象直接量是由若干名值对组成的映射表名值对中间用冒号分隔名值对之间用逗号分隔整个映射表用花括号括起来属性名可以是标识符也可以是字符串字面量包括空字符串属性的值可以是任意类型的表达式表达式的值可以是原始值也可以是对象值变成这个属性的值下面有一些例子对象文本中最后一个属性的尾随逗号是合法的并且某些编程样式鼓励使用这些尾随逗号因为如果之后在对象文本的末尾添加新属性则不太可能导致语法错误对象字面量是一个表达式它每次计算时都会创建和初始化一个新对象每次字面量计算时将计算每个属性的值这意味着如果单个对象字面量出现在循环体或重复调用的函数中它能创建许多个新对象并且这些对象的属性值可能彼此不同此处的简单语法对象字面量自最早的版本以来一直是合法的最新版本引入了许多对象字面量的新的特性这些特性在中介绍运算符创建并初始化一个新的对象关键字必须紧跟一个函数调用这种方式使用函数叫做构造函数调用其提供初始化一个新创建的对象的服务在中内置类型都包含相对应的构造函数例如除了这些内置构造函数常常用自定义构造函数来初始化新对象第章将详细讲述其中的细节在讲述第三种对象创建技术之前我们应当首先解释一下原型每一个对象都和另一个对象相关联另一个对象就是我们熟知的原型每一个对象都从原型继承属性所有通过对象字面量创建的对象都具有同一个原型对象并可以通过代码获得对原型对象的引用通过关键字和构造函数调用创建的对象的原型就是构造函数的属性的值因此同使用创建对象一样通过创建的对象也继承自同样通过创建的对象的原型就是通过创建的对象的原型就是当第一次学习时这可能令人困惑请记住几乎所有对象都有原型但只有相对较少的对象具有原型属性正是这些具有原型属性的对象定义了所有其他对象的原型没有原型的对象为数不多就是其中之一它不继承任何属性其他原型对象都是普通对象普通对象都具有原型大部分的内置构造函数以及大部分自定义的构造函数都具有一个继承自的原型例如的属性继承自因此由创建的对象的属性同时继承自和这一系列链接的原型对象就是所谓原型链节讲述属性继承的工作机制第章将会更详细地讨论原型和构造函数包括如何通过编写构造函数定义对象的类以及给构造函数的属性赋值可以让其实例直接使用这个原型上的属性和方法并且在我们会学习如何查询甚至改变对象的原型创建一个新的对象用第一个实参作为它的原型可以通过传入参数来创建一个没有原型的新对象但通过这种方式创建的对象不会继承任何东西甚至不包括基础方法比如也就是说它将不能和运算符一起正常工作如果想创建一个普通的空对象像通过或创建的对象需要传入可以通过任意原型创建新对象这是一个强大的特性并且本章我们会在很多地方使用也可以传入第二个可选实参来描述这个新的对象的属性第二个实参是一个高级特性在再进行描述其中一个用途是预防对象无意间非恶意地被无法支配的库函数篡改可以创建一个继承它的对象来传递给函数而不是将其直接传递给函数当函数读取继承对象的属性时实际上读取的是继承来的值如果给继承对象的属性赋值则这些属性只会影响这个继承对象自身而不是原始对象想要了解其工作原理需要先知道中属性的查询和设置机制这是接下来这节的主题已经提到可以通过点或方括号运算符来获取属性的值运算符左侧应当是一个表达式它返回一个对象如果使用点运算符右侧必须是一个以属性名称命名的简单标识符如果使用方括号方括号内必须是一个计算结果为字符串的表达式这个字符串就是属性的名字和查询属性值的写法一样通过点和方括号也可以创建属性或给属性赋值但需要将它们放在赋值表达式的左侧当使用方括号时我们说方括号内的表达式必须返回字符串其实更严格地讲表达式必须返回字符串或返回一个可以转换为字符串的值或在第章里有一些例子中的方括号内使用了数字这情况是非常常用的上文提到下面两个表达式有相同的值第一种语法使用点运算符和一个标识符这和和中访问一个结构体或对象的静态字段非常类似第二种语法使用方括号和一个字符串看起来更像数组只是这个数组元素是通过字符串索引而不是数字索引这种数组就是我们所说的关联数组也称做散列映射或字典对象都是关联数组本节将讨论它的重要性在和一些强类型语言中对象只能拥有固定数目的属性并且这些属性的名称必须提前定义好由于是一个弱类型语言因此不适用这条规则对象在程序中可以创建任意数量的属性当使用运算符访问对象的属性时属性名用一个标识符来表示标识符必须直接出现在程序中它们不是数据类型所以无法在程序中修改另一种方式当通过来访问对象的属性时属性名通过字符串来表示字符串是的数据类型在程序运行时可以修改和创建它们因此可以在中使用下面这种代码这段代码读取对象的和属性并将它们连接起来这个例子主要说明了通过字符串表达式使用数组标记来访问对象属性的灵活性这段代码也可以通过点运算符来重写但是一些场景只能使用数组写法来完成假设你正在写一个程序这个程序利用网络资源计算用户股票市场投资的当前价值程序允许用户输入他们拥有的股票名称以及对应的数量你可以用一个名为的对象来储存这些信息每一个股票在对象中都有一个属性与之对应属性名是股票名属性值是股票持有份额例如如果用户持有的股那么属性的值就为下面是程序的部分代码这个函数用来给添加新的股票由于用户是在程序运行时输入股票名称因此在之前无法得知这些股票的名称是什么而由于在写程序的时候不知道属性名称因此无法通过点运算符来访问对象的属性但可以使用运算符因为它使用字符串值字符串值是动态的可以在运行时更改而不是标识符标识符是静态的必须写死在程序中作为索引对属性进行访问第章介绍了循环节还会进一步介绍当使用循环遍历关联数组时就可以清晰地体会到的强大之处下面的例子就是利用计算的合计值如本节所示对象通常用作关联数组理解其工作原理非常重要但是在之后使用类常常是一个更好的选择我们将在中进行描述对象中有一组自有属性也有一组属性是继承自它的原型对象想要理解属性继承必须更深入地了解属性访问的细节这一节的例子通过使用函数创建对象来指定它的原型我们会在第章再次看到它但是每次使用创建类的实例时都会创建一个从原型对象继承属性的对象假设要查询对象的属性如果中不存在名称的自由属性那么将会继续在的原型对象中查询属性如果原型对象中也没有但这个原型对象也有原型那么继续在这个原型对象的原型上执行查询直到找到或者查找到一个原型是的对象为止可以看到对象的原型属性构成了一个链通过这个链可以实现属性的继承现在假设给对象的属性赋值如果中已经有属性这个属性不是继承来的那么这个赋值操作只改变这个已有属性的值否则赋值操作给添加一个新属性如果之前继承自属性那么这个继承的属性就被新创建的同名属性覆盖了属性赋值操作检查原型链只是判断是否允许赋值操作例如如果继承自一个只读属性那么赋值操作是不允许的将对此进行详细讨论如果允许属性赋值操作它也总是在原始对象上创建属性或对已有的属性赋值而不会去修改原型链在中只有在查询属性时才会体会到继承的存在而设置属性则和继承无关这是的一个重要特性该特性让程序员可以有选择地重写继承的属性属性赋值要么失败要么创建一个属性要么在原始对象中设置属性但有一个例外如果继承自属性而这个属性是一个具有方法的存取器属性参照那么这时将调用方法而不是给创建一个属性需要注意的是方法是由对象调用的而不是定义这个属性的原型对象调用的因此如果方法定义任意属性这个操作只是针对本身并不会修改原型链属性访问表达式并不总是返回或设置一个值本节讲述查询或设置属性时的一些出错情况查询一个不存在的属性并不会报错如果在对象自身的属性或继承的属性中均未找到属性属性访问表达式返回回想一下我们的对象有属性而没有属性但是如果对象不存在那么试图查询这个不存在的对象的属性就会报错和值都没有属性因此查询这些值的属性会报错接上例如果的左边是或时其属性表达式会失败所以当写一个像一样的表达式时如果你不确定和确实被定义就要小心了下面提供了两种避免出错的方法为了理解为什么这里的第二种方法可以避免类型错误异常可以参照节中关于运算符的短路行为如中所描述支持用条件属性访问它允许这样重写上面的赋值表达式当然给和设置属性也会报类型错误给其他值设置属性也不总是成功有一些属性是只读的不能重新赋值有一些对象不允许新增属性在严格模式下属性设定失败时会抛出异常在非严格模式下这些失败的处理经常没有任何反应尽管属性赋值成功或失败的规律看起来很简单但要描述清楚并不容易在这些场景下给对象设置属性会失败中的属性是只读的不能给只读属性重新赋值中的属性是继承属性且它是只读的不能通过同名自有属性覆盖只读的继承属性中不存在自有属性没有使用方法继承属性并且的可扩展性是见如果中不存在而且没有方法可供调用则一定会添加至中但如果不是可扩展的那么在中不能定义新属性删除运算符能删除对象中的属性它的操作数应当是一个属性访问表达式令人意外的是没有操作属性的值而是操作属性的属性运算符只删除自有属性不删除继承属性想要删除一个继承属性必须从定义这个属性的原型对象上删除它这会影响所有继承这个原型的对象如果删除成功或删除没有任何影响时删除表达式计算结果是如删除不存在的属性作用于非属性访问表达式无用代码时也返回不能删除那些可配置性为的属性某些内置对象的属性是不可配置的比如通过变量声明和函数声明创建的全局对象的属性在严格模式中删除一个不可配置属性会报一个类型错误在非严格模式中在这些情况下的操作会返回当在非严格模式中删除全局对象的可配值属性时可以省略对全局对象的引用直接在操作符后跟随要删除的属性名即可然而在严格模式中后跟随一个非法的操作数比如则会报一个语法错误因此必须显式指定对象及其属性对象可以看作属性的集合我们经常会检测集合中成员的所属关系判断某个属性是否存在于某个对象中可以用运算符和方法来完成这个工作甚至仅通过属性查询也可以做到这一点这节的例子都是用字符串作为属性名称但是也可以用作为属性名运算符的左侧是属性名右侧是对象如果对象的自有属性或继承属性中包含这个属性则返回对象的方法用来检测给定的名字是否是对象的自有属性对于继承属性它将返回是的增强版只有检测到是自有属性且这个属性的可枚举性为时它才返回某些内置属性是不可枚举的通常由代码创建的属性都是可枚举的除非使用中介绍的技术来让它们不可枚举除了使用运算符之外另一种更简便的方法是使用判断一个属性是否是然而有一种场景只能使用运算符而不能使用上述属性访问的方式可以区分不存在的属性和存在但值为的属性例如下面的代码除了检测对象的属性是否存在我们还会经常遍历对象的属性有几种不同的方法可以做到这一点讨论过循环其可以在循环体中遍历指定对象中所有可枚举的属性包括自有属性和继承的属性把属性名称赋值给循环变量对象继承的内置方法不可枚举的但在代码中给对象添加的属性都是可枚举的除非用下文中提到的一个方法将它们转换为不可枚举的例如为了防止枚举到继承属性可以在循环中添加显示检查作为使用循环的替代方法通常使用循环遍历易获取对象的属性名称数组可以使用四个函数获取属性名称数组返回对象的可枚举自有属性名称数组集合数组内不包含不可枚举属性继承属性或属性名称是见的属性用起来和类似但是它返回数组中也包含不可迭代的自有属性只要它们的名称是字符串返回名称是的自有属性无论它们是否可枚举返回所有的自由属性名称包括可枚举和不可枚举类型也包括字符串和见在中有例子使用循环正式定义元素的自有属性的枚举顺序和相关方法如属性列表都按以下顺序排列的受它们自身是否是不可枚举属性列表或者属性是字符串或者影响首先列出名称为非负整数的字符串属性按从最小到最大的数字顺序列出此规则意味着数组和数组类对象将按顺序枚举其属性列出所有看起来像数组索引的属性后将列出所有具有字符串名称的剩余属性包括看起来像负数或浮点数字的属性这些属性按添加到对象的顺序列出对于在对象字面量中定义的属性此顺序与它们在文本中显示的顺序相同最后其名称为对象的属性按添加到对象的顺序列出循环的枚举顺序不像这些枚举函数那样严格指定但实现通常按刚才描述的顺序枚举自己的属性然后向上移动原型链按相同顺序枚举每个原型对象的属性但是请注意如果已枚举具有相同名称的属性或者不可枚举属性已经被检测过再次枚举到相同名称的属性都不会再次枚举在代码中有一个很常见的操作需要将一个对象中的属性拷贝到另外一个对象以下面的代码很容易实现但是因为这个是个常用的操作各种框架定义公用函数经常将其命名为来执行这个拷贝操作最后在中这个功能以的形式被添加到核心语言中需要两个或多个对象作为其实参它修改并返回第一个实参即目标对象但不会改变第二个或任何后续参数这些参数是源对象对于每个源对象它将该对象的可枚举自有属性包括名称为的属性复制到目标对象中它按源对象在实参列表顺序中的顺序处理所以第一个源对象中的属性会重写在目标对象中的同名属性然后以第二个源对象中的同名属性如果有第二个源对象再次重写第一个源对象重写后的属性通过普通属性的和操作复制属性因此如果源对象具有方法或目标对象具有方法则将在复制期间调用它们但不会复制方法本身看这样一个场景有一个对象定义许多属性的默认值希望将这些默认属性中不存在于目标对象中的属性复制到目标对象中使用不会得到想要的结果想得到这个效果需要创建一个新的对象将默认值拷贝到其中然后用的属性重写默认值中的属性我们会在见到可以用展开操作符如下操作这个对象拷贝并重写为了避免对象创建和复制的额外开销我们还可以通过编写一个仅在缺少属性时复制属性编写其他属性操作公共函数很简单就是像这个函数例如如果对象的属性不出现在另一个模板对象中则函数会删除这些属性或者函数可以从其他对象中删除一个对象的所有属性对象序列化是指将对象的状态转换为字符串也可将字符串还原为对象函数和用来序列化和还原对象这些方法都使用作为数据交换格式的全称是对象表示法它的语法和对象与数组字面量的语法非常相近的语法是语法的子集它并不能表示里的所有值支持对象数组字符串无穷大数字和并且它们可以序列化和还原和序列化的结果是日期对象序列化的结果是格式的日期字符串参照函数但依然保留它们的字符串形态而不会将它们还原为原始日期对象函数对象和值不能序列化和还原只能序列化对象可枚举的自有属性对于一个不能序列化的属性来说在序列化后的输出字符串中会将这个属性省略掉和都可以接收第二个可选实参通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作有关于这些函数的详细文档上文已经讨论过所有的对象都从继承属性除了那些不通过原型显式创建的对象这些继承属性主要是方法因为程序员普遍对继承方法更感兴趣例如我们已经见过的和方法并且我们也已经提到了一小部分定义在对象构造函数中的静态函数像和本节介绍在上定义的少数通用对象方法但是这些方法经常会被更专业的实现所取代在下面的各节中我们将展示在单个对象上定义这些方法的示例在第章中将学习如何更常规化地为整个对象类定义这些方法方法没有实参它将返回一个表示调用这个方法的对象值的字符串在需要将对象转换为字符串的时候都会调用这个方法比如当使用运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用默认的方法的返回值带有的信息量很少尽管它在检测对象的类型时非常有用参照例如下面这行代码的计算结果为字符串由于默认的方法并不会输出很多有用的信息因此很多类都带有自定义的例如当数组转换为字符串的时候结果是一个数组元素列表只是每个元素都转换成了字符串再比如当函数转换为字符串的时候得到函数的源代码可以像下面这样自定义方法除了基本的方法之外对象都包含方法这个方法返回一个表示这个对象的本地化字符串中默认的方法并不做任何本地化自身的操作它仅调用方法并返回对应值和类对方法做了定制可以用它对数字日期和时间做本地化的转换类的方法和方法很像唯一的不同是每个数组元素会调用方法转换为字符串而不是调用各自的方法可以像这样使用对象做到同样的效果在的国际化类中方法的实现是非常有用的方法和方法非常类似但往往当需要将对象转换为某种原始值而非字符串的时候才会调用它尤其是转换为数字的时候如果在需要使用原始值的上下文中使用了对象就会自动调用这个方法默认的方法不足为奇但有些内置类自定义了方法类定义将日期转化成数值型并且这允许对象使用和按时间先手顺序比较可以对对象做同样的事定义一个方法返回原点到点的距离实际上没有定义方法但对于需要执行序列化的对象来说方法见会调用方法如果在待序列化的对象中存在这个方法则调用它返回值即是序列化的结果而不是原始的对象类定义了方法返回日期的序列化字符串我们可以这样对对象做同样的事的最新版本扩展了许多有用的对象字面量相关的语法以下小节解释这些扩展假设值存储在变量和中并且想要创建具有名为和的属性的对象这些属性包含这些值使用基本对象字面量语法最终会重复每个标识符两次在之后可以删除标识符的冒号和一个副本最终使用更简单的代码有时需要创建具有特定属性的对象但该属性的名称不是可以在源代码中键入的编译时常量相反需要的属性名称存储在变量中或者是调用的函数的返回值不能对此类属性使用基本对象字面量而必须创建一个对象通过额外的步骤添加所需的属性使用称为计算属性的特性设置这样的对象要简单得多该功能允许从前面的代码写入方括内并直接移动到对象字面量中使用这种新语法方括号将其分隔成表达式计算该表达式并将结果值如有必要转换为字符串用作属性名称可能想要使用计算属性的一个情况是有一个代码库该库希望传递具有一组特定属性的对象并且这些属性的名称定义为该库中的常量如果要编写代码以创建将传递给该库的对象可以硬编码属性名称但如果在任何地方键入错误的属性名称则存在错误风险如果库的新版本更改了所需的属性名称则存在版本不匹配问题的风险相反可能会发现使用计算属性语法与库定义的属性名称常量时它使代码更加健壮计算属性语法启用了另一个非常重要的对象字面量特性在之后属性名称可以是字符串或如果将分配给变量或常量则可以使用计算属性语法将该用作属性名称如中所述符号是不透明值除了将它们用作属性名称不能对它们进行任何其他处理但是每个都不同于所有其他这意味着适合创建唯一的属性名称通过调用工厂函数创建新是原始值而不是对象因此不是使用调用的构造函数返回的值不等于任何其他或其他值可以将字符串传递给当转换为字符串时将使用此字符串但是这只是一个调试帮助使用同一字符串参数创建的两个仍然彼此不同的要点不是安全性而是为对象定义一个安全的扩展机制如果从第三方代码获取对象您无法控制该对象并且需要向该对象添加自己的一些属性但希望确保属性不会与对象上可能存在的任何属性冲突可以安全地使用作为属性名称如果这样做还可以确信第三方代码不会意外更改命名的属性当然该第三方代码可以使用来发现你使用的然后可以更改或删除你的属性这就是为什么符号不是安全机制在之后可以使用展开运算符将现有的对象中的属性复制到新的对象中在此代码中和对象的属性被展开到对象字面量中就像它们以字面量的方式写入这些大括号中一样请注意语法通常称为展开运算符但在任何情况下都不是真正的运算符相反它是一种特殊情况下语法仅在对象文本中可用在别的上下文中有其他用途但是对象字面量上下文中只有这一种用法如果展开的目标对象和源对象中具有相同的名称则该属性的值将是位置处于后面的值还有注意展开运算符只展开对象的自有属性不展开继承属性最后值得注意的是虽然展开运算符在代码中只是三个小点但它对解释器来说可以代表大量的工作如果对象具有个属性则将这些属性分散到另一个对象的过程很可能是操作这意味着如果你发现自己在使用在循环或递归函数中类似将数据累积到一个大对象中的方法您可能正在编写一个低效的算法该算法不会随着变大而扩展当函数被定义为对象的属性时我们称该函数为方法我们将在第章和第章中对方法有更多的描述在之前在对象字面量中用函数定义表达式定义一个方法和在对象中定义其他属性一样但是在中对象字面量语法以及我们将在第章中看到的类定义语法已扩展成允许省略函数关键字和冒号的快捷方式可以写成这样的代码两种形式是相同的在对象字面量中添加一个名为的属性并指定一个函数为这个属性的值速记语法更清晰的看出是一个方法而不是一个像一样的数据属性使用此速记语法编写方法时属性名称可以采用对象字面量中的任何合法形式除了像上面的名称这样的常规标识符外还可以使用字符串字面量和计算属性名称包括属性名称使用作为方法名称并不像看起来那么奇怪为了使对象可迭代因此它可以与循环一起使用必须定义一个具有符号名称的方法并且在第章中有这样做的示例到目前为止本节我们所讨论的所有的对象都是具有名称和普通值的数据属性还支持存取器属性这些属性没有单个值而是具有一个或两个存取器方法和或是或当程序查询存取器属性的值时调用方法无实参这个方法的返回值就是属性存取表达式的值当程序设置一个存取器属性的值时调用方法将赋值表达式右侧的值当做参数传入从某种意义上讲这个方法负责设置属性值可以忽略方法的返回值如果属性同时有和方法则它是一个可读写属性如果它只含有方法它是一个只读属性如果它只有方法它是一个只可写属性这对一个数据属性来说是不可能的如果尝试去读它计算结果永远是存储器属性可以通过表达式在对象字面量语法中定义不像我们在这里看到的其他扩展和是中的内容存储器属性定义为名称与属性名称相同的一个或两个方法这些方法看起来像使用速记定义的普通方法只不过和定义使用或前缀在中在定义和时还可以使用计算属性名称只需将带方括号的表达式替换属性名称即可上面定义的存储器方法只需获取并设置数据属性的值没有理由将存储器属性替换数据属性但作为一个更有趣的示例请考虑以下表示笛卡尔点的对象它具有表示点的和坐标的普通数据属性并且具有提供点等效极坐标的存储器属性请注意在本示例中的和中使用关键字以对象的方法的方式调用这些函数这意味着在函数体中指的是点对象因此属性的方法通过和获取到和属性的引用方法以及关键字在中详细介绍存储器属性是可继承的就像数据属性一样因此可以使用上面定义的对象作为其他点的原型可以为新对象提供自有的和属性它们将继承和属性上述代码使用存储器属性定义一个该提供一组数据的两种表示形式笛卡尔坐标和极坐标使用存储器属性的其他场景包括属性写入的稳健性检测以及在每个属性上返回不同的值最后下面是使用方法实现具有魔幻行为的属性的示例本章非常详细地记录了对象涵盖的主题包括基本对象术语包括可枚举和自有属性等术语的含义对象字面量语法包括及以后的许多新特性如何读取写入删除枚举和检查对象属性是否存在基于原型的继承是如何在中工作以及如何使用创建一个从另一个对象继承的对象如何使用将属性从一个对象复制到另一个对象所有的非原始值都是对象这包括数组和函数这是接下来两章的主题记住几乎所有对象都有一个原型但大多数对象没有名为的属性即使不能直接访问原型对象继承依然工作但是如果你想学习如何做到这一点请参阅',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:44:12',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/null"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Jackhou Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 1.05rem; color: rgb(119, 188, 186);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem; color: rgb(113, 75, 65);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem; color: rgb(85, 46, 140);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem; color: rgb(195, 101, 175);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem; color: rgb(144, 178, 199);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem; color: rgb(18, 24, 56);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 1.05rem; color: rgb(32, 192, 110);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem; color: rgb(43, 154, 118);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 1.05rem; color: rgb(101, 99, 75);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem; color: rgb(91, 24, 32);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 1.05rem; color: rgb(160, 162, 80);">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 1.05rem; color: rgb(31, 146, 158);">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem; color: rgb(117, 11, 21);">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem; color: rgb(163, 139, 156);">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 1.05rem; color: rgb(5, 182, 73);">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 1.05rem; color: rgb(162, 100, 74);">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.05rem; color: rgb(121, 17, 20);">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem; color: rgb(34, 65, 156);">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 1.05rem; color: rgb(155, 79, 125);">越权<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">37</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>《JavaScript权威指南》</span></a><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">第6章 对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:55.000Z" title="发表于 2023-04-26 00:00:55">2023-04-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:12.000Z" title="更新于 2023-04-26 21:44:12">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="第6章 对象"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url">《JavaScript权威指南》</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><h1 id="CrawlerTitle" itemprop="name headline">第6章 对象</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jack hou</span><time itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:55.000Z" title="发表于 2023-04-26 00:00:55">2023-04-26</time><time itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:12.000Z" title="更新于 2023-04-26 21:44:12">2023-04-26</time></header><meta name="referrer" content="no-referrer"/>



<p>Objects are JavaScript’s most fundamental datatype, and you have already seen them many times in the chapters that precede this one. Because objects are so important to the JavaScript language, it is important that you understand how they work in detail, and this chapter provides that detail. It begins with a formal overview of objects, then dives into practical sections about creating objects and querying, setting, deleting, testing, and enumerating the properties of objects. These property-focused sections are followed by sections that explain how to extend, serialize, and define important methods on objects. Finally, the chapter concludes with a long section about new object literal syntax in ES6 and more recent versions of the language.</p>
<blockquote>
<p>对象是 JavaScript 最基本的数据类型，在本章之前的章节中已经多次看到它们。因为对象对 JavaScript 语言非常重要，所以了解它们的工作原理非常重要，本章将提供这些细节。它从对象的正式概述开始，然后深入到关于创建对象以及查询、设置、删除、测试和枚举对象属性的实用部分。在这些以属性为中心的章节之后，将介绍如何扩展、序列化和定义对象上的重要方法。最后，本章以一大段关于 ES6 中的新对象文字语法和该语言的最新版本结尾。</p>
</blockquote>
<h2 id="6-1-Introduction-to-Objects"><a href="#6-1-Introduction-to-Objects" class="headerlink" title="6.1 Introduction to Objects"></a>6.1 Introduction to Objects</h2><p>An object is a composite value: it aggregates multiple values (primitive values or other objects) and allows you to store and retrieve those values by name. An object is an unordered collection of properties, each of which has a name and a value. Property names are usually strings (although, as we’ll see in §6.10.3, property names can also be Symbols), so we can say that objects map strings to values. This string-to-value mapping goes by various names—you are probably already familiar with the fundamental data structure under the name “hash,” “hashtable,” “dictionary,” or “associative array.” An object is more than a simple string-to-value map, however. In addition to maintaining its own set of properties, a JavaScript object also inherits the properties of another object, known as its “prototype.” The methods of an object are typically inherited properties, and this “prototypal inheritance” is a key feature of JavaScript.</p>
<blockquote>
<p>对象是一个复合值：它聚合了多个值（原始值或其他对象），并允许按名称存储和获取这些值。对象是属性的无序集合，每个属性都有一个名称和一个值。属性名通常是字符串（尽管，正如我们将在 §6.10.3 中看到的，属性名也可以是 Symbol），所以我们可以说对象将字符串映射到值。这种字符串到值的映射有不同的名称——可能已经熟悉这种基本数据结构的别的名称“散列”（hash）、“散列表”（hashtable）、“字典”（dictionary）或“关联数组”（associative array）。然而，对象不仅仅是简单的字符串到值的映射。除了维护自己的属性集，JavaScript 对象还继承另一个对象的属性，即它的“原型”。对象的方法通常是继承的属性，而这种“原型继承”是 JavaScript 的一个关键特性。</p>
</blockquote>
<p>JavaScript objects are dynamic—properties can usually be added and deleted—but they can be used to simulate the static objects and “structs” of statically typed languages. They can also be used (by ignoring the value part of the string-to-value mapping) to represent sets of strings.</p>
<blockquote>
<p>JavaScript 对象是动态的——属性通常可以添加和删除——但它们可以用来模拟静态类型语言的静态对象和“结构体”（struct）。有时它们也用做字符串的集 合（忽略名&#x2F;值对中的值）。</p>
</blockquote>
<p>Any value in JavaScript that is not a string, a number, a Symbol, or true, false, null, or undefined is an object. And even though strings, numbers, and booleans are not objects, they can behave like immutable objects.</p>
<blockquote>
<p>JavaScript 中任何不是字符串、数字、Symbol 或 true、false、null 或 undefined 的值都是对象。即使字符串、数字和布尔值不是对象，它们的行为和不可变对象非常类似。</p>
</blockquote>
<p>Recall from §3.8 that objects are mutable and manipulated by reference rather than by value. If the variable x refers to an object and the code let y &#x3D; x; is executed, the variable y holds a reference to the same object, not a copy of that object. Any modifications made to the object through the variable y are also visible through the variable x.</p>
<blockquote>
<p>回想一下 §3.8，对象是可变的，通过引用而不是值来操作。如果变量 x 指向一个对象的引用，执行 <code>y = x;</code> 时，变量 y 也是指向同一对象的引用，而不是该对象的副本。通过变量 y 修改这个对象也会对变量 x 造成影响。</p>
</blockquote>
<p>The most common things to do with objects are to create them and set, query, delete, test, and enumerate their properties. These fundamental operations are described in the opening sections of this chapter. The sections after that cover more advanced topics.</p>
<blockquote>
<p>对对象最常见的操作是创建它们并设置、查询、删除、测试和枚举它们的属性。这些基本的操作将在本章的开头部分进行描述。之后的部分将介绍更高级的主题。</p>
</blockquote>
<p>A property has a name and a value. A property name may be any string, including the empty string (or any Symbol), but no object may have two properties with the same name. The value may be any JavaScript value, or it may be a getter or setter function (or both). We’ll learn about getter and setter functions in §6.10.6.</p>
<blockquote>
<p>属性有一个名称和一个值。属性名可以是任何字符串，包括空字符串（或任何 Symbol），但任何对象都不能有两个同名的属性。值可以是任何 JavaScript 值，也可以是 getter 或 setter 函数（或两者都是）。我们将在 §6.10.6 中学习 getter 和 setter 函数。</p>
</blockquote>
<p>It is sometimes important to be able to distinguish between properties defined directly on an object and those that are inherited from a prototype object. JavaScript uses the term own property to refer to non-inherited properties.</p>
<blockquote>
<p>有时，能够区分直接在对象上定义的属性和从原型对象继承的属性是很重要的。JavaScript 使用术语“自有属性”来指代非继承属性。</p>
</blockquote>
<p>In addition to its name and value, each property has three property attributes:</p>
<blockquote>
<p>除了名称和值之外，每个属性还有三个属性属性:</p>
</blockquote>
<ul>
<li>The writable attribute specifies whether the value of the property can be set.</li>
<li>The enumerable attribute specifies whether the property name is returned by a for&#x2F;in loop.</li>
<li>The configurable attribute specifies whether the property can be deleted and whether its attributes can be altered.</li>
</ul>
<hr>
<ul>
<li>writable 属性指定是否可以设置属性的值。</li>
<li>enumerable 属性指定 for&#x2F;in 循环是否返回属性名称。</li>
<li>可配置属性指定该属性是否可以删除，是否可以修改其属性。</li>
</ul>
<p>Many of JavaScript’s built-in objects have properties that are read-only, non-enumerable, or non-configurable. By default, however, all properties of the objects you create are writable, enumerable, and configurable. §14.1 explains techniques for specifying non-default property attribute values for your objects.</p>
<blockquote>
<p>许多 JavaScript 的内置对象具有只读、不可枚举或不可配置的属性。但是，在默认情况下，创建的对象的所有属性都是可写、可枚举和可配置的。§14.1 解释了为对象指定非默认属性属性值的技巧。</p>
</blockquote>
<h2 id="6-2-Creating-Objects"><a href="#6-2-Creating-Objects" class="headerlink" title="6.2 Creating Objects"></a>6.2 Creating Objects</h2><p>Objects can be created with object literals, with the new keyword, and with the Object.create() function. The subsections below describe each technique.</p>
<blockquote>
<p>对象可以用对象字面量创建，也可以用 new 关键字和 Object.create() 函数来创建。接下来的几部分对这些技术一一讲述。</p>
</blockquote>
<h3 id="6-2-1-Object-Literals"><a href="#6-2-1-Object-Literals" class="headerlink" title="6.2.1 Object Literals"></a>6.2.1 Object Literals</h3><p>The easiest way to create an object is to include an object literal in your JavaScript code. In its simplest form, an object literal is a comma-separated list of colon-separated name:value pairs, enclosed within curly braces. A property name is a JavaScript identifier or a string literal (the empty string is allowed). A property value is any JavaScript expression; the value of the expression (it may be a primitive value or an object value) becomes the value of the property. Here are some examples:</p>
<blockquote>
<p>创建对象最简单的方式就是在 JavaScript 代码中使用对象直接量。对象直接量是由若干名&#x2F;值对组成的映射表，名&#x2F;值对中间用冒号分隔，名&#x2F;值对之间用逗号分隔，整个映射表用花括号括起来。属性名可以是 JavaScript 标识符也可以是字符串字面量（包括空字符串）。属性的值可以是任意类型的 JavaScript 表达式；表达式的值（可以是原始值也可以是对象值）变成这个属性的值。下面有一些例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> empty = &#123;&#125;;                          <span class="comment">// An object with no properties</span></span><br><span class="line"><span class="keyword">let</span> point = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;              <span class="comment">// Two numeric properties</span></span><br><span class="line"><span class="keyword">let</span> p2 = &#123; <span class="attr">x</span>: point.<span class="property">x</span>, <span class="attr">y</span>: point.<span class="property">y</span>+<span class="number">1</span> &#125;;   <span class="comment">// More complex values</span></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    <span class="string">&quot;main title&quot;</span>: <span class="string">&quot;JavaScript&quot;</span>,          <span class="comment">// These property names include spaces,</span></span><br><span class="line">    <span class="string">&quot;sub-title&quot;</span>: <span class="string">&quot;The Definitive Guide&quot;</span>, <span class="comment">// and hyphens, so use string literals.</span></span><br><span class="line">    <span class="attr">for</span>: <span class="string">&quot;all audiences&quot;</span>,                <span class="comment">// for is reserved, but no quotes.</span></span><br><span class="line">    <span class="attr">author</span>: &#123;                            <span class="comment">// The value of this property is</span></span><br><span class="line">        <span class="attr">firstname</span>: <span class="string">&quot;David&quot;</span>,              <span class="comment">// itself an object.</span></span><br><span class="line">        <span class="attr">surname</span>: <span class="string">&quot;Flanagan&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>A trailing comma following the last property in an object literal is legal, and some programming styles encourage the use of these trailing commas so you’re less likely to cause a syntax error if you add a new property at the end of the object literal at some later time.</p>
<blockquote>
<p>对象文本中最后一个属性的尾随逗号是合法的，并且某些编程样式鼓励使用这些尾随逗号，因为，如果之后在对象文本的末尾添加新属性，则不太可能导致语法错误。</p>
</blockquote>
<p>An object literal is an expression that creates and initializes a new and distinct object each time it is evaluated. The value of each property is evaluated each time the literal is evaluated. This means that a single object literal can create many new objects if it appears within the body of a loop or in a function that is called repeatedly, and that the property values of these objects may differ from each other.</p>
<blockquote>
<p>对象字面量是一个表达式，它每次计算时都会创建和初始化一个新对象。每次字面量计算时，将计算每个属性的值。这意味着，如果单个对象字面量出现在循环体或重复调用的函数中，它能创建许多个新对象，并且这些对象的属性值可能彼此不同。</p>
</blockquote>
<p>The object literals shown here use simple syntax that has been legal since the earliest versions of JavaScript. Recent versions of the language have introduced a number of new object literal features, which are covered in §6.10.</p>
<blockquote>
<p>此处的简单语法对象字面量，自 JavaScript 最早的版本以来一直是合法的。最新版本引入了许多对象字面量的新的特性，这些特性在 §6.10 中介绍。</p>
</blockquote>
<h3 id="6-2-2-Creating-Objects-with-new"><a href="#6-2-2-Creating-Objects-with-new" class="headerlink" title="6.2.2 Creating Objects with new"></a>6.2.2 Creating Objects with new</h3><p>The new operator creates and initializes a new object. The new keyword must be followed by a function invocation. A function used in this way is called a constructor and serves to initialize a newly created object. JavaScript includes constructors for its built-in types. For example:</p>
<blockquote>
<p>new 运算符创建并初始化一个新的对象。new 关键字必须紧跟一个函数调用。这种方式使用函数叫做构造函数调用，其提供初始化一个新创建的对象的服务。在 JavaScript 中，内置类型都包含相对应的构造函数。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();  <span class="comment">// Create an empty object: same as &#123;&#125;.</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>();   <span class="comment">// Create an empty array: same as [].</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>();    <span class="comment">// Create a Date object representing the current time</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Map</span>();     <span class="comment">// Create a Map object for key/value mapping</span></span><br></pre></td></tr></table></figure>
<p>In addition to these built-in constructors, it is common to define your own constructor functions to initialize newly created objects. Doing so is covered in Chapter 9.</p>
<blockquote>
<p>除了这些内置构造函数，常常用自定义构造函数来初始化新对象。 第 9 章将详细讲述其中的细节。</p>
</blockquote>
<h3 id="6-2-3-Prototypes"><a href="#6-2-3-Prototypes" class="headerlink" title="6.2.3 Prototypes"></a>6.2.3 Prototypes</h3><p>Before we can cover the third object creation technique, we must pause for a moment to explain prototypes. Almost every JavaScript object has a second JavaScript object associated with it. This second object is known as a prototype, and the first object inherits properties from the prototype.</p>
<blockquote>
<p>在讲述第三种对象创建技术之前，我们应当首先解释一下原型。每一个 JavaScript 对象都和另一个对象相关联。“另一个”对象就是我们熟知的原型，每一个对象都从原型继承属性。</p>
</blockquote>
<p>All objects created by object literals have the same prototype object, and we can refer to this prototype object in JavaScript code as Object.prototype. Objects created using the new keyword and a constructor invocation use the value of the prototype property of the constructor function as their prototype. So the object created by new Object() inherits from Object.prototype, just as the object created by {} does. Similarly, the object created by new Array() uses Array.prototype as its prototype, and the object created by new Date() uses Date.prototype as its prototype. This can be confusing when first learning JavaScript. Remember: almost all objects have a prototype, but only a relatively small number of objects have a prototype property. It is these objects with prototype properties that define the prototypes for all the other objects.</p>
<blockquote>
<p>所有通过对象字面量创建的对象都具有同一个原型对象，并可以通过 JavaScript 代码 Object.prototype 获得对原型对象的引用。通过关键字 new 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用 {} 创建对象一样，通过 new Object() 创建的对象也继承自Object.prototype。同样，通过 new Array() 创建的对象的原型就是 Array.prototype，通过 new Date() 创建的对象的原型就是 Date.prototype。当第一次学习 JavaScript 时，这可能令人困惑。请记住：几乎所有对象都有原型，但只有相对较少的对象具有原型属性。正是这些具有原型属性的对象定义了所有其他对象的原型。</p>
</blockquote>
<p>Object.prototype is one of the rare objects that has no prototype: it does not inherit any properties. Other prototype objects are normal objects that do have a prototype. Most built-in constructors (and most user-defined constructors) have a prototype that inherits from Object.prototype. For example, Date.prototype inherits properties from Object.prototype, so a Date object created by new Date() inherits properties from both Date.prototype and Object.prototype. This linked series of prototype objects is known as a prototype chain.</p>
<blockquote>
<p>没有原型的对象为数不多，Object.prototype就是其中之一：它不继承任何属性。其他原型对象都是普通对象，普通对象都具有原型。大部分的内置构造函数（以及大部分自定义的构造函数）都具有一个继承自 Object.prototype 的原型。例如， Date.prototype 的属性继承自 Object.prototype，因此由 new Date() 创建的 Date 对象的属性同时继承自 Date.prototype 和 Object.prototype。这一系列链接的原型对象就是所谓 “原型链”（prototype chain）。</p>
</blockquote>
<p>An explanation of how property inheritance works is in §6.3.2. Chapter 9 explains the connection between prototypes and constructors in more detail: it shows how to define new “classes” of objects by writing a constructor function and setting its prototype property to the prototype object to be used by the “instances” created with that constructor. And we’ll learn how to query (and even change) the prototype of an object in §14.3.</p>
<blockquote>
<p>§6.3.2 节讲述属性继承的工作机制。第 9 章将会更详细地讨论原型和构造函数：包括如何通过编写构造函数定义对象的“类”，以及给构造函数的 prototype 属性赋值可以让其“实例”直接使用这个原型上的属性和方法。并且在 §14.3 我们会学习如何查询（甚至改变）对象的原型。</p>
</blockquote>
<h3 id="6-2-4-Object-create"><a href="#6-2-4-Object-create" class="headerlink" title="6.2.4 Object.create()"></a>6.2.4 Object.create()</h3><p>Object.create() creates a new object, using its first argument as the prototype of that object:</p>
<blockquote>
<p>Object.create() 创建一个新的对象，用第一个实参作为它的原型：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;);     <span class="comment">// o1 inherits properties x and y.</span></span><br><span class="line">o1.<span class="property">x</span> + o1.<span class="property">y</span>                               <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>You can pass null to create a new object that does not have a prototype, but if you do this, the newly created object will not inherit anything, not even basic methods like toString() (which means it won’t work with the + operator either):</p>
<blockquote>
<p>可以通过传入参数 null 来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如 toString()，也就是说，它将不能和“+”运算符一起正常工作：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);             <span class="comment">// o2 inherits no props or methods.</span></span><br></pre></td></tr></table></figure>
<p>If you want to create an ordinary empty object (like the object returned by {} or new Object()), pass Object.prototype:</p>
<blockquote>
<p>如果想创建一个普通的空对象（像通过 {} 或 new Object() 创建的对象），需要传入 Object.prototype：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// o3 is like &#123;&#125; or new Object().</span></span><br></pre></td></tr></table></figure>
<p>The ability to create a new object with an arbitrary prototype is a powerful one, and we’ll use Object.create() in a number of places throughout this chapter. (Object.create() also takes an optional second argument that describes the properties of the new object. This second argument is an advanced feature covered in §14.1.)</p>
<blockquote>
<p>可以通过任意原型创建新对象，这是一个强大的特性，并且本章我们会在很多地方使用 Object.create()。（Object.create() 也可以传入第二个可选实参来描述这个新的对象的属性。第二个实参是一个高级特性，在  §14.1 再进行描述。）</p>
</blockquote>
<p>One use for Object.create() is when you want to guard against unintended (but nonmalicious) modification of an object by a library function that you don’t have control over. Instead of passing the object directly to the function, you can pass an object that inherits from it. If the function reads properties of that object, it will see the inherited values. If it sets properties, however, those writes will not affect the original object.</p>
<blockquote>
<p>Object.create() 其中一个用途是预防对象无意间（非恶意地）被无法支配的库函数篡改。可以创建一个继承它的对象来传递给函数，而不是将其直接传递给函数。当函数读取继承对象的属性时，实际上读取的是继承来的值。如果给继承对象的属性赋值，则这些属性只会影响这个继承对象自身，而不是原始对象：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="string">&quot;don&#x27;t change this value&quot;</span> &#125;;</span><br><span class="line">library.<span class="keyword">function</span>(<span class="params"><span class="built_in">Object</span>.create(o)</span>);  <span class="comment">// Guard against accidental modifications</span></span><br></pre></td></tr></table></figure>
<p>To understand why this works, you need to know how properties are queried and set in JavaScript. These are the topics of the next section.</p>
<blockquote>
<p>想要了解其工作原理，需要先知道 JavaScript 中属性的查询和设置机制。这是接下来这节的主题。</p>
</blockquote>
<h2 id="6-3-Querying-and-Setting-Properties"><a href="#6-3-Querying-and-Setting-Properties" class="headerlink" title="6.3 Querying and Setting Properties"></a>6.3 Querying and Setting Properties</h2><p>To obtain the value of a property, use the dot (.) or square bracket ([]) operators described in §4.4. The lefthand side should be an expression whose value is an object. If using the dot operator, the righthand side must be a simple identifier that names the property. If using square brackets, the value within the brackets must be an expression that evaluates to a string that contains the desired property name:</p>
<blockquote>
<p>§4.4 已经提到，可以通过点（.）或方括号（[]）运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。如果使用点运算符，右侧必须是一个以属性名称命名的简单标识符。如果使用方括号，方括号内必须是一个计算结果为字符串的表达式，这个字符串就是属性的名字：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> author = book.<span class="property">author</span>;       <span class="comment">// Get the &quot;author&quot; property of the book.</span></span><br><span class="line"><span class="keyword">let</span> name = author.<span class="property">surname</span>;      <span class="comment">// Get the &quot;surname&quot; property of the author.</span></span><br><span class="line"><span class="keyword">let</span> title = book[<span class="string">&quot;main title&quot;</span>]; <span class="comment">// Get the &quot;main title&quot; property of the book.</span></span><br></pre></td></tr></table></figure>
<p>To create or set a property, use a dot or square brackets as you would to query the property, but put them on the lefthand side of an assignment expression:</p>
<blockquote>
<p>和查询属性值的写法一样，通过点和方括号也可以创建属性或给属性赋值，但需要将它们放在赋值表达式的左侧：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">book.<span class="property">edition</span> = <span class="number">7</span>;                   <span class="comment">// Create an &quot;edition&quot; property of book.</span></span><br><span class="line">book[<span class="string">&quot;main title&quot;</span>] = <span class="string">&quot;ECMAScript&quot;</span>;  <span class="comment">// Change the &quot;main title&quot; property.</span></span><br></pre></td></tr></table></figure>
<p>When using square bracket notation, we’ve said that the expression inside the square brackets must evaluate to a string. A more precise statement is that the expression must evaluate to a string or a value that can be converted to a string or to a Symbol (§6.10.3). In Chapter 7, for example, we’ll see that it is common to use numbers inside the square brackets.</p>
<blockquote>
<p>当使用方括号时，我们说方括号内的表达式必须返回字符串。其实更严格地讲，表达式必须返回字符串或返回一个可以转换为字符串的值或 Symbol（§6.10.3）。在第 7 章里有一些例子中的方括号内使用了数字，这情况是非常常用的。</p>
</blockquote>
<h3 id="6-3-1-Objects-As-Associative-Arrays"><a href="#6-3-1-Objects-As-Associative-Arrays" class="headerlink" title="6.3.1 Objects As Associative Arrays"></a>6.3.1 Objects As Associative Arrays</h3><p>As explained in the preceding section, the following two JavaScript expressions have the same value:</p>
<blockquote>
<p>上文提到，下面两个表达式有相同的值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object.<span class="property">property</span></span><br><span class="line">object[<span class="string">&quot;property&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>The first syntax, using the dot and an identifier, is like the syntax used to access a static field of a struct or object in C or Java. The second syntax, using square brackets and a string, looks like array access, but to an array indexed by strings rather than by numbers. This kind of array is known as an associative array (or hash or map or dictionary). JavaScript objects are associative arrays, and this section explains why that is important.</p>
<blockquote>
<p>第一种语法使用点运算符和一个标识符，这和 C 和 Java 中访问一个结构体或对象的静态字段非常类似。第二种语法使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引。这种数组就是我们所说的关联数组（associative array）（也称做散列、映射或字典）。JavaScript 对象都是关联数组，本节将讨论它的重要性。</p>
</blockquote>
<p>In C, C++, Java, and similar strongly typed languages, an object can have only a fixed number of properties, and the names of these properties must be defined in advance. Since JavaScript is a loosely typed language, this rule does not apply: a program can create any number of properties in any object. When you use the . operator to access a property of an object, however, the name of the property is expressed as an identifier. Identifiers must be typed literally into your JavaScript program; they are not a datatype, so they cannot be manipulated by the program.</p>
<blockquote>
<p>在 C、C++、Java 和一些强类型语言中，对象只能拥有固定数目的属性，并且这些属性的名称必须提前定义好。由于 JavaScript 是一个弱类型语言，因此不适用这条规则：对象在程序中可以创建任意数量的属性。当使用 . 运算符访问对象的属性时，属性名用一个标识符来表示。标识符必须直接出现在 JavaScript 程序中，它们不是数据类型，所以无法在程序中修改。</p>
</blockquote>
<p>On the other hand, when you access a property of an object with the [] array notation, the name of the property is expressed as a string. Strings are JavaScript datatypes, so they can be manipulated and created while a program is running. So, for example, you can write the following code in JavaScript:</p>
<blockquote>
<p>另一种方式，当通过 [] 来访问对象的属性时，属性名通过字符串来表示。字符串是 JavaScript 的数据类型，在程序运行时可以修改和创建它们。因此，可以在 JavaScript 中使用下面这种代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addr = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    addr += customer[<span class="string">`address<span class="subst">$&#123;i&#125;</span>`</span>] + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code reads and concatenates the address0, address1, address2, and address3 properties of the customer object.</p>
<blockquote>
<p>这段代码读取 customer 对象的 address0、address1、address2 和 address3 属性，并将它们连接起来。</p>
</blockquote>
<p>This brief example demonstrates the flexibility of using array notation to access properties of an object with string expressions. This code could be rewritten using the dot notation, but there are cases in which only the array notation will do. Suppose, for example, that you are writing a program that uses network resources to compute the current value of the user’s stock market investments. The program allows the user to type in the name of each stock they own as well as the number of shares of each stock. You might use an object named portfolio to hold this information. The object has one property for each stock. The name of the property is the name of the stock, and the property value is the number of shares of that stock. So, for example, if a user holds 50 shares of stock in IBM, the portfolio.ibm property has the value 50.</p>
<blockquote>
<p>这个例子主要说明了通过字符串表达式使用数组标记来访问对象属性的灵活性。这段代码也可以通过点运算符来重写，但是一些场景只能使用数组写法来完成。假设你正在写一个程序，这个程序利用网络资源计算用户股票市场投资的当前价值。程序允许用户输入他们拥有的股票名称以及对应的数量。你可以用一个名为 portfolio 的对象来储存这些信息。每一个股票在对象中都有一个属性与之对应。属性名是股票名，属性值是股票持有份额。例如，如果用户持有 IBM 的 50 股，那么 portfolio.ibm 属性的值就为 50。</p>
</blockquote>
<p>Part of this program might be a function for adding a new stock to the portfolio:</p>
<blockquote>
<p>下面是程序的部分代码，这个函数用来给 portifolio 添加新的股票：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addstock</span>(<span class="params">portfolio, stockname, shares</span>) &#123;</span><br><span class="line">    portfolio[stockname] = shares;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since the user enters stock names at runtime, there is no way that you can know the property names ahead of time. Since you can’t know the property names when you write the program, there is no way you can use the . operator to access the properties of the portfolio object. You can use the [] operator, however, because it uses a string value (which is dynamic and can change at runtime) rather than an identifier (which is static and must be hardcoded in the program) to name the property.</p>
<blockquote>
<p>由于用户是在程序运行时输入股票名称，因此在之前无法得知这些股票的名称是什么。而由于在写程序的时候不知道属性名称，因此无法通过点运算符（.）来访问对象 portfolio 的属性。但可以使用 [] 运算符，因为它使用字符串值（字符串值是动态的，可以在运行时更改）而不是标识符（标识符是静态的，必须写死在程序中）作为索引对属性进行访问。</p>
</blockquote>
<p>In Chapter 5, we introduced the for&#x2F;in loop (and we’ll see it again shortly, in §6.6). The power of this JavaScript statement becomes clear when you consider its use with associative arrays. Here is how you would use it when computing the total value of a portfolio:</p>
<blockquote>
<p>第 5 章介绍了 for&#x2F;in 循环（§6.6 节还会进一步介绍）。当使用 for&#x2F;in 循环遍历关联数组时，就可以清晰地体会到 for&#x2F;in 的强大之处。下面的例子就是利用 for&#x2F;in 计算  portfolio 的合计值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">computeValue</span>(<span class="params">portfolio</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> stock <span class="keyword">in</span> portfolio) &#123;       <span class="comment">// For each stock in the portfolio:</span></span><br><span class="line">        <span class="keyword">let</span> shares = portfolio[stock];  <span class="comment">// get the number of shares</span></span><br><span class="line">        <span class="keyword">let</span> price = <span class="title function_">getQuote</span>(stock);    <span class="comment">// look up share price</span></span><br><span class="line">        total += shares * price;        <span class="comment">// add stock value to total value</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;                       <span class="comment">// Return total value.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript objects are commonly used as associative arrays as shown here, and it is important to understand how this works. In ES6 and later, however, the Map class described in §11.1.2 is often a better choice than using a plain object.</p>
<blockquote>
<p>如本节所示，JavaScript 对象通常用作关联数组，理解其工作原理非常重要。但是，在 ES6 之后使用 Map 类常常是一个更好的选择，我们将在 §11.1.2 中进行描述。</p>
</blockquote>
<h3 id="6-3-2-Inheritance"><a href="#6-3-2-Inheritance" class="headerlink" title="6.3.2 Inheritance"></a>6.3.2 Inheritance</h3><p>JavaScript objects have a set of “own properties,” and they also inherit a set of properties from their prototype object. To understand this, we must consider property access in more detail. The examples in this section use the Object.create() function to create objects with specified prototypes. We’ll see in Chapter 9, however, that every time you create an instance of a class with new, you are creating an object that inherits properties from a prototype object.</p>
<blockquote>
<p>JavaScript 对象中有一组“自有属性”，也有一组属性是继承自它的原型对象。想要理解属性继承，必须更深入地了解属性访问的细节。这一节的例子通过使用 Object.create() 函数创建对象来指定它的原型。我们会在第 9 章再次看到它，但是，每次使用 new 创建类的实例时，都会创建一个从原型对象继承属性的对象。</p>
</blockquote>
<p>Suppose you query the property x in the object o. If o does not have an own property with that name, the prototype object of o1 is queried for the property x. If the prototype object does not have an own property by that name, but has a prototype itself, the query is performed on the prototype of the prototype. This continues until the property x is found or until an object with a null prototype is searched. As you can see, the prototype attribute of an object creates a chain or linked list from which properties are inherited:</p>
<blockquote>
<p>假设要查询对象 o 的属性 x。如果 o 中不存在 x 名称的自由属性，那么将会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到 x 或者查找到一个原型是 null 的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;;               <span class="comment">// o inherits object methods from Object.prototype</span></span><br><span class="line">o.<span class="property">x</span> = <span class="number">1</span>;                  <span class="comment">// and it now has an own property x.</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">Object</span>.<span class="title function_">create</span>(o); <span class="comment">// p inherits properties from o and Object.prototype</span></span><br><span class="line">p.<span class="property">y</span> = <span class="number">2</span>;                  <span class="comment">// and has an own property y.</span></span><br><span class="line"><span class="keyword">let</span> q = <span class="title class_">Object</span>.<span class="title function_">create</span>(p); <span class="comment">// q inherits properties from p, o, and...</span></span><br><span class="line">q.<span class="property">z</span> = <span class="number">3</span>;                  <span class="comment">// ...Object.prototype and has an own property z.</span></span><br><span class="line"><span class="keyword">let</span> f = q.<span class="title function_">toString</span>();     <span class="comment">// toString is inherited from Object.prototype</span></span><br><span class="line">q.<span class="property">x</span> + q.<span class="property">y</span>                 <span class="comment">// =&gt; 3; x and y are inherited from o and p</span></span><br></pre></td></tr></table></figure>
<p>Now suppose you assign to the property x of the object o. If o already has an own (non-inherited) property named x, then the assignment simply changes the value of this existing property. Otherwise, the assignment creates a new property named x on the object o. If o previously inherited the property x, that inherited property is now hidden by the newly created own property with the same name.</p>
<blockquote>
<p>现在假设给对象 o 的属性 x 赋值，如果 o 中已经有属性 x（这个属性不是继承来的），那么这个赋值操作只改变这个已有属性 x 的值。否则，赋值操作给 o 添加一个新属性 x。如果之前 o 继承自属性 x，那么这个继承的属性就被新创建的同名属性覆盖了。</p>
</blockquote>
<p>Property assignment examines the prototype chain only to determine whether the assignment is allowed. If o inherits a read-only property named x, for example, then the assignment is not allowed. (Details about when a property may be set are in §6.3.3.) If the assignment is allowed, however, it always creates or sets a property in the original object and never modifies objects in the prototype chain. The fact that inheritance occurs when querying properties but not when setting them is a key feature of JavaScript because it allows us to selectively override inherited properties:</p>
<blockquote>
<p>属性赋值操作检查原型链只是判断是否允许赋值操作。例如，如果 o 继承自一个只读属性 x，那么赋值操作是不允许的（§6.3.3 将对此进行详细讨论）。 如果允许属性赋值操作，它也总是在原始对象上创建属性或对已有的属性赋值，而不会去修改原型链。在 JavaScript 中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关，这是 JavaScript 的一个重要特性，该特性让程序员可以有选择地重写继承的属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unitcircle = &#123; <span class="attr">r</span>: <span class="number">1</span> &#125;;         <span class="comment">// An object to inherit from</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="title class_">Object</span>.<span class="title function_">create</span>(unitcircle); <span class="comment">// c inherits the property r</span></span><br><span class="line">c.<span class="property">x</span> = <span class="number">1</span>; c.<span class="property">y</span> = <span class="number">1</span>;                  <span class="comment">// c defines two properties of its own</span></span><br><span class="line">c.<span class="property">r</span> = <span class="number">2</span>;                           <span class="comment">// c overrides its inherited property</span></span><br><span class="line">unitcircle.<span class="property">r</span>                       <span class="comment">// =&gt; 1: the prototype is not affected</span></span><br></pre></td></tr></table></figure>
<p>There is one exception to the rule that a property assignment either fails or creates or sets a property in the original object. If o inherits the property x, and that property is an accessor property with a setter method (see §6.10.6), then that setter method is called rather than creating a new property x in o. Note, however, that the setter method is called on the object o, not on the prototype object that defines the property, so if the setter method defines any properties, it will do so on o, and it will again leave the prototype chain unmodified.</p>
<blockquote>
<p>属性赋值要么失败，要么创建一个属性，要么在原始对象中设置属性。但有一个例外，如果 o 继承自属性 x，而这个属性是一个具有 setter 方法的存取器属性（参照 §6.10.6），那么这时将调用 setter 方法而不是给 o 创建一个属性 x。需要注意的是，setter 方法是由对象 o 调用的，而不是定义这个属性的原型对象调用的。因此如果 setter 方法定义任意属性，这个操作只是针对 o 本身，并不会修改原型链。</p>
</blockquote>
<h3 id="6-3-3-Property-Access-Errors"><a href="#6-3-3-Property-Access-Errors" class="headerlink" title="6.3.3 Property Access Errors"></a>6.3.3 Property Access Errors</h3><p>Property access expressions do not always return or set a value. This section explains the things that can go wrong when you query or set a property.</p>
<blockquote>
<p>属性访问表达式并不总是返回或设置一个值。本节讲述查询或设置属性时的一些出错情况。</p>
</blockquote>
<p>It is not an error to query a property that does not exist. If the property x is not found as an own property or an inherited property of o, the property access expression o.x evaluates to undefined. Recall that our book object has a “sub-title” property, but not a “subtitle” property:</p>
<blockquote>
<p>查询一个不存在的属性并不会报错，如果在对象 o 自身的属性或继承的属性中均未找到属性 x，属性访问表达式 o.x 返回 undefined。回想一下我们的 book 对象有属性“sub-title”，而没有属性“subtitle”：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.<span class="property">subtitle</span>    <span class="comment">// =&gt; undefined: property doesn&#x27;t exist</span></span><br></pre></td></tr></table></figure>
<p>It is an error, however, to attempt to query a property of an object that does not exist. The null and undefined values have no properties, and it is an error to query properties of these values. Continuing the preceding example:</p>
<blockquote>
<p>但是，如果对象不存在，那么试图查询这个不存在的对象的属性就会报错。null 和 undefined 值都没有属性，因此查询这些值的属性会报错，接上例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> len = book.<span class="property">subtitle</span>.<span class="property">length</span>; <span class="comment">// !TypeError: undefined doesn&#x27;t have length</span></span><br></pre></td></tr></table></figure>
<p>Property access expressions will fail if the lefthand side of the . is null or undefined. So when writing an expression like book.author.surname, you should be careful if you are not certain that book and book.author are actually defined. Here are two ways to guard against this kind of problem: </p>
<blockquote>
<p>如果 . 的左边是 null 或 undefined 时，其属性表达式会失败。所以当写一个像 book.author.surname 一样的表达式时，如果你不确定 book 和 book.author 确实被定义就要小心了。下面提供了两种避免出错的方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A verbose and explicit technique</span></span><br><span class="line"><span class="keyword">let</span> surname = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">if</span> (book) &#123;</span><br><span class="line">    <span class="keyword">if</span> (book.<span class="property">author</span>) &#123;</span><br><span class="line">        surname = book.<span class="property">author</span>.<span class="property">surname</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A concise and idiomatic alternative to get surname or null or undefined</span></span><br><span class="line">surname = book &amp;&amp; book.<span class="property">author</span> &amp;&amp; book.<span class="property">author</span>.<span class="property">surname</span>;</span><br></pre></td></tr></table></figure>
<p>To understand why this idiomatic expression works to prevent TypeError exceptions, you might want to review the short-circuiting behavior of the &amp;&amp; operator in §4.10.1.</p>
<blockquote>
<p>为了理解为什么这里的第二种方法可以避免类型错误异常，可以参照 §4.10.1节 中关于 &amp;&amp; 运算符的短路行为。</p>
</blockquote>
<p>As described in §4.4.1, ES2020 supports conditional property access with ?., which allows us to rewrite the previous assignment expression as:</p>
<blockquote>
<p>如 §4.4.1 中所描述，ES2020 支持用 ?. 条件属性访问，它允许这样重写上面的赋值表达式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> surname = book?.<span class="property">author</span>?.<span class="property">surname</span>;</span><br></pre></td></tr></table></figure>
<p>Attempting to set a property on null or undefined also causes a TypeError. Attempts to set properties on other values do not always succeed, either: some properties are read-only and cannot be set, and some objects do not allow the addition of new properties. In strict mode (§5.6.3), a TypeError is thrown whenever an attempt to set a property fails. Outside of strict mode, these failures are usually silent.</p>
<blockquote>
<p>当然，给 null 和 undefined 设置属性也会报类型错误。给其他值设置属性也不总是成功，有一些属性是只读的，不能重新赋值，有一些对象不允许新增属性。在严格模式下（§5.6.3），属性设定失败时会抛出 TypeError 异常。在非严格模式下，这些失败的处理经常没有任何反应。</p>
</blockquote>
<p>The rules that specify when a property assignment succeeds and when it fails are intuitive but difficult to express concisely. An attempt to set a property p of an object o fails in these circumstances:</p>
<blockquote>
<p>尽管属性赋值成功或失败的规律看起来很简单，但要描述清楚并不容易。在这些场景下给对象 o 设置属性 p 会失败：</p>
</blockquote>
<p>o has an own property p that is read-only: it is not possible to set read-only properties.</p>
<blockquote>
<p>o 中的属性 p 是只读的：不能给只读属性重新赋值。</p>
</blockquote>
<p>o has an inherited property p that is read-only: it is not possible to hide an inherited read-only property with an own property of the same name.</p>
<blockquote>
<p>o 中的属性 p 是继承属性，且它是只读的：不能通过同名自有属性覆盖只读的继承属性。</p>
</blockquote>
<p>o does not have an own property p; o does not inherit a property p with a setter method, and o’s extensible attribute (see §14.2) is false. Since p does not already exist in o, and if there is no setter method to call, then p must be added to o. But if o is not extensible, then no new properties can be defined on it.</p>
<blockquote>
<p>o 中不存在自有属性 p：o 没有使用 setter 方法继承属性 p，并且o的可扩展性是（见 §14.2）false。如果 o 中不存在 p，而且没有 setter 方法可供调用，则 p 一定会添加至 o 中。但如果 o 不是可扩展的，那么在 o 中不能定义新属性。</p>
</blockquote>
<h2 id="6-4-Deleting-Properties"><a href="#6-4-Deleting-Properties" class="headerlink" title="6.4 Deleting Properties"></a>6.4 Deleting Properties</h2><p>The delete operator (§4.13.4) removes a property from an object. Its single operand should be a property access expression. Surprisingly, delete does not operate on the value of the property but on the property itself:</p>
<blockquote>
<p>删除运算符（§4.13.4）能删除对象中的属性。它的操作数应当是一个属性访问表达式。令人意外的是，delete 没有操作属性的值，而是操作属性的属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> book.<span class="property">author</span>;          <span class="comment">// The book object now has no author property.</span></span><br><span class="line"><span class="keyword">delete</span> book[<span class="string">&quot;main title&quot;</span>];   <span class="comment">// Now it doesn&#x27;t have &quot;main title&quot;, either.</span></span><br></pre></td></tr></table></figure>
<p>The delete operator only deletes own properties, not inherited ones. (To delete an inherited property, you must delete it from the prototype object in which it is defined. Doing this affects every object that inherits from that prototype.)</p>
<blockquote>
<p>delete 运算符只删除自有属性，不删除继承属性。（想要删除一个继承属性，必须从定义这个属性的原型对象上删除它。这会影响所有继承这个原型的对象。）</p>
</blockquote>
<p>A delete expression evaluates to true if the delete succeeded or if the delete had no effect (such as deleting a nonexistent property). delete also evaluates to true when used (meaninglessly) with an expression that is not a property access expression:</p>
<blockquote>
<p>如果删除成功或删除没有任何影响时删除表达式计算结果是 true（如删除不存在的属性）。delete 作用于非属性访问表达式（无用代码）时也返回 true。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;    <span class="comment">// o has own property x and inherits property toString</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">x</span>         <span class="comment">// =&gt; true: deletes property x</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">x</span>         <span class="comment">// =&gt; true: does nothing (x doesn&#x27;t exist) but true anyway</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">toString</span>  <span class="comment">// =&gt; true: does nothing (toString isn&#x27;t an own property)</span></span><br><span class="line"><span class="keyword">delete</span> <span class="number">1</span>           <span class="comment">// =&gt; true: nonsense, but true anyway</span></span><br></pre></td></tr></table></figure>
<p>delete does not remove properties that have a configurable attribute of false. Certain properties of built-in objects are non-configurable, as are properties of the global object created by variable declaration and function declaration. In strict mode, attempting to delete a non-configurable property causes a TypeError. In non-strict mode, delete simply evaluates to false in this case:</p>
<blockquote>
<p>delete 不能删除那些可配置性为 false 的属性。某些内置对象的属性是不可配置的，比如通过变量声明和函数声明创建的全局对象的属性。在严格模式中，删除一个不可配置属性会报一个类型错误。在非严格模式中，在这些情况下的 delete 操作会返回 false：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In strict mode, all these deletions throw TypeError instead of returning false</span></span><br><span class="line"><span class="keyword">delete</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// =&gt; false: property is non-configurable</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;              <span class="comment">// Declare a global variable</span></span><br><span class="line"><span class="keyword">delete</span> globalThis.<span class="property">x</span>     <span class="comment">// =&gt; false: can&#x27;t delete this property</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;         <span class="comment">// Declare a global function</span></span><br><span class="line"><span class="keyword">delete</span> globalThis.<span class="property">f</span>     <span class="comment">// =&gt; false: can&#x27;t delete this property either</span></span><br></pre></td></tr></table></figure>
<p>When deleting configurable properties of the global object in non-strict mode, you can omit the reference to the global object and simply follow the delete operator with the property name:</p>
<blockquote>
<p>当在非严格模式中删除全局对象的可配值属性时，可以省略对全局对象的引用，直接在 delete 操作符后跟随要删除的属性名即可：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">globalThis.<span class="property">x</span> = <span class="number">1</span>;       <span class="comment">// Create a configurable global property (no let or var)</span></span><br><span class="line"><span class="keyword">delete</span> x                <span class="comment">// =&gt; true: this property can be deleted</span></span><br></pre></td></tr></table></figure>
<p>In strict mode, however, delete raises a SyntaxError if its operand is an unqualified identifier like x, and you have to be explicit about the property access:</p>
<blockquote>
<p>然而在严格模式中，delete 后跟随一个非法的操作数（比如 x），则会报一个语法错误，因此必须显式指定对象及其属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> x;               <span class="comment">// SyntaxError in strict mode</span></span><br><span class="line"><span class="keyword">delete</span> globalThis.<span class="property">x</span>;    <span class="comment">// This works</span></span><br></pre></td></tr></table></figure>
<h2 id="6-5-Testing-Properties"><a href="#6-5-Testing-Properties" class="headerlink" title="6.5 Testing Properties"></a>6.5 Testing Properties</h2><p>JavaScript objects can be thought of as sets of properties, and it is often useful to be able to test for membership in the set—to check whether an object has a property with a given name. You can do this with the in operator, with the hasOwnProperty() and propertyIsEnumerable() methods, or simply by querying the property. The examples shown here all use strings as property names, but they also work with Symbols (§6.10.3).</p>
<blockquote>
<p>JavaScript 对象可以看作属性的集合，我们经常会检测集合中成员的所属关系——判断某个属性是否存在于某个对象中。可以用 in 运算符、hasOwnPreperty() 和  propertyIsEnumerable() 方法来完成这个工作，甚至仅通过属性查询也可以做到这一点。这节的例子都是用字符串作为属性名称，但是也可以用 Symbol 作为属性名（§6.10.3）。</p>
</blockquote>
<p>The in operator expects a property name on its left side and an object on its right. It returns true if the object has an own property or an inherited property by that name:</p>
<blockquote>
<p>in 运算符的左侧是属性名，右侧是对象。如果对象的自有属性或继承属性中包含这个属性则返回 true：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&quot;x&quot;</span> <span class="keyword">in</span> o         <span class="comment">// =&gt; true: o has an own property &quot;x&quot;</span></span><br><span class="line"><span class="string">&quot;y&quot;</span> <span class="keyword">in</span> o         <span class="comment">// =&gt; false: o doesn&#x27;t have a property &quot;y&quot;</span></span><br><span class="line"><span class="string">&quot;toString&quot;</span> <span class="keyword">in</span> o  <span class="comment">// =&gt; true: o inherits a toString property</span></span><br></pre></td></tr></table></figure>
<p>The hasOwnProperty() method of an object tests whether that object has an own property with the given name. It returns false for inherited properties:</p>
<blockquote>
<p>对象的 hasOwnProperty() 方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回 false：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;x&quot;</span>)        <span class="comment">// =&gt; true: o has an own property x</span></span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;y&quot;</span>)        <span class="comment">// =&gt; false: o doesn&#x27;t have a property y</span></span><br><span class="line">o.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;toString&quot;</span>) <span class="comment">// =&gt; false: toString is an inherited property</span></span><br></pre></td></tr></table></figure>
<p>The propertyIsEnumerable() refines the hasOwnProperty() test. It returns true only if the named property is an own property and its enumerable attribute is true. Certain built-in properties are not enumerable. Properties created by normal JavaScript code are enumerable unless you’ve used one of the techniques shown in §14.1 to make them non-enumerable.</p>
<blockquote>
<p>propertyIsEnumerable() 是 hasOwnProperty() 的增强版。只有检测到是自有属性且这个属性的可枚举性为 true 时它才返回 true。某些内置属性是不可枚举的。通常由 JavaScript 代码创建的属性都是可枚举的，除非使用  §14.1 中介绍的技术来让它们不可枚举。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;x&quot;</span>)  <span class="comment">// =&gt; true: o has an own enumerable property x</span></span><br><span class="line">o.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;toString&quot;</span>)  <span class="comment">// =&gt; false: not an own property</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;toString&quot;</span>) <span class="comment">// =&gt; false: not enumerable</span></span><br></pre></td></tr></table></figure>
<p>Instead of using the in operator, it is often sufficient to simply query the property and use !&#x3D;&#x3D; to make sure it is not undefined:</p>
<blockquote>
<p>除了使用 in 运算符之外，另一种更简便的方法是使用 !&#x3D;&#x3D; 判断一个属性是否是 undefined：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.<span class="property">x</span> !== <span class="literal">undefined</span>        <span class="comment">// =&gt; true: o has a property x</span></span><br><span class="line">o.<span class="property">y</span> !== <span class="literal">undefined</span>        <span class="comment">// =&gt; false: o doesn&#x27;t have a property y</span></span><br><span class="line">o.<span class="property">toString</span> !== <span class="literal">undefined</span> <span class="comment">// =&gt; true: o inherits a toString property</span></span><br></pre></td></tr></table></figure>
<p>There is one thing the in operator can do that the simple property access technique shown here cannot do. in can distinguish between properties that do not exist and properties that exist but have been set to undefined. Consider this code:</p>
<blockquote>
<p>然而有一种场景只能使用 in 运算符而不能使用上述属性访问的方式。in 可以区分不存在的属性和存在但值为 undefined 的属性。例如下面的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="literal">undefined</span> &#125;;  <span class="comment">// Property is explicitly set to undefined</span></span><br><span class="line">o.<span class="property">x</span> !== <span class="literal">undefined</span>          <span class="comment">// =&gt; false: property exists but is undefined</span></span><br><span class="line">o.<span class="property">y</span> !== <span class="literal">undefined</span>          <span class="comment">// =&gt; false: property doesn&#x27;t even exist</span></span><br><span class="line"><span class="string">&quot;x&quot;</span> <span class="keyword">in</span> o                   <span class="comment">// =&gt; true: the property exists</span></span><br><span class="line"><span class="string">&quot;y&quot;</span> <span class="keyword">in</span> o                   <span class="comment">// =&gt; false: the property doesn&#x27;t exist</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">x</span>;                <span class="comment">// Delete the property x</span></span><br><span class="line"><span class="string">&quot;x&quot;</span> <span class="keyword">in</span> o                   <span class="comment">// =&gt; false: it doesn&#x27;t exist anymore</span></span><br></pre></td></tr></table></figure>
<h2 id="6-6-Enumerating-Properties"><a href="#6-6-Enumerating-Properties" class="headerlink" title="6.6 Enumerating Properties"></a>6.6 Enumerating Properties</h2><p>Instead of testing for the existence of individual properties, we sometimes want to iterate through or obtain a list of all the properties of an object. There are a few different ways to do this.</p>
<blockquote>
<p>除了检测对象的属性是否存在，我们还会经常遍历对象的属性。有几种不同的方法可以做到这一点。</p>
</blockquote>
<p>The for&#x2F;in loop was covered in §5.4.5. It runs the body of the loop once for each enumerable property (own or inherited) of the specified object, assigning the name of the property to the loop variable. Built-in methods that objects inherit are not enumerable, but the properties that your code adds to objects are enumerable by default. For example:</p>
<blockquote>
<p>§5.4.5 讨论过 for&#x2F;in 循环，其可以在循环体中遍历指定对象中所有可枚举的属性（包括自有属性和继承的属性），把属性名称赋值给循环变量。对象继承的 内置方法不可枚举的，但在代码中给对象添加的属性都是可枚举的（除非用下文中提到的一个方法将它们转换为不可枚举的）。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;          <span class="comment">// Three enumerable own properties</span></span><br><span class="line">o.<span class="title function_">propertyIsEnumerable</span>(<span class="string">&quot;toString&quot;</span>)   <span class="comment">// =&gt; false: not enumerable</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;                    <span class="comment">// Loop through the properties</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p);                  <span class="comment">// Prints x, y, and z, but not toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To guard against enumerating inherited properties with for&#x2F;in, you can add an explicit check inside the loop body:</p>
<blockquote>
<p>为了防止 for&#x2F;in 枚举到继承属性，可以在循环中添加显示检查：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!o.<span class="title function_">hasOwnProperty</span>(p)) <span class="keyword">continue</span>;       <span class="comment">// Skip inherited properties</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> o[p] === <span class="string">&quot;function&quot;</span>) <span class="keyword">continue</span>; <span class="comment">// Skip all methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As an alternative to using a for&#x2F;in loop, it is often easier to get an array of property names for an object and then loop through that array with a for&#x2F;of loop. There are four functions you can use to get an array of property names:</p>
<blockquote>
<p>作为使用 for&#x2F;in 循环的替代方法，通常使用 for&#x2F;of 循环遍历易获取对象的属性名称数组。可以使用四个函数获取属性名称数组：</p>
</blockquote>
<p>Object.keys() returns an array of the names of the enumerable own properties of an object. It does not include non-enumerable properties, inherited properties, or properties whose name is a Symbol (see §6.10.3).</p>
<blockquote>
<p>Object.keys() 返回对象的可枚举自有属性名称数组集合。数组内不包含不可枚举属性、继承属性或属性名称是 Symbol（见 §6.10.3）的属性</p>
</blockquote>
<p>Object.getOwnPropertyNames() works like Object.keys() but returns an array of the names of non-enumerable own properties as well, as long as their names are strings.</p>
<blockquote>
<p>Object.getOwnPropertyNames() 用起来和 Object.keys() 类似，但是它返回数组中也包含不可迭代的自有属性，只要它们的名称是字符串。</p>
</blockquote>
<p>Object.getOwnPropertySymbols() returns own properties whose names are Symbols, whether or not they are enumerable.</p>
<blockquote>
<p>Object.getOwnPropertySymbols() 返回名称是 Symbol 的自有属性，无论它们是否可枚举。</p>
</blockquote>
<p>Reflect.ownKeys() returns all own property names, both enumerable and non-enumerable, and both string and Symbol. (See §14.6.)</p>
<blockquote>
<p>Reflect.ownKeys() 返回所有的自由属性名称，包括可枚举和不可枚举类型，也包括字符串和 Symbol（见 §14.6）。</p>
</blockquote>
<p>There are examples of the use of Object.keys() with a for&#x2F;of loop in §6.7.</p>
<blockquote>
<p>在 §6.7 中有例子使用 for&#x2F;of 循环 Object.keys()。</p>
</blockquote>
<h3 id="6-6-1-Property-Enumeration-Order"><a href="#6-6-1-Property-Enumeration-Order" class="headerlink" title="6.6.1 Property Enumeration Order"></a>6.6.1 Property Enumeration Order</h3><p>ES6 formally defines the order in which the own properties of an object are enumerated. Object.keys(), Object.getOwnPropertyNames(), Object.getOwnPropertySymbols(), Reflect.ownKeys(), and related methods such as JSON.stringify() all list properties in the following order, subject to their own additional constraints about whether they list non-enumerable properties or properties whose names are strings or Symbols:</p>
<blockquote>
<p>ES6 正式定义元素的自有属性的枚举顺序。Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Reflect.ownKeys() 和相关方法如 JSON.stringify() 属性列表都按以下顺序排列的，受它们自身是否是不可枚举属性列表或者属性是字符串或者 Symbol 影响：</p>
</blockquote>
<p>String properties whose names are non-negative integers are listed first, in numeric order from smallest to largest. This rule means that arrays and array-like objects will have their properties enumerated in order.</p>
<blockquote>
<p>首先列出名称为非负整数的字符串属性，按从最小到最大的数字顺序列出。此规则意味着数组和数组类对象将按顺序枚举其属性。</p>
</blockquote>
<p>After all properties that look like array indexes are listed, all remaining properties with string names are listed (including properties that look like negative numbers or floating-point numbers). These properties are listed in the order in which they were added to the object. For properties defined in an object literal, this order is the same order they appear in the literal.</p>
<blockquote>
<p>列出所有看起来像数组索引的属性后，将列出所有具有字符串名称的剩余属性（包括看起来像负数或浮点数字的属性）。这些属性按添加到对象的顺序列出。对于在对象字面量中定义的属性，此顺序与它们在文本中显示的顺序相同。</p>
</blockquote>
<p>Finally, the properties whose names are Symbol objects are listed in the order in which they were added to the object.</p>
<blockquote>
<p>最后，其名称为 Symbol 对象的属性按添加到对象的顺序列出。</p>
</blockquote>
<p>The enumeration order for the for&#x2F;in loop is not as tightly specified as it is for these enumeration functions, but implementations typically enumerate own properties in the order just described, then travel up the prototype chain enumerating properties in the same order for each prototype object. Note, however, that a property will not be enumerated if a property by that same name has already been enumerated, or even if a non-enumerable property by the same name has already been considered.</p>
<blockquote>
<p>for&#x2F;in 循环的枚举顺序不像这些枚举函数那样严格指定，但实现通常按刚才描述的顺序枚举自己的属性，然后向上移动原型链按相同顺序枚举每个原型对象的属性。但是请注意，如果已枚举具有相同名称的属性，或者不可枚举属性已经被检测过再次枚举到相同名称的属性，都不会再次枚举。</p>
</blockquote>
<h2 id="6-7-Extending-Objects"><a href="#6-7-Extending-Objects" class="headerlink" title="6.7 Extending Objects"></a>6.7 Extending Objects</h2><p>A common operation in JavaScript programs is needing to copy the properties of one object to another object. It is easy to do that with code like this:</p>
<blockquote>
<p>在 JavaScript 代码中有一个很常见的操作，需要将一个对象中的属性拷贝到另外一个对象。以下面的代码很容易实现：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, source = &#123;<span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(source)) &#123;</span><br><span class="line">    target[key] = source[key];</span><br><span class="line">&#125;</span><br><span class="line">target  <span class="comment">// =&gt; &#123;x: 1, y: 2, z: 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>But because this is a common operation, various JavaScript frameworks have defined utility functions, often named extend(), to perform this copying operation. Finally, in ES6, this ability comes to the core JavaScript language in the form of Object.assign().</p>
<blockquote>
<p>但是因为这个是个常用的操作，各种 JavaScript 框架定义公用函数，经常将其命名为 extend() 来执行这个拷贝操作。最后在 ES6 中，这个功能以 Object.assign() 的形式被添加到 JavaScript 核心语言中。</p>
</blockquote>
<p>Object.assign() expects two or more objects as its arguments. It modifies and returns the first argument, which is the target object, but does not alter the second or any subsequent arguments, which are the source objects. For each source object, it copies the enumerable own properties of that object (including those whose names are Symbols) into the target object. It processes the source objects in argument list order so that properties in the first source object override properties by the same name in the target object and properties in the second source object (if there is one) override properties with the same name in the first source object.</p>
<blockquote>
<p>Object.assign() 需要两个或多个对象作为其实参。它修改并返回第一个实参，即目标对象，但不会改变第二个或任何后续参数，这些参数是源对象。对于每个源对象，它将该对象的可枚举自有属性（包括名称为 Symbol 的属性）复制到目标对象中。它按源对象在实参列表顺序中的顺序处理，所以第一个源对象中的属性会重写在目标对象中的同名属性，然后以第二个源对象中的同名属性（如果有第二个源对象）再次重写第一个源对象重写后的属性。</p>
</blockquote>
<p>Object.assign() copies properties with ordinary property get and set operations, so if a source object has a getter method or the target object has a setter method, they will be invoked during the copy, but they will not themselves be copied.</p>
<blockquote>
<p>Object.assign() 通过普通属性的 get 和 set 操作复制属性，因此，如果源对象具有 getter 方法或目标对象具有 setter 方法，则将在复制期间调用它们，但不会复制方法本身。</p>
</blockquote>
<p>One reason to assign properties from one object into another is when you have an object that defines default values for many properties and you want to copy those default properties into another object if a property by that name does not already exist in that object. Using Object.assign() naively will not do what you want:</p>
<blockquote>
<p>看这样一个场景，有一个对象定义许多属性的默认值，希望将这些默认属性中不存在于目标对象中的属性复制到目标对象中，使用 Object.assign() 不会得到想要的结果：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(o, defaults);  <span class="comment">// overwrites everything in o with defaults</span></span><br></pre></td></tr></table></figure>
<p>Instead, what you can do is to create a new object, copy the defaults into it, and then override those defaults with the properties in o:</p>
<blockquote>
<p>想得到这个效果需要创建一个新的对象，将默认值拷贝到其中，然后用 o 的属性重写默认值中的属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, defaults, o);</span><br></pre></td></tr></table></figure>
<p>We’ll see in §6.10.4 that you can also express this object copy-and-override operation using the … spread operator like this:</p>
<blockquote>
<p>我们会在 §6.10.4 见到，可以用 … 展开操作符如下操作这个对象拷贝并重写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o = &#123;...defaults, ...o&#125;;</span><br></pre></td></tr></table></figure>
<p>We could also avoid the overhead of the extra object creation and copying by writing a version of Object.assign() that copies properties only if they are missing:</p>
<blockquote>
<p>为了避免对象创建和复制的额外开销，我们还可以通过编写一个 Object.assign() 仅在缺少属性时复制属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like Object.assign() but doesn&#x27;t override existing properties</span></span><br><span class="line"><span class="comment">// (and also doesn&#x27;t handle Symbol properties)</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">target, ...sources</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> source <span class="keyword">of</span> sources) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(source)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(key <span class="keyword">in</span> target)) &#123; <span class="comment">// This is different than Object.assign()</span></span><br><span class="line">                target[key] = source[key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">y</span>: <span class="number">3</span>, <span class="attr">z</span>: <span class="number">4</span>&#125;)  <span class="comment">// =&gt; &#123;x: 2, y: 3, z: 4&#125;</span></span><br><span class="line"><span class="title function_">merge</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">2</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">y</span>: <span class="number">3</span>, <span class="attr">z</span>: <span class="number">4</span>&#125;)          <span class="comment">// =&gt; &#123;x: 1, y: 2, z: 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>It is straightforward to write other property manipulation utilities like this merge() function. A restrict() function could delete properties of an object if they do not appear in another template object, for example. Or a subtract() function could remove all of the properties of one object from another object.</p>
<blockquote>
<p>编写其他属性操作公共函数很简单，就是像这个 merge() 函数。例如，如果对象的属性不出现在另一个模板对象中，则 restrict() 函数会删除这些属性。或者，subtract() 函数可以从其他对象中删除一个对象的所有属性。</p>
</blockquote>
<h2 id="6-8-Serializing-Objects"><a href="#6-8-Serializing-Objects" class="headerlink" title="6.8 Serializing Objects"></a>6.8 Serializing Objects</h2><p>Object serialization is the process of converting an object’s state to a string from which it can later be restored. The functions JSON.stringify() and JSON.parse() serialize and restore JavaScript objects. These functions use the JSON data interchange format. JSON stands for “JavaScript Object Notation,” and its syntax is very similar to that of JavaScript object and array literals:</p>
<blockquote>
<p>对象序列化（serialization）是指将对象的状态转换为字符串，也可将字符串还原为对象。函数 JSON.stringify() 和 JSON.parse() 用来序列化和还原 JavaScript 对象。这些方法都使用 JSON 作为数据交换格式，JSON 的全称是“JavaScript Object Notation”——JavaScript 对象表示法，它的语法和 JavaScript 对象与数组字面量的语法非常相近：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: &#123;<span class="attr">z</span>: [<span class="literal">false</span>, <span class="literal">null</span>, <span class="string">&quot;&quot;</span>]&#125;&#125;; <span class="comment">// Define a test object</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(o);   <span class="comment">// s == &#x27;&#123;&quot;x&quot;:1,&quot;y&quot;:&#123;&quot;z&quot;:[false,null,&quot;&quot;]&#125;&#125;&#x27;</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(s);       <span class="comment">// p == &#123;x: 1, y: &#123;z: [false, null, &quot;&quot;]&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>JSON syntax is a subset of JavaScript syntax, and it cannot represent all JavaScript values. Objects, arrays, strings, finite numbers, true, false, and null are supported and can be serialized and restored. NaN, Infinity, and -Infinity are serialized to null. Date objects are serialized to ISO-formatted date strings (see the Date.toJSON() function), but JSON.parse() leaves these in string form and does not restore the original Date object. Function, RegExp, and Error objects and the undefined value cannot be serialized or restored. JSON.stringify() serializes only the enumerable own properties of an object. If a property value cannot be serialized, that property is simply omitted from the stringified output. Both JSON.stringify() and JSON.parse() accept optional second arguments that can be used to customize the serialization and&#x2F;or restoration process by specifying a list of properties to be serialized, for example, or by converting certain values during the serialization or stringification process. Complete documentation for these functions is in §11.6.</p>
<blockquote>
<p>JSON 的语法是 JavaScript 语法的子集，它并不能表示 JavaScript 里的所有值。支持对象、数组、字符串、无穷大数字、true、false 和 null，并且它们可以序列化和还原。NaN、Infinity 和 -Infinity 序列化的结果是 null，日期对象序列化的结果是 ISO 格式的日期字符串（参照 Date.toJSON() 函数），但 JSON.parse() 依然保留它们的字符串形态，而不会将它们还原为原始日期对象。函数、RegExp、Error 对象和 undefined 值不能序列化和还原。JSON.stringify() 只能序列化对象可枚举的自有属性。对于一个不能序列化的属性来说，在序列化后的输出字符串中会将这个属性省略掉。JSON.stringify() 和 JSON.parse() 都可以接收第二个可选实参，通过传入需要序列化或还原的属性列表来定制自定义的序列化或还原操作。§11.6 有关于这些函数的详细文档。</p>
</blockquote>
<h2 id="6-9-Object-Methods"><a href="#6-9-Object-Methods" class="headerlink" title="6.9 Object Methods"></a>6.9 Object Methods</h2><p>As discussed earlier, all JavaScript objects (except those explicitly created without a prototype) inherit properties from Object.prototype. These inherited properties are primarily methods, and because they are universally available, they are of particular interest to JavaScript programmers. We’ve already seen the hasOwnProperty() and propertyIsEnumerable() methods, for example. (And we’ve also already covered quite a few static functions defined on the Object constructor, such as Object.create() and Object.keys().) This section explains a handful of universal object methods that are defined on Object.prototype, but which are intended to be replaced by other, more specialized implementations. In the sections that follow, we show examples of defining these methods on a single object. In Chapter 9, you’ll learn how to define these methods more generally for an entire class of objects.</p>
<blockquote>
<p>上文已经讨论过，所有的 JavaScript 对象都从 Object.prototype 继承属性（除了那些不通过原型显式创建的对象）。这些继承属性主要是方法，因为 JavaScript 程序员普遍对继承方法更感兴趣。例如我们已经见过的 hasOwnProperty() 和 propertyIsEnumerable() 方法。（并且我们也已经提到了一小部分定义在对象构造函数中的静态函数，像 Object.create() 和 Object.keys()。）本节介绍在 Object.prototype 上定义的少数通用对象方法，但是这些方法经常会被更专业的实现所取代。在下面的各节中，我们将展示在单个对象上定义这些方法的示例。在第 9 章中，将学习如何更常规化地为整个对象类定义这些方法。</p>
</blockquote>
<h3 id="6-9-1-The-toString-Method"><a href="#6-9-1-The-toString-Method" class="headerlink" title="6.9.1 The toString() Method"></a>6.9.1 The toString() Method</h3><p>The toString() method takes no arguments; it returns a string that somehow represents the value of the object on which it is invoked. JavaScript invokes this method of an object whenever it needs to convert the object to a string. This occurs, for example, when you use the + operator to concatenate a string with an object or when you pass an object to a method that expects a string.</p>
<blockquote>
<p>toString() 方法没有实参，它将返回一个表示调用这个方法的对象值的字符串。在需要将对象转换为字符串的时候，JavaScript 都会调用这个方法。比如，当使用 + 运算符连接一个字符串和一个对象时或者在希望使用字符串的方法中使用了对象时都会调用 toString()。</p>
</blockquote>
<p>The default toString() method is not very informative (though it is useful for determining the class of an object, as we will see in §14.4.3). For example, the following line of code simply evaluates to the string “[object Object]”:</p>
<blockquote>
<p>默认的 toString() 方法的返回值带有的信息量很少（尽管它在检测对象的类型时非常有用，参照 §14.4.3），例如，下面这行代码的计算结果为字符串”[object Object]”：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;.<span class="title function_">toString</span>();  <span class="comment">// s == &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>
<p>Because this default method does not display much useful information, many classes define their own versions of toString(). For example, when an array is converted to a string, you obtain a list of the array elements, themselves each converted to a string, and when a function is converted to a string, you obtain the source code for the function. You might define your own toString() method like this:</p>
<blockquote>
<p>由于默认的 toString() 方法并不会输出很多有用的信息，因此很多类都带有自定义的 toString()。例如，当数组转换为字符串的时候，结果是一个数组元素列表，只是每个元素都转换成了字符串，再比如，当函数转换为字符串的时候，得到函数的源代码。可以像下面这样自定义 toString() 方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="variable language_">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.y&#125;</span>)`</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">String</span>(point)    <span class="comment">// =&gt; &quot;(1, 2)&quot;: toString() is used for string conversions</span></span><br></pre></td></tr></table></figure>
<h3 id="6-9-2-The-toLocaleString-Method"><a href="#6-9-2-The-toLocaleString-Method" class="headerlink" title="6.9.2 The toLocaleString() Method"></a>6.9.2 The toLocaleString() Method</h3><p>In addition to the basic toString() method, objects all have a toLocaleString(). The purpose of this method is to return a localized string representation of the object. The default toLocaleString() method defined by Object doesn’t do any localization itself: it simply calls toString() and returns that value. The Date and Number classes define customized versions of toLocaleString() that attempt to format numbers, dates, and times according to local conventions. Array defines a toLocaleString() method that works like toString() except that it formats array elements by calling their toLocaleString() methods instead of their toString() methods. You might do the same thing with a point object like this:</p>
<blockquote>
<p>除了基本的 toString() 方法之外，对象都包含 toLocaleString() 方法，这个方法返回一个表示这个对象的本地化字符串。Object 中默认的 toLocaleString() 方法并不做任何本地化自身的操作，它仅调用 toString() 方法并返回对应值。Date 和 Number 类对 toLocaleString() 方法做了定制，可以用它对数字、日期和时间做本地化的转换。 Array 类的 toLocaleString() 方法和 toString() 方法很像，唯一的不同是每个数组元素会调用 toLocaleString() 方法转换为字符串，而不是调用各自的 toString() 方法。可以像这样使用 point 对象做到同样的效果：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2000</span>,</span><br><span class="line">    <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="variable language_">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.y&#125;</span>)`</span>; &#125;,</span><br><span class="line">    <span class="attr">toLocaleString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="variable language_">this</span>.x.toLocaleString()&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.y.toLocaleString()&#125;</span>)`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">point.<span class="title function_">toString</span>()        <span class="comment">// =&gt; &quot;(1000, 2000)&quot;</span></span><br><span class="line">point.<span class="title function_">toLocaleString</span>()  <span class="comment">// =&gt; &quot;(1,000, 2,000)&quot;: note thousands separators</span></span><br></pre></td></tr></table></figure>
<p>The internationalization classes documented in §11.7 can be useful when implementing a toLocaleString() method.</p>
<blockquote>
<p>在 §11.7 的国际化类中，toLocaleString() 方法的实现是非常有用的。</p>
</blockquote>
<h3 id="6-9-3-The-valueOf-Method"><a href="#6-9-3-The-valueOf-Method" class="headerlink" title="6.9.3 The valueOf() Method"></a>6.9.3 The valueOf() Method</h3><p>The valueOf() method is much like the toString() method, but it is called when JavaScript needs to convert an object to some primitive type other than a string—typically, a number. JavaScript calls this method automatically if an object is used in a context where a primitive value is required. The default valueOf() method does nothing interesting, but some of the built-in classes define their own valueOf() method. The Date class defines valueOf() to convert dates to numbers, and this allows Date objects to be chronologically compared with &lt; and &gt;. You could do something similar with a point object, defining a valueOf() method that returns the distance from the origin to the point:</p>
<blockquote>
<p>valueOf() 方法和 toString() 方法非常类似，但往往当 JavaScript 需要将对象转换为某种原始值而非字符串的时候才会调用它，尤其是转换为数字的时候。如果在需要使用原始值的上下文中使用了对象，JavaScript 就会自动调用这个方法。默认的 valueOf() 方法不足为奇，但有些内置类自定义了 valueOf() 方法. Date 类定义 valueOf() 将日期转化成数值型，并且这允许 Date 对象使用 &lt; 和 &gt; 按时间先手顺序比较。可以对 point 对象做同样的事，定义一个 valueOf() 方法返回原点到点的距离：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Number</span>(point)  <span class="comment">// =&gt; 5: valueOf() is used for conversions to numbers</span></span><br><span class="line">point &gt; <span class="number">4</span>      <span class="comment">// =&gt; true</span></span><br><span class="line">point &gt; <span class="number">5</span>      <span class="comment">// =&gt; false</span></span><br><span class="line">point &lt; <span class="number">6</span>      <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<h3 id="6-9-4-The-toJSON-Method"><a href="#6-9-4-The-toJSON-Method" class="headerlink" title="6.9.4 The toJSON() Method"></a>6.9.4 The toJSON() Method</h3><p>Object.prototype does not actually define a toJSON() method, but the JSON.stringify() method (see §6.8) looks for a toJSON() method on any object it is asked to serialize. If this method exists on the object to be serialized, it is invoked, and the return value is serialized, instead of the original object. The Date class (§11.4) defines a toJSON() method that returns a serializable string representation of the date. We could do the same for our Point object like this:</p>
<blockquote>
<p>Object.prototype 实际上没有定义 toJSON() 方法，但对于需要执行序列化的对象来说，JSON.stringify() 方法（见 §6.8）会调用 toJSON() 方法。如果在待序列化的对象中存在这 个方法，则调用它，返回值即是序列化的结果，而不是原始的对象。Date 类（§11.4）定义了 toJSON() 方法返回日期的序列化字符串。我们可以这样对 point 对象做同样的事：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> point = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="variable language_">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.y&#125;</span>)`</span>; &#125;,</span><br><span class="line">    <span class="attr">toJSON</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>([point])   <span class="comment">// =&gt; &#x27;[&quot;(1, 2)&quot;]&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="6-10-Extended-Object-Literal-Syntax"><a href="#6-10-Extended-Object-Literal-Syntax" class="headerlink" title="6.10 Extended Object Literal Syntax"></a>6.10 Extended Object Literal Syntax</h2><p>Recent versions of JavaScript have extended the syntax for object literals in a number of useful ways. The following subsections explain these extensions.</p>
<blockquote>
<p>JavaScript 的最新版本扩展了许多有用的对象字面量相关的语法。以下小节解释这些扩展。</p>
</blockquote>
<h3 id="6-10-1-Shorthand-Properties"><a href="#6-10-1-Shorthand-Properties" class="headerlink" title="6.10.1 Shorthand Properties"></a>6.10.1 Shorthand Properties</h3><p>Suppose you have values stored in variables x and y and want to create an object with properties named x and y that hold those values. With basic object literal syntax, you’d end up repeating each identifier twice:</p>
<blockquote>
<p>假设值存储在变量 x 和 y 中，并且想要创建具有名为 x 和 y 的属性的对象，这些属性包含这些值。使用基本对象字面量语法，最终会重复每个标识符两次：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="attr">x</span>: x,</span><br><span class="line">    <span class="attr">y</span>: y</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In ES6 and later, you can drop the colon and one copy of the identifier and end up with much simpler code:</p>
<blockquote>
<p>在 ES6 之后，可以删除标识符的冒号和一个副本，最终使用更简单的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> o = &#123; x, y &#125;;</span><br><span class="line">o.<span class="property">x</span> + o.<span class="property">y</span>  <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<h3 id="6-10-2-Computed-Property-Names"><a href="#6-10-2-Computed-Property-Names" class="headerlink" title="6.10.2 Computed Property Names"></a>6.10.2 Computed Property Names</h3><p>Sometimes you need to create an object with a specific property, but the name of that property is not a compile-time constant that you can type literally in your source code. Instead, the property name you need is stored in a variable or is the return value of a function that you invoke. You can’t use a basic object literal for this kind of property. Instead, you have to create an object and then add the desired properties as an extra step:</p>
<blockquote>
<p>有时需要创建具有特定属性的对象，但该属性的名称不是可以在源代码中键入的编译时常量。相反，需要的属性名称存储在变量中，或者是调用的函数的返回值。不能对此类属性使用基本对象字面量。而必须创建一个对象，通过额外的步骤，添加所需的属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROPERTY_NAME</span> = <span class="string">&quot;p1&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computePropertyName</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;p&quot;</span> + <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">o[<span class="variable constant_">PROPERTY_NAME</span>] = <span class="number">1</span>;</span><br><span class="line">o[<span class="title function_">computePropertyName</span>()] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>It is much simpler to set up an object like this with an ES6 feature known as computed properties that lets you take the square brackets from the preceding code and move them directly into the object literal:</p>
<blockquote>
<p>使用称为计算属性的 ES6 特性设置这样的对象要简单得多，该功能允许从前面的代码写入方括内并直接移动到对象字面量中：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PROPERTY_NAME</span> = <span class="string">&quot;p1&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">computePropertyName</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;p&quot;</span> + <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">    [<span class="variable constant_">PROPERTY_NAME</span>]: <span class="number">1</span>,</span><br><span class="line">    [<span class="title function_">computePropertyName</span>()]: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p.<span class="property">p1</span> + p.<span class="property">p2</span> <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>With this new syntax, the square brackets delimit an arbitrary JavaScript expression. That expression is evaluated, and the resulting value (converted to a string, if necessary) is used as the property name.</p>
<blockquote>
<p>使用这种新语法，方括号将其分隔成 JavaScript 表达式。计算该表达式，并将结果值（如有必要转换为字符串）用作属性名称。</p>
</blockquote>
<p>One situation where you might want to use computed properties is when you have a library of JavaScript code that expects to be passed objects with a particular set of properties, and the names of those properties are defined as constants in that library. If you are writing code to create the objects that will be passed to that library, you could hardcode the property names, but you’d risk bugs if you type the property name wrong anywhere, and you’d risk version mismatch issues if a new version of the library changes the required property names. Instead, you might find that it makes your code more robust to use computed property syntax with the property name constants defined by the library.</p>
<blockquote>
<p>可能想要使用计算属性的一个情况是，有一个 JavaScript 代码库，该库希望传递具有一组特定属性的对象，并且这些属性的名称定义为该库中的常量。如果要编写代码以创建将传递给该库的对象，可以硬编码属性名称，但如果在任何地方键入错误的属性名称，则存在错误风险；如果库的新版本更改了所需的属性名称，则存在版本不匹配问题的风险。相反，可能会发现，使用计算属性语法与库定义的属性名称常量时，它使代码更加健壮。</p>
</blockquote>
<h3 id="6-10-3-Symbols-as-Property-Names"><a href="#6-10-3-Symbols-as-Property-Names" class="headerlink" title="6.10.3 Symbols as Property Names"></a>6.10.3 Symbols as Property Names</h3><p>The computed property syntax enables one other very important object literal feature. In ES6 and later, property names can be strings or symbols. If you assign a symbol to a variable or constant, then you can use that symbol as a property name using the computed property syntax:</p>
<blockquote>
<p>计算属性语法启用了另一个非常重要的对象字面量特性。在 ES6 之后，属性名称可以是字符串或 Symbol。如果将 Symbol 分配给变量或常量，则可以使用计算属性语法将该 Symbol 用作属性名称：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> extension = <span class="title class_">Symbol</span>(<span class="string">&quot;my extension symbol&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    [extension]: &#123; <span class="comment">/* extension data stored in this object */</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o[extension].<span class="property">x</span> = <span class="number">0</span>; <span class="comment">// This won&#x27;t conflict with other properties of o</span></span><br></pre></td></tr></table></figure>
<p>As explained in §3.6, Symbols are opaque values. You can’t do anything with them other than use them as property names. Every Symbol is different from every other Symbol, however, which means that Symbols are good for creating unique property names. Create a new Symbol by calling the Symbol() factory function. (Symbols are primitive values, not objects, so Symbol() is not a constructor function that you invoke with new.) The value returned by Symbol() is not equal to any other Symbol or other value. You can pass a string to Symbol(), and this string is used when your Symbol is converted to a string. But this is a debugging aid only: two Symbols created with the same string argument are still different from one another.</p>
<blockquote>
<p>如 §3.6 中所述，符号是不透明值。除了将它们用作属性名称，不能对它们进行任何其他处理。但是，每个 Symbol 都不同于所有其他 Symbol，这意味着 Symbol 适合创建唯一的属性名称。通过调用 Symbol() 工厂函数创建新 Symbol。（Symbol 是原始值，而不是对象，因此 Symbol() 不是使用 new 调用的构造函数。）Symbol() 返回的值不等于任何其他 Symbol 或其他值。可以将字符串传递给 Symbol()，当 Symbol 转换为字符串时，将使用此字符串。但是，这只是一个调试帮助：使用同一字符串参数创建的两个 Symbol 仍然彼此不同。</p>
</blockquote>
<p>The point of Symbols is not security, but to define a safe extension mechanism for JavaScript objects. If you get an object from third-party code that you do not control and need to add some of your own properties to that object but want to be sure that your properties will not conflict with any properties that may already exist on the object, you can safely use Symbols as your property names. If you do this, you can also be confident that the third-party code will not accidentally alter your symbolically named properties. (That third-party code could, of course, use Object.getOwnPropertySymbols() to discover the Symbols you’re using and could then alter or delete your properties. This is why Symbols are not a security mechanism.)</p>
<blockquote>
<p>Symbol 的要点不是安全性，而是为 JavaScript 对象定义一个安全的扩展机制。如果从第三方代码获取对象，您无法控制该对象，并且需要向该对象添加自己的一些属性，但希望确保属性不会与对象上可能存在的任何属性冲突，可以安全地使用 Symbol 作为属性名称。如果这样做，还可以确信第三方代码不会意外更改 Symbol 命名的属性。（当然，该第三方代码可以使用 Object.getOwnPropertySymbols() 来发现你使用的 Symbol，然后可以更改或删除你的属性。这就是为什么符号不是安全机制。）</p>
</blockquote>
<h3 id="6-10-4-Spread-Operator"><a href="#6-10-4-Spread-Operator" class="headerlink" title="6.10.4 Spread Operator"></a>6.10.4 Spread Operator</h3><p>In ES2018 and later, you can copy the properties of an existing object into a new object using the “spread operator” … inside an object literal:</p>
<blockquote>
<p>在 ES2018 之后，可以使用展开运算符 … 将现有的对象中的属性复制到新的对象中：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> position = &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> dimensions = &#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">height</span>: <span class="number">75</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> rect = &#123; ...position, ...dimensions &#125;;</span><br><span class="line">rect.<span class="property">x</span> + rect.<span class="property">y</span> + rect.<span class="property">width</span> + rect.<span class="property">height</span> <span class="comment">// =&gt; 175</span></span><br></pre></td></tr></table></figure>
<p>In this code, the properties of the position and dimensions objects are “spread out” into the rect object literal as if they had been written literally inside those curly braces. Note that this … syntax is often called a spread operator but is not a true JavaScript operator in any sense. Instead, it is a special-case syntax available only within object literals. (Three dots are used for other purposes in other JavaScript contexts, but object literals are the only context where the three dots cause this kind of interpolation of one object into another one.)</p>
<blockquote>
<p>在此代码中，position 和 dimensions 对象的属性被展开到 rect 对象字面量中，就像它们以字面量的方式写入这些大括号中一样。请注意，… 语法通常称为展开运算符，但在任何情况下都不是真正的 JavaScript 运算符。相反，它是一种特殊情况下语法，仅在对象文本中可用。（… 在别的 JavaScript 上下文中有其他用途，但是对象字面量上下文中只有这一种用法。）</p>
</blockquote>
<p>If the object that is spread and the object it is being spread into both have a property with the same name, then the value of that property will be the one that comes last:</p>
<blockquote>
<p>如果展开的目标对象和源对象中具有相同的名称，则该属性的值将是位置处于后面的值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> p = &#123; <span class="attr">x</span>: <span class="number">0</span>, ...o &#125;;</span><br><span class="line">p.<span class="property">x</span>   <span class="comment">// =&gt; 1: the value from object o overrides the initial value</span></span><br><span class="line"><span class="keyword">let</span> q = &#123; ...o, <span class="attr">x</span>: <span class="number">2</span> &#125;;</span><br><span class="line">q.<span class="property">x</span>   <span class="comment">// =&gt; 2: the value 2 overrides the previous value from o.</span></span><br></pre></td></tr></table></figure>
<p>Also note that the spread operator only spreads the own properties of an object, not any inherited ones:</p>
<blockquote>
<p>还有注意展开运算符只展开对象的自有属性，不展开继承属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="title class_">Object</span>.<span class="title function_">create</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;); <span class="comment">// o inherits the property x</span></span><br><span class="line"><span class="keyword">let</span> p = &#123; ...o &#125;;</span><br><span class="line">p.<span class="property">x</span>                            <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>
<p>Finally, it is worth noting that, although the spread operator is just three little dots in your code, it can represent a substantial amount of work to the JavaScript interpreter. If an object has n properties, the process of spreading those properties into another object is likely to be an O(n) operation. This means that if you find yourself using … within a loop or recursive function as a way to accumulate data into one large object, you may be writing an inefficient O(n2) algorithm that will not scale well as n gets larger.</p>
<blockquote>
<p>最后，值得注意的是，虽然展开运算符在代码中只是三个小点，但它对 JavaScript 解释器来说可以代表大量的工作。如果对象具有 n 个属性，则将这些属性分散到另一个对象的过程很可能是 O(n) 操作。这意味着，如果你发现自己在使用 … 在循环或递归函数中，类似将数据累积到一个大对象中的方法，您可能正在编写一个低效的 O(n2) 算法，该算法不会随着 n 变大而扩展。</p>
</blockquote>
<h3 id="6-10-5-Shorthand-Methods"><a href="#6-10-5-Shorthand-Methods" class="headerlink" title="6.10.5 Shorthand Methods"></a>6.10.5 Shorthand Methods</h3><p>When a function is defined as a property of an object, we call that function a method (we’ll have a lot more to say about methods in Chapters 8 and 9). Prior to ES6, you would define a method in an object literal using a function definition expression just as you would define any other property of an object:</p>
<blockquote>
<p>当函数被定义为对象的属性时，我们称该函数为方法（我们将在第 8 章和第 9 章中对方法有更多的描述）。在 ES6 之前，在对象字面量中用函数定义表达式定义一个方法和在对象中定义其他属性一样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square = &#123;</span><br><span class="line">    <span class="attr">area</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">side</span> * <span class="variable language_">this</span>.<span class="property">side</span>; &#125;,</span><br><span class="line">    <span class="attr">side</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line">square.<span class="title function_">area</span>() <span class="comment">// =&gt; 100</span></span><br></pre></td></tr></table></figure>
<p>In ES6, however, the object literal syntax (and also the class definition syntax we’ll see in Chapter 9) has been extended to allow a shortcut where the function keyword and the colon are omitted, resulting in code like this:</p>
<blockquote>
<p>但是，在 ES6 中，对象字面量语法（以及我们将在第 9 章中看到的类定义语法）已扩展成允许省略函数关键字和冒号的快捷方式，可以写成这样的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square = &#123;</span><br><span class="line">    <span class="title function_">area</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">side</span> * <span class="variable language_">this</span>.<span class="property">side</span>; &#125;,</span><br><span class="line">    <span class="attr">side</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line">square.<span class="title function_">area</span>() <span class="comment">// =&gt; 100</span></span><br></pre></td></tr></table></figure>
<p>Both forms of the code are equivalent: both add a property named area to the object literal, and both set the value of that property to the specified function. The shorthand syntax makes it clearer that area() is a method and not a data property like side.</p>
<blockquote>
<p>两种形式是相同的：在对象字面量中添加一个名为 area 的属性，并指定一个函数为这个属性的值。速记语法更清晰的看出 area() 是一个方法而不是一个像 side 一样的数据属性。</p>
</blockquote>
<p>When you write a method using this shorthand syntax, the property name can take any of the forms that are legal in an object literal: in addition to a regular JavaScript identifier like the name area above, you can also use string literals and computed property names, which can include Symbol property names:</p>
<blockquote>
<p>使用此速记语法编写方法时，属性名称可以采用对象字面量中的任何合法形式：除了像上面的名称 area 这样的常规 JavaScript 标识符外，还可以使用字符串字面量和计算属性名称，包括 Symbol 属性名称：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">METHOD_NAME</span> = <span class="string">&quot;m&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> symbol = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> weirdMethods = &#123;</span><br><span class="line">    <span class="string">&quot;method With Spaces&quot;</span>(x) &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;,</span><br><span class="line">    [<span class="variable constant_">METHOD_NAME</span>](x) &#123; <span class="keyword">return</span> x + <span class="number">2</span>; &#125;,</span><br><span class="line">    [symbol](x) &#123; <span class="keyword">return</span> x + <span class="number">3</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">weirdMethods[<span class="string">&quot;method With Spaces&quot;</span>](<span class="number">1</span>)  <span class="comment">// =&gt; 2</span></span><br><span class="line">weirdMethods[<span class="variable constant_">METHOD_NAME</span>](<span class="number">1</span>)           <span class="comment">// =&gt; 3</span></span><br><span class="line">weirdMethods[symbol](<span class="number">1</span>)                <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>
<p>Using a Symbol as a method name is not as strange as it seems. In order to make an object iterable (so it can be used with a for&#x2F;of loop), you must define a method with the symbolic name Symbol.iterator, and there are examples of doing exactly that in Chapter 12.</p>
<blockquote>
<p>使用 Symbol 作为方法名称并不像看起来那么奇怪。为了使对象可迭代（因此它可以与 for&#x2F;of 循环一起使用），必须定义一个具有符号名称 Symbol.iterator 的方法，并且在第 12 章中有这样做的示例。</p>
</blockquote>
<h3 id="6-10-6-Property-Getters-and-Setters"><a href="#6-10-6-Property-Getters-and-Setters" class="headerlink" title="6.10.6 Property Getters and Setters"></a>6.10.6 Property Getters and Setters</h3><p>All of the object properties we’ve discussed so far in this chapter have been data properties with a name and an ordinary value. JavaScript also supports accessor properties, which do not have a single value but instead have one or two accessor methods: a getter and&#x2F;or a setter.</p>
<blockquote>
<p>到目前为止，本节我们所讨论的所有的对象都是具有名称和普通值的数据属性。JavaScript 还支持存取器属性，这些属性没有单个值，而是具有一个或两个存取器方法：getter 和或是或 setter。</p>
</blockquote>
<p>When a program queries the value of an accessor property, JavaScript invokes the getter method (passing no arguments). The return value of this method becomes the value of the property access expression. When a program sets the value of an accessor property, JavaScript invokes the setter method, passing the value of the righthand side of the assignment. This method is responsible for “setting,” in some sense, the property value. The return value of the setter method is ignored.</p>
<blockquote>
<p>当程序查询存取器属性的值时，JavaScript 调用 getter 方法（无实参）。这个方法的返回值就是属性存取表达式的值。当程序设置一个存取器属性的值时， JavaScript 调用 setter 方法，将赋值表达式右侧的值当做参数传入 setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略 setter 方法的返回值。</p>
</blockquote>
<p>If a property has both a getter and a setter method, it is a read&#x2F;write property. If it has only a getter method, it is a read-only property. And if it has only a setter method, it is a write-only property (something that is not possible with data properties), and attempts to read it always evaluate to undefined.</p>
<blockquote>
<p>如果属性同时有 getter 和 setter 方法，则它是一个可读写属性。如果它只含有 getter 方法，它是一个只读属性。如果它只有 setter 方法，它是一个只可写属性（这对一个数据属性来说是不可能的），如果尝试去读它，计算结果永远是 undefined。</p>
</blockquote>
<p>Accessor properties can be defined with an extension to the object literal syntax (unlike the other ES6 extensions we’ve seen here, getters and setters were introduced in ES5):</p>
<blockquote>
<p>存储器属性可以通过表达式在对象字面量语法中定义（不像我们在这里看到的其他 ES6 扩展，getter 和 setter 是 ES5 中的内容）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    <span class="comment">// An ordinary data property</span></span><br><span class="line">    <span class="attr">dataProp</span>: value,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// An accessor property defined as a pair of functions.</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">accessorProp</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">dataProp</span>; &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">accessorProp</span>(<span class="params">value</span>) &#123; <span class="variable language_">this</span>.<span class="property">dataProp</span> = value; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Accessor properties are defined as one or two methods whose name is the same as the property name. These look like ordinary methods defined using the ES6 shorthand except that getter and setter definitions are prefixed with get or set. (In ES6, you can also use computed property names when defining getters and setters. Simply replace the property name after get or set with an expression in square brackets.)</p>
<blockquote>
<p>存储器属性定义为名称与属性名称相同的一个或两个方法。这些方法看起来像使用 ES6 速记定义的普通方法，只不过 getter 和 setter 定义使用 get 或 set 前缀。（在 ES6 中，在定义 getter 和 setter 时还可以使用计算属性名称。只需将带方括号的表达式替换属性名称即可。</p>
</blockquote>
<p>The accessor methods defined above simply get and set the value of a data property, and there is no reason to prefer the accessor property over the data property. But as a more interesting example, consider the following object that represents a 2D Cartesian point. It has ordinary data properties to represent the x and y coordinates of the point, and it has accessor properties that give the equivalent polar coordinates of the point:</p>
<blockquote>
<p>上面定义的存储器方法只需获取并设置数据属性的值，没有理由将存储器属性替换数据属性。但作为一个更有趣的示例，请考虑以下表示 2D 笛卡尔点的对象。它具有表示点的 x 和 y 坐标的普通数据属性，并且具有提供点等效极坐标的存储器属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = &#123;</span><br><span class="line">    <span class="comment">// x and y are regular read-write data properties.</span></span><br><span class="line">    <span class="attr">x</span>: <span class="number">1.0</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">1.0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// r is a read-write accessor property with getter and setter.</span></span><br><span class="line">    <span class="comment">// Don&#x27;t forget to put a comma after accessor methods.</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">r</span>() &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>); &#125;,</span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">r</span>(<span class="params">newvalue</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> oldvalue = <span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="variable language_">this</span>.<span class="property">x</span>, <span class="variable language_">this</span>.<span class="property">y</span>);</span><br><span class="line">        <span class="keyword">let</span> ratio = newvalue/oldvalue;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">x</span> *= ratio;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">y</span> *= ratio;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// theta is a read-only accessor property with getter only.</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">theta</span>() &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">atan2</span>(<span class="variable language_">this</span>.<span class="property">y</span>, <span class="variable language_">this</span>.<span class="property">x</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line">p.<span class="property">r</span>     <span class="comment">// =&gt; Math.SQRT2</span></span><br><span class="line">p.<span class="property">theta</span> <span class="comment">// =&gt; Math.PI / 4</span></span><br></pre></td></tr></table></figure>
<p>Note the use of the keyword this in the getters and setter in this example. JavaScript invokes these functions as methods of the object on which they are defined, which means that within the body of the function, this refers to the point object p. So the getter method for the r property can refer to the x and y properties as this.x and this.y. Methods and the this keyword are covered in more detail in §8.2.2.</p>
<blockquote>
<p>请注意，在本示例中的 getter 和 setter 中使用 this 关键字。JavaScript 以对象的方法的方式调用这些函数，这意味着在函数体中，this 指的是点对象 p。因此，r 属性的 getter 方法通过 this.x 和 this.y 获取到 x 和 y 属性的引用。方法以及 this 关键字在 §8.2.2 中详细介绍。</p>
</blockquote>
<p>Accessor properties are inherited, just as data properties are, so you can use the object p defined above as a prototype for other points. You can give the new objects their own x and y properties, and they’ll inherit the r and theta properties:</p>
<blockquote>
<p>存储器属性是可继承的，就像数据属性一样，因此可以使用上面定义的对象 p 作为其他点的原型。可以为新对象提供自有的 x 和 y 属性，它们将继承 r 和 theta 属性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = <span class="title class_">Object</span>.<span class="title function_">create</span>(p); <span class="comment">// A new object that inherits getters and setters</span></span><br><span class="line">q.<span class="property">x</span> = <span class="number">3</span>; q.<span class="property">y</span> = <span class="number">4</span>;         <span class="comment">// Create q&#x27;s own data properties</span></span><br><span class="line">q.<span class="property">r</span>                       <span class="comment">// =&gt; 5: the inherited accessor properties work</span></span><br><span class="line">q.<span class="property">theta</span>                   <span class="comment">// =&gt; Math.atan2(4, 3)</span></span><br></pre></td></tr></table></figure>
<p>The code above uses accessor properties to define an API that provides two representations (Cartesian coordinates and polar coordinates) of a single set of data. Other reasons to use accessor properties include sanity checking of property writes and returning different values on each property read:</p>
<blockquote>
<p>上述代码使用存储器属性定义一个 API，该 API 提供一组数据的两种表示形式（笛卡尔坐标和极坐标）。使用存储器属性的其他场景包括属性写入的稳健性检测以及在每个属性上返回不同的值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This object generates strictly increasing serial numbers</span></span><br><span class="line"><span class="keyword">const</span> serialnum = &#123;</span><br><span class="line">    <span class="comment">// This data property holds the next serial number.</span></span><br><span class="line">    <span class="comment">// The _ in the property name hints that it is for internal use only.</span></span><br><span class="line">    <span class="attr">_n</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the current value and increment it</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">next</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_n</span>++; &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set a new value of n, but only if it is larger than current</span></span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">next</span>(<span class="params">n</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="variable language_">this</span>.<span class="property">_n</span>) <span class="variable language_">this</span>.<span class="property">_n</span> = n;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;serial number can only be set to a larger value&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">serialnum.<span class="property">next</span> = <span class="number">10</span>;    <span class="comment">// Set the starting serial number</span></span><br><span class="line">serialnum.<span class="property">next</span>          <span class="comment">// =&gt; 10</span></span><br><span class="line">serialnum.<span class="property">next</span>          <span class="comment">// =&gt; 11: different value each time we get next</span></span><br></pre></td></tr></table></figure>
<p>Finally, here is one more example that uses a getter method to implement a property with “magical” behavior:</p>
<blockquote>
<p>最后，下面是使用 getter 方法实现具有”魔幻”行为的属性的示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This object has accessor properties that return random numbers.</span></span><br><span class="line"><span class="comment">// The expression &quot;random.octet&quot;, for example, yields a random number</span></span><br><span class="line"><span class="comment">// between 0 and 255 each time it is evaluated.</span></span><br><span class="line"><span class="keyword">const</span> random = &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">octet</span>() &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">256</span>); &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">uint16</span>() &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">65536</span>); &#125;,</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">int16</span>() &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()*<span class="number">65536</span>)-<span class="number">32768</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="6-11-Summary"><a href="#6-11-Summary" class="headerlink" title="6.11 Summary"></a>6.11 Summary</h2><p>This chapter has documented JavaScript objects in great detail, covering topics that include:</p>
<p>Basic object terminology, including the meaning of terms like enumerable and own property.</p>
<p>Object literal syntax, including the many new features in ES6 and later.</p>
<p>How to read, write, delete, enumerate, and check for the presence of the properties of an object.</p>
<p>How prototype-based inheritance works in JavaScript and how to create an object that inherits from another object with Object.create().</p>
<p>How to copy properties from one object into another with Object.assign().</p>
<p>All JavaScript values that are not primitive values are objects. This includes both arrays and functions, which are the topics of the next two chapters.</p>
<blockquote>
<p>本章非常详细地记录了 JavaScript 对象，涵盖的主题包括：</p>
</blockquote>
<blockquote>
<p>基本对象术语，包括可枚举和自有属性等术语的含义。</p>
</blockquote>
<blockquote>
<p>对象字面量语法，包括 ES6 及以后的许多新特性。</p>
</blockquote>
<blockquote>
<p>如何读取、写入、删除、枚举和检查对象属性是否存在。</p>
</blockquote>
<blockquote>
<p>基于原型的继承是如何在 JavaScript 中工作，以及如何使用 Object.create() 创建一个从另一个对象继承的对象。</p>
</blockquote>
<blockquote>
<p>如何使用 Object.assign() 将属性从一个对象复制到另一个对象。</p>
</blockquote>
<blockquote>
<p>所有 JavaScript 的非原始值都是对象。这包括数组和函数，这是接下来两章的主题。</p>
</blockquote>
<hr>
<ol>
<li>Remember; almost all objects have a prototype but most do not have a property named prototype. JavaScript inheritance works even if you can’t access the prototype object directly. But see §14.3 if you want to learn how to do that.</li>
</ol>
<blockquote>
<ol>
<li>记住，几乎所有对象都有一个原型，但大多数对象没有名为 prototype 的属性。即使不能直接访问原型对象，JavaScript 继承依然工作。但是，如果你想学习如何做到这一点，请参阅 §14.3。</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/63232b7d91d22.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/63232b7d91d22.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Jack hou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/')">第6章 对象</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wechat/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=第6章 对象&amp;url=http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/&amp;pic=https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.houyanbin.com" target="_blank">Jackhou Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>《JavaScript权威指南》<span class="tagsPageCount">17</span></a><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">17</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第7章 数组</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch5/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover5.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第5章 语句</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch1/" title="第1章 JavaScript 概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第1章 JavaScript 概述</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch12/" title="第12章 迭代器和生成器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第12章 迭代器和生成器</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch10/" title="第10章 模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第10章 模块</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch14/" title="第14章 元编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第14章 元编程</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch11/" title="第11章 JavaScript 标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第11章 JavaScript 标准库</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/" title="第13章 异步 JavaScript"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第13章 异步 JavaScript</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://img02.anzhiy.cn/adminuploads/1/2022/09/15/63232b7d91d22.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">Hi，这是我的博客网站，欢迎你能到访~</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">我会在这里分享我的<b style="color:#fff">技术知识</b>、<b style="color:#fff">日常生活</b>和<b style="color:#fff">人生经验。</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Jack hou</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Hou-yanbin" target="_blank" title="Github"><i class="fab fa-github faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/478589474" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=jackhou921@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wxgzh1.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Introduction-to-Objects"><span class="toc-text">6.1 Introduction to Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-Creating-Objects"><span class="toc-text">6.2 Creating Objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-Object-Literals"><span class="toc-text">6.2.1 Object Literals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-Creating-Objects-with-new"><span class="toc-text">6.2.2 Creating Objects with new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3-Prototypes"><span class="toc-text">6.2.3 Prototypes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4-Object-create"><span class="toc-text">6.2.4 Object.create()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-Querying-and-Setting-Properties"><span class="toc-text">6.3 Querying and Setting Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-Objects-As-Associative-Arrays"><span class="toc-text">6.3.1 Objects As Associative Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-Inheritance"><span class="toc-text">6.3.2 Inheritance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-Property-Access-Errors"><span class="toc-text">6.3.3 Property Access Errors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-Deleting-Properties"><span class="toc-text">6.4 Deleting Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-Testing-Properties"><span class="toc-text">6.5 Testing Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-Enumerating-Properties"><span class="toc-text">6.6 Enumerating Properties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-1-Property-Enumeration-Order"><span class="toc-text">6.6.1 Property Enumeration Order</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-Extending-Objects"><span class="toc-text">6.7 Extending Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-Serializing-Objects"><span class="toc-text">6.8 Serializing Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9-Object-Methods"><span class="toc-text">6.9 Object Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-1-The-toString-Method"><span class="toc-text">6.9.1 The toString() Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-2-The-toLocaleString-Method"><span class="toc-text">6.9.2 The toLocaleString() Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-3-The-valueOf-Method"><span class="toc-text">6.9.3 The valueOf() Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-9-4-The-toJSON-Method"><span class="toc-text">6.9.4 The toJSON() Method</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10-Extended-Object-Literal-Syntax"><span class="toc-text">6.10 Extended Object Literal Syntax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-1-Shorthand-Properties"><span class="toc-text">6.10.1 Shorthand Properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-2-Computed-Property-Names"><span class="toc-text">6.10.2 Computed Property Names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-3-Symbols-as-Property-Names"><span class="toc-text">6.10.3 Symbols as Property Names</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-4-Spread-Operator"><span class="toc-text">6.10.4 Spread Operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-5-Shorthand-Methods"><span class="toc-text">6.10.5 Shorthand Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-10-6-Property-Getters-and-Setters"><span class="toc-text">6.10.6 Property Getters and Setters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11-Summary"><span class="toc-text">6.11 Summary</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="做情人真的没有好下场吗？"/></a><div class="content"><a class="title" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？">做情人真的没有好下场吗？</a><time datetime="2023-08-14T16:00:00.000Z" title="发表于 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不爱前行"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行">不爱前行</a><time datetime="2023-07-29T16:00:00.000Z" title="发表于 2023-07-30 00:00:00">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="租房时光"/></a><div class="content"><a class="title" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光">租房时光</a><time datetime="2023-07-21T16:00:00.000Z" title="发表于 2023-07-22 00:00:00">2023-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="故宫记"/></a><div class="content"><a class="title" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记">故宫记</a><time datetime="2023-06-10T16:00:00.000Z" title="发表于 2023-06-11 00:00:00">2023-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息收集道道之外网信息收集"/></a><div class="content"><a class="title" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集">信息收集道道之外网信息收集</a><time datetime="2023-05-28T16:00:00.000Z" title="发表于 2023-05-29 00:00:00">2023-05-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 By <a class="footer-bar-link" href="/" title="Jack hou" target="_blank">Jack hou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 0.88rem; color: rgb(115, 42, 143);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem; color: rgb(11, 162, 98);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem; color: rgb(99, 102, 101);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem; color: rgb(89, 174, 72);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; color: rgb(165, 134, 55);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem; color: rgb(145, 99, 187);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 0.88rem; color: rgb(187, 30, 148);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem; color: rgb(30, 128, 29);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 0.88rem; color: rgb(33, 146, 124);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem; color: rgb(121, 122, 163);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 0.88rem; color: rgb(27, 15, 129);">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 0.88rem; color: rgb(134, 88, 7);">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem; color: rgb(91, 117, 189);">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem; color: rgb(194, 12, 109);">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 0.88rem; color: rgb(55, 6, 45);">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 0.88rem; color: rgb(99, 97, 121);">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 0.88rem; color: rgb(197, 198, 13);">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem; color: rgb(114, 148, 141);">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 0.88rem; color: rgb(46, 94, 153);">越权<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8868465080" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8868465080&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("4/15/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.8",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Jack hou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("4/15/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
      img.title = "下班了就该开开心心的玩耍，嘿嘿~";
      img.alt = "下班了就该开开心心的玩耍，嘿嘿~";

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.houyanbin.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.21/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>