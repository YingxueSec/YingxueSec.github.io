<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>第7章 数组 | Jackhou Blog</title><meta name="keywords" content="《JavaScript权威指南》,JavaScript"><meta name="author" content="Jack hou"><meta name="copyright" content="Jack hou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="第7章 数组"><meta name="application-name" content="第7章 数组"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="第7章 数组"><meta property="og:url" content="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/index.html"><meta property="og:site_name" content="Jackhou Blog"><meta property="og:description" content="This chapter documents arrays, a fundamental datatype in JavaScript and in most other programming languages. An array is an ordered collection of"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg"><meta property="article:author" content="Jack hou"><meta property="article:tag" content="Jackhou, blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg"><meta name="description" content="This chapter documents arrays, a fundamental datatype in JavaScript and in most other programming languages. An array is an ordered collection of"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.houyanbin.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Jack hou","link":"链接: ","source":"来源: Jackhou Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Jackhou Blog',
  title: '第7章 数组',
  postAI: '',
  pageFillDescription: '7.1 Creating Arrays, 7.1.1 Array Literals, 7.1.2 The Spread Operator, 7.1.3 The Array() Constructor, 7.1.4 Array.of(), 7.1.5 Array.from(), 7.2 Reading and Writing Array Elements, 7.3 Sparse Arrays, 7.4 Array Length, 7.5 Adding and Deleting Array Elements, 7.6 Iterating Arrays, 7.7 Multidimensional Arrays, 7.8 Array Methods, 7.8.1 Array Iterator Methods, FOREACH(), MAP(), FILTER(), FIND() AND FINDINDEX(), EVERY() AND SOME(), REDUCE() AND REDUCERIGHT(), 7.8.2 Flattening arrays with flat() and flatMap(), 7.8.3 Adding arrays with concat(), 7.8.4 Stacks and Queues with push() pop() shift() and unshift(), 7.8.5 Subarrays with slice() splice() fill() and copyWithin(), SLICE(), SPLICE(), FILL(), COPYWITHIN(), 7.8.6 Array Searching and Sorting Methods, INDEXOF() AND LASTINDEXOF(), INCLUDES(), SORT(), REVERSE(), 7.8.7 Array to String Conversions, 7.8.8 Static Array Functions, 7.9 Array-Like Objects, 7.10 Strings as Arrays, 7.11 Summary本章记录了数组一个在和大多数其他编程语言中的基本数据类型数组是值的有序集合每个值叫做一个元素而每个元素在数组中有一个位置以数字表示称为索引数组是无类型的数组元素可以是任意类型并且同一个数组中的不同元素也可能有不同的类型数组的元素甚至也可能是对象或其他数组这允许创建复杂的数据结构如对象的数组和数组的数组数组的索引是基于零的位数值第一个元素的索引为最大可能的索引为数组最大能容纳个元素数组是动态的根据需要它们会增长或缩减并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间数组可能是稀疏的数组元素的索引不一定要连续的它们之间可以有空缺每个数组都有一个属性针对非稀疏数组该属性就是数组元素的个数针对稀疏数组大于任何元素的最高索引数组是对象的特殊形式数组索引实际上和碰巧是整数的属性名差不多我们将在本章的其他地方更多地讨论特殊化的数组通常数组的实现是经过优化的用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多数组继承自中的属性它定义了一套丰富的数组操作方法涵盖这方面内容大多数这些方法是通用的这意味着它们不仅对真正的数组有效而且对类数组对象同样有效讨论类数组对象最后字符串的行为与字符数组类似我们将在讨论引入了一组新的数组类这些类统称为类型化数组与常规的数组不同类型化数组有固定的长度和固定的数值元素类型它们提供高性能和对二进制数据的字节级访问在中有介绍有很多种创建数组的方法以下小节将说明如何使用以下方式创建数组数组字面量可迭代数组展开运算符构造函数和工厂方法到目前为止使用数组字面量是创建数组最简单的方法在方括号中将数组元素用逗号隔开即可例如数组字面量中的值不一定要是常量它们可以是任意的表达式数组字面量可以包含对象字面量或其他数组字面量如果数组字面量在一行中包含多个逗号之间没有值则数组是稀疏的请参阅省略值的数组元素不存在但如果查询它们则返回数组字面量语法允许可选的尾部逗号所以的长度是不是之后可以使用展开操作符将一个数组中的元素展开在数组字面量中三个点展开数组所以它的元素变成了数组字面量并被创建在数组中就像被数组的元素所替换被列出作为未闭合的数组字面量的一部分注意尽管我们称三点是展开运算符但这并不是一个操作因为它只能用于数组字面量和本书后面提到的函数调用展开运算符可以方便的创建一个数组的拷贝浅拷贝展开运算符可以作用于任何可迭代对象可迭代对象是可以用进行循环的对象第一次在中提到在第章会看到更多关于它们的描述字符串是可迭代对象所以可以使用展开操作符将字符串转换成单个字符的数组对象是可迭代对象所以数组去重有一种简单的方法是用展开运算符将数组转换成然后再转成数组另一种创建数组的方法是使用构造函数可以用三种不同的方式调用这个构造函数调用时没有实参这个方法创建了一个没有元素的空数组它等价于数组字面量调用时有一个数值实参它指定了数组的长度该技术创建指定长度的数组当预先知道所需元素个数时这种形式的构造函数可以用来预分配一个数组空间注意数组中没有存储值甚至数组的索引属性等还未定义为数组显式指定两个或多个数组元素或者非数值元素以这种形式构造函数的实参将会成为新数组的元素使用数组字面量比这样使用构造函数要简单多了当构造函数调用时有一个数值型实参它会将实参作为数组的长度但当调用时不止一个数值型实参时它会将那些实参作为数组的元素创建这意味着构造函数不能创建只有一个数值型元素的数组在中函数修复了这个问题它是一个将其实参值无论有多少个实参作为数组元素创建并返回一个新数组的工厂方法是中另外一个数组工厂方法它期望一个可迭代或类数组对象作为它的第一个实参并返回一个包含对象中元素的新数组使用一个可迭代实参工作方式类似于展开运算符它也可以简单的拷贝一个数组也很重要因为它定义了一个将类数组对象拷贝成数组的方法类数组对象是一个不是数组的对象它有一个数值型的属性并且它的值碰巧保存在属性名为整数的属性中当使用客户端时一些浏览器方法的返回值是类数组的并且当将其转化成真正的数组后会更容易操作它们第二个实参为可选实参如果传递一个函数作为第二个实参那么当新数组被创建每一个元素都会被作为实参传入这个指定函数中并且这个函数的每个返回值保存在数组中代替原来的值这很像后面会介绍的数组方法但是它会更加高效的执行映射因其为没有创建数组而是直接进行映射到另外一个数组使用运算符来访问数组中的一个元素数组的引用位于方括号的左边方括号中是一个返回非负整数值的任意表达式使用该语法既可以读又可以写数组的一个元素因此如下代码都是合法的语句数组特殊的是当使用小于的非负整数属性名时数组会自动维护属性例如上文中我们创建了只有一个元素的数组然后我们为其序列为和的元素进行赋值数组属性会自动改变请记住数组是对象的特殊形式使用方括号访问数组元素就像用方括号访问对象的属性一样将指定的数字索引值转换成字符串索引值变成然后将其作为属性名来使用关于索引值从数字转换为字符串没什么特别之处对常规对象也可以这么做清晰地区分数组的索引和对象的属性名是非常有用的所有的索引都是属性名但只有在之间的整数属性名才是索引所有的数组都是对象可以为其创建任意名字的属性但如果使用的属性是数组的索引数组的特殊行为就是将根据需要更新它们的属性值注意可以使用负数或非整数来索引数组这种情况下数值转换为字符串字符串作为属性名来用既然名字不是非负整数它就只能当做常规的对象属性而非数组的索引同样如果凑巧使用了是非负整数的字符串它就当做数组索引而非对象属性当使用的一个浮点数和一个整数相等时情况也是一样的事实上数组索引仅仅是对象属性名的一种特殊类型这意味着数组没有越界错误的概念当试图查询任何对象中不存在的属性时都不会报错只会得到值类似于对象对于对象同样存在这种情况稀疏数组就是包含从开始的不连续索引的数组通常数组的属性值代表数组中元素的个数如果数组是稀疏的属性值大于元素的个数可以用构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组后面会看到你也可以用运算符来生产稀疏数组足够稀疏的数组通常在实现上比稠密的数组更慢内存利用率更高在这样的数组中查找元素的时间与常规对象属性的查找时间一样长注意当在数组字面量中省略值时像中使用重复的逗号返回的是稀疏数组省略掉的值是不存在的了解稀疏数组是了解数组的真实本质的一部分尽管如此实际上你所碰到的绝大多数数组不是稀疏数组并且如果你确实碰到了稀疏数组你的代码很可能像对待非稀疏数组一样来对待它们只不过它们包含一些元素每个数组有一个属性就是这个属性使其区别于常规的对象针对稠密也就是非稀疏数组属性值代表数组中元素的个数其值比数组中最大的索引大当数组是稀疏的时属性值大于元素的个数而且关于此我们可以说数组长度保证大于它每个元素的索引值或者换一种说法在数组中无论稀疏与否肯定找不到一个元素的索引值大于或等于它的长度为了维持此规则不变化数组有两个特殊的行为第一个如同上面的描述如果为一个数组元素赋值它的索引大于或等于现有数组的长度时属性的值将设置为第二个特殊的行为就是设置属性为一个小于当前长度的非负整数时当前数组中那些索引值大于或等于的元素将从中删除还可以将数组的属性值设置为大于其当前的长度实际上这不会向数组中添加新的元素它只是在数组尾部创建一个稀疏区域我们已经见过添加数组元素最简单的方法为新索引赋值也可以使用方法在数组末尾增加一个或多个元素在数组尾部压入一个元素与给赋值是一样的可以使用方法有描述在数组的首部插入一个元素并且将其他元素依次移到更高的索引处方法与相反它移除数组最后一个元素并返回这个元素使数组减同样方法移除并返回数组的第一个元素使数组减并将其他元素依次移到低的索引处有更多关于这些方法的描述可以像删除对象属性一样使用运算符来删除数组元素删除数组元素与为其赋值是类似的但有一些微妙的区别注意对一个数组元素使用不会修改数组的属性也不会将元素从高索引处移下来填充已删除属性留下的空白如果从数组中删除一个元素它就变成稀疏数组正如上面所看到的也可以通过设置新的所需长度即可从数组尾部删除元素最后是一个通用的方法来插入删除或替换数组元素它会根据需要修改属性并移动元素到更高或较低的索引处详细内容见在中最容易遍历数组元素或可迭代对象的方法是循环在中详细介绍内置数组迭代器循环按照升序返回数组元素对于稀疏数组它没有特殊的行为数组中不存在的元素只是单纯的返回如果使用循环一个数组时还需要知道每个元素的索引可以像这样将数组的方法和解构语句一同使用另一种不错的遍历数组方法是用这不是循环的新形式而是提供数组遍历功能方法的数组方法可以给数组的方法传递一个函数会对数组中每一个元素调用这个方法正如期望的按顺序对数组进行计算实际上它将数组索引作为第二个实参传递到函数这有时很有用与循环不同能意识到稀疏数组并且不会为不存在的元素调用函数更详细地记录了方法该部分还介绍演示了特定类型的数组遍历方法如和也可以用一种非常老旧方式遍历数组的元素在嵌套循环或其他性能至关重要的上下文中有时可能会看到这样的数组遍历以便数组长度仅被查一次而不是在每次循环都去查询以下两种形式都是符合习惯的循环虽然不是特别常用而且对于现代解释器它们是否对性能有任何影响尚不清楚这些示例假定数组是稠密的并且所有元素都包含有效的数据如果不是这样应该在使用数组元素之前测试它们如果要跳过和不存在的元素可以编写不支持真正的多维数组但可以用数组的数组来近似访问数组的数组中的元素只要简单地使用两次操作符即可例如假设变量是一个数组的数组它的基本元素是数值那么的每个元素是包含一个数值数组访问数组中特定数值的代码为这里有一个具体的例子它使用二维数组作为一个九九乘法表前面几节重点介绍了用于处理数组的基本语法但通常由类定义的方法是最强大的下一节将记录这些方法在阅读有关这些方法时请记住其中一些方法修改了调用的数组而其中一些方法使数组保持不变许多方法返回数组有时这是一个新数组原始数组保持不变其他时候方法将修改数组并且返回对修改后数组的引用以下每个小节都涵盖一组相关的数组方法迭代器方法循环遍历数组的元素通常调用在每个元素上指定的函数堆栈和队列方法在数组的开头和结尾添加和删除数组元素子数组方法用于提取删除插入填充和复制一个更大数组中相邻的区域搜索和排序方法用于查找数组中的元素和排序数组的元素以下小节还介绍类的静态方法和一些用于连接数组和将数组转换为字符串的各种方法本节中介绍的方法通过将数组元素按顺序传递到所指定的函数来遍历数组它们提供了迭代映射筛选测试和减少数组的便捷方法然而在详细解释这些方法之前值得对它们进行一些概括首先所有这些方法都接受函数作为其第一个实参并使用调用数组的每个元素或某些元素作为实参调用该函数如果数组是稀疏的则不会为不存在的元素调用传递的函数在大多数情况下提供的函数被调用时有三个实参数组元素的值数组元素的索引和数组本身通常只需要这些实参值中的第一个并且可以忽略第二个和第三个值以下小节中描述的大多数迭代器方法都接受可选的第二个实参如果指定则调用函数就像它是第二个实参的方法一样也就是说传递的第二个实参将成为第一个函数实参内部的值传递的函数的返回值通常很重要但不同的方法以不同的方式处理返回值此处描述的方法都没有修改调用它们的数组当然传递的函数可以修改这个数组这节的每个函数都调用它的第一个函数实参并且通常将该函数内联定义为方法调用表达式的一部分而不是使用在其他地方显示定义的函数箭头函数语法参见在这些方法中特别有效我们将在下面的示例中使用它方法遍历数组调用为每个元素指定的函数正如我们已经描述的那样将函数作为第一个实参传递给然后使用三个实参调用函数数组元素的值数组元素的索引和数组本身如果只关心数组元素的值则编写一个只有一个实参的函数将忽略其他实参请注意不提供在所有元素传递给函数之前终止迭代的方法也就是说没有等效于常规循环的语句可以使用方法将调用数组的每个元素传递到指定的函数并返回一个包含函数返回的值的数组例如传递到的函数的调用方式与传递给的函数相同但是对于方法传递的函数应返回一个值请注意返回一个新数组它不会修改调用它的数组如果该数组是稀疏的则不会为缺失的元素调用函数但返回的数组将稀疏其确实元素与原始数组的位置相同它将具有相同的长度和相同的缺失元素方法返回一个数组其中包含调用该数组的数组元素的子集传递给它的函数应该是断言返回真或假的函数断言函数的调用就像和调用一样如果返回值为或者能转换为的值则传递给断言的元素是子集的成员并将添加到将成为返回值的数组中例子注意跳过稀疏数组中的丢失元素并且返回值也总是稠密的要缩小稀疏数组的间距可以这样做要缩小间隙并移除和元素可以用这样做和方法就像因为它们在数组中迭代查找断言函数返回真实值的元素但是与不同这两种方法在断言首次查找元素到时停止遍历发生这种情况时返回匹配元素而返回匹配元素的索引如果未找到匹配元素返回返回和方法是数组断言它们将指定的断言函数应用于数组的元素然后返回或方法与数学全称量化符号相似如果数组中所有元素执行断言函数返回值都为则返回方法与数学存在限定符相同如果数组中存在至少有一个元素调用断言函数返回的返回仅在断言全部返回时返回请注意和只要它们知道要返回的值都停止对数组元素的遍历在断言函数第一次返回时返回并且只有在每个元素调用断言函数都返回时才会遍历整个数组正好相反它返回时您的谓词返回并且仅在谓词始终返回时才会回注所有元素另请注意根据数学约定返回有些返回当在空数组上调用时某些返回和方法使用指定的函数将数组元素进行组合生成单个值这在函数式编程中是常见的操作也可以称为注入和折叠举例说明它是如何工作的需要两个实参第一个是执行化简操作的函数化简函数的任务就是用某种方法把两个值组合或化简为一个值并返回化简后的值在上述例子中函数通过加法乘法或取最大值的方法组合两个值第二个可选的实参是一个传递给函数的初始值使用的函数与和使用的函数不同比较熟悉的是数组元素元素的索引和数组本身将作为第个实参传递给函数第一个实参是到目前为止的化简操作累积的结果第一次调用函数时第一个实参是一个初始值它就是传递给的第二个实参在接下来的调用中这个值就是上一次化简函数的返回值在上面的第一个例子中第一次调用化简函数时的实参是和将两者相加并返回再次调用时的实参是和它返回然后它计算最后计算最后的值是返回这个值可能已经注意到了上面第三次调用时只有一个实参没有指定初始值当不指定初始值调用时它将使用数组的第一个元素作为其初始值这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个实参在上面求和与求积的例子中可以省略初始值实参在空数组上不带初始值实参调用将导致类型错误异常如果调用它的时候只有一个值数组只有一个元素并且没有指定初始值或者有一个空数组并且指定一个初始值只是简单地返回那个值而不会调用化简函数的工作原理和一样不同的是它按照数组索引从高到低从右到左处理数组而不是从低到高如果操作的优先顺序是从右到左你可能想使用它例如注意和都能接收一个可选的实参它指定了化简函数调用时的关键字的值可选的初始值实参仍然需要占一个位置如果想让化简函数作为一个特殊对象的方法调用请参看方法为了简单起见到目前位置所展示的例子都是数值的但数学计算不是和的唯一意图任何想要将两个相同类型的值例如两个对象合并到一个值的函数都可以用化简函数另一方面使用数组化简的算法可能很快变得复杂且难以理解可能会发现如果使用常规循环构造来处理数组则更容易读写和推理在中方法创建并返回一个新的数组该数组包含与调用的数组相同的元素只不过作为数组的任何元素都展平到返回的数组中例如当调用时没有实参将平展一个级别的嵌套作为数组的原始数组的元素被展平但这些数组的数组元素不会展平如果要展平更多级别需要传递数字给方法的工作方式与方法见类似只不过返回的数组会自动展平就像传递到也就是说调用与但更高效相同可以将视为的泛化它允许输入数组的每个元素映射到输出数组的多个元素特别的是允许将输入元素映射到空数组该数组在平展后不输出到数组中方法创建并返回一个新数组它的元素包括调用的原始数组的元素和的每个实参如果这些实参中的任何一个自身是数组则连接的是数组的元素而非数组本身但要注意不会递归扁平化数组的数组也不会修改调用的数组请注意创建调用数组的新副本在许多情况下这是正确的做法但它是一个昂贵的操作如果您发现自己编写代码像那么您应该考虑使用或修改数组而不是创建新的数组和方法允许将数组当做栈来使用方法在数组的尾部添加一个或多个元素并返回数组新的长度方法则相反它删除数组的最后一个元素减小数组长度并返回它删除的值注意两个方法都修改并替换原始数组而非生成一个修改版的新数组组合使用和能够用数组实现先进后出的栈例如方法不展平传入的数组但如果想要将数组的元素全部压入另外一个数组可以使用展开运算符来显示展开和方法的行为非常类似于和不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作在数组的头部添加一个或多个元素并将已存在的元素移动到更高索引的位置来获得足够的空间最后返回数组新的长度删除数组的第一个元素并将其返回然后把所有随后的元素下移一个位置来填补数组头部的空缺可以使用和实现栈但它比使用和的效率低因为每次在数组头部添加或删除元素时都需要向上或向下移动数组元素但是您可以使用在数组末尾添加元素并从数组的头部删除它们来实现队列数据解构有一个特性是值得一提的你可能会觉得它令人惊讶将多个实参传入时它们将一次全部插入这意味着它们最终在数组中的顺序与一次插入一个实参的顺序时不同的数组定义了许多在连续区域子数组或数组的片段上工作的方法以下各节描述了提取替换填充和复制片段的方法方法返回指定数组的一个片段或子数组它的两个实参分别指定了片段的开始和结束的位置返回的数组包含第一个实参指定的位置到但不包含第二个实参指定的位置之间的所有数组元素如果只指定一个实参返回的数组将包含从开始位置到数组结尾的所有元素如实参中出现负数它表示相对于数组的位置例如实参指定了最后一个元素而指定了它前面的元素注意不会修改调用的数组下面有一些示例方法是在数组中插入或删除元素的通用方法不同于和会修改调用的数组注意和拥有非常相似的名字但它们的功能却有本质的区别能够从数组中删除元素插入元素到数组中或者同时完成这两种操作在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值因此数组的其他部分仍然保持连续的的第一个实参指定了插入和或删除的起始位置第二个实参指定了应该从数组中删除的元素的个数注意这里是这两个方法的另外一个不同的第二个实参是结束的位置的第二个实参是长度如果省略第二个实参从起始点开始到数组结尾的所有元素都将被删除返回一个由删除元素组成的数组或者如果没有删除元素就返回一个空数组例如的前两个实参指定了需要删除的数组元素紧随其后的任意个数的实参指定了需要插入到数组中的元素从第一个实参指定的位置开始插入例如注意不同于插入数组本身不是数组的元素方法将数组或数组片段的元素填充为指定值它将对调用它的数组进行突变并返回修改后的数组的第一个实参是将数组元素填充的值可选的第二个实参指定起始索引如果省略则填充将从索引开始可选的第三个实参指定结束索引将填充到但不包括该索引的数组元素如果省略此实参则从起始索引到末尾填充数组可以通过传递负数来指定相对于数组末尾的索引就像一样将数组的一个片段复制到数组中的新位置它在适当的位置修改数组并返回修改后的数组但不会更改数组的长度第一个实参指定将第一个元素复制到的目标索引第二个实参指定被复制的第一个元素的索引如果省略此第二个实参则使用第三个实参指定被复制的元素片段的结尾如果省略则使用数组的长度从开始索引到结束索引但不包括结束索引的元素将被复制可以通过传递负数来指定相对于数组末尾的索引就像一样旨在作为一种高性能方法对类型化数组特别有用请参见它模仿的标准库中函数请注意即使源区域和目标区域之间存在重叠该拷贝也可以正常工作数组实现和方法这些方法类似于名称相同的字符串方法还有和方法用于对数组元素进行重新排序这些方法在下面的小节中介绍和在数组中搜索具有指定值的元素并返回找到的第一个元素的索引如果未找到则返回从头到尾搜索数组从尾到头搜索和使用运算符将其实参与数组元素进行比较如果数组包含对象而不是原始值则这些方法将检查两个引用是否都指向完全相同的对象如果要实际查看对象的内容尝试将方法代替自定义的断言函数和采用可选的第二个实参该实参指定开始搜索的数组索引如果省略此参数则从开头开始从结尾开始第二个参数允许使用负值并将其视为距数组末端的偏移量就像方法一样例如值指定数组的最后一个元素以下函数在数组中搜索指定的值并返回所有匹配索引的数组这演示了如何使用的第二个参数来查找第一个参数之外的匹配项请注意字符串具有和方法它们与这些数组方法一样工作不同之处在于第二个实参是负数时被视为零的方法采用单个实参如果数组包含该值返回否则它不会告诉你值的索引只告诉你该值是否存在方法实际上是数组集的成员身份测试但是请注意数组不是的高效表示形式如果使用多个元素则应使用真正的对象方法在一个重要方面与方法略有不同与运算符使用相同的算法测试相等性并且这个相等算法认为非数字值与所有其他值包括自身不同使用略有不同的相等算法它认为等于自身这意味着不会检测数组中的值但可以对数组的元素直接进行排序并返回排序后的数组当调用时它会按字母顺序对数组元素进行排序如有必要暂时将它们转换为字符串以执行比较如果数组中包含元素它们会被放在数组的结尾若要将数组按字母顺序以外的顺序排序必须将比较函数作为实参传递给该函数决定了它的两个实参在排好序的数组中的先后顺序假设第一个实参应该在前比较函数应该返回一个小于的数值反之假设第一个参数应该在后函数应该返回一个大于的数值并且假设两个值相等也就是说它们的顺序无关紧要函数应该返回例如用数值大小而非字母表顺序进行数组排序代码如下另外一个数组元素排序的例子也许需要对一个字符串数组执行不区分大小写的字母表排序比较函数首先将实参都转化为小写字符串使用方法再开始比较方法反转数组中元素的顺序并返回反转后的数组它直接在数组中操作换一种说法它不创建一个新的数组它不创建一个新的带有排序后的元素的数组而是直接在已存在的数组中进行排序类定义了三个方法来将数组转化为字符串通常在创建日志和错误信息时会用到如果要以文本形式保存数组的内容供以后重用请使用序列化数组而不是使用此处描述的方法方法将数组的所有元素转换为字符串并连接它们返回生成的字符串可以指定一个可选字符串来分隔生成的字符串中的元素如果未指定分隔符字符串则使用逗号方法是方法的反向方法该方法通过将字符串拆分为多个片段来创建数组数组与所有对象一样具有方法对于数组此方法的工作方式与没有参数的方法相同请注意输出不包括方括号或数组值周围的任何其他分隔符是的本地化版本它通过调用元素的方法将每个数组元素转换为字符串然后使用特定于区域设置和实现定义分隔符字符串连接生成的字符串除了我们已经记录的数组方法之外类还定义了三个静态函数可以通过构造函数而不是数组调用和是用于创建新数组的工厂方法它们记录在和中另外一个静态数组方法是用来判断一个未知值是否是数组我们已经看到数组的有一些特性是其他对象所没有的当有新的元素添加到列表中时自动更新属性设置为一个较小值将截断数组从中继承一些有用的方法数组传入方法返回这些特性让数组和常规的对象有明显的区别但是它们不是定义数组的本质特性一种常常完全合理的看法是把拥有一个数值型属性和对应非负整数属性的对象看作数组的同类实际上这些类数组对象在实践中偶尔出现虽然不能通过它们直接调用数组方法或者期望属性有什么特殊的行为但是仍然可以用针对真正数组遍历代码来遍历它们结论就是很多数组算法针对类数组对象同样奏效就像针对真正的数组一样尤其是这种情况算法把数组看成只读的或者如果保持数组长度不变以下代码为一个常规对象增加了一些属性使其变成类数组对象然后遍历生成的伪数组的元素在客户端中很多作用于的方法例如返回类数组对象下面这个函数可能会用于测试对象是否可以用作类数组我们会在下一节看到字符串的行为像数组一样尽管如此对于数组这种测试对字符串通常返回它们通常最好作为字符串处理而不是作为数组处理大多数数组方法都特意定义为泛型以便它们在应用于除数组之外的类数组可以正常工作由于类数组对象不会从继承因此不能直接在它们上调用数组方法但是可以使用方法间接调用它们详情请参阅此代码倒数第二行调用数组类对象上的方法以便将该对象的元素复制到真正的数组对象中这是一个惯用的技巧存在于许多旧代码中但现在使用要容易得多字符串的行为类似于字符的只读数组可以使用方括号替代方法访问单个字符当然字符串使用运算符仍然返回如果将字符串传递给方法则返回可索引字符串的主要好处是我们可以用方括号替换对的调用方括号更简洁更可读而且可能更高效但是字符串的行为类似于数组也意味着我们可以对它们应用泛型数组方法例如请记住字符串是不可变值因此当字符串被视为数组时它们是只读数组数组方法和直接修改数组它们不能处理字符串但是尝试使用数组方法修改字符串不会引发异常它只是静默失败本章深入介绍了数组包括有关稀疏数组和类数组对象的深奥细节本章要点包括数组字面量编写方括号内逗号分隔值列表通过在方括号内指定所需的数组索引来访问单个数组元素循环和中引入的展开运算符是遍历数组的特别有用的方法类定义了一组用于操作数组的丰富方法应该确保熟悉',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:44:22',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Jackhou Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 1.05rem;">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 1.05rem;">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem;">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 1.05rem;">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 1.05rem;">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 1.05rem;">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 1.05rem;">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 1.05rem;">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.05rem;">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 1.05rem;">越权<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">37</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>《JavaScript权威指南》</span></a><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">第7章 数组</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:54.000Z" title="发表于 2023-04-26 00:00:54">2023-04-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:22.000Z" title="更新于 2023-04-26 21:44:22">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="第7章 数组"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url">《JavaScript权威指南》</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><h1 id="CrawlerTitle" itemprop="name headline">第7章 数组</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jack hou</span><time itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:54.000Z" title="发表于 2023-04-26 00:00:54">2023-04-26</time><time itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:22.000Z" title="更新于 2023-04-26 21:44:22">2023-04-26</time></header><meta name="referrer" content="no-referrer"/>



<p>This chapter documents arrays, a fundamental datatype in JavaScript and in most other programming languages. An array is an ordered collection of values. Each value is called an element, and each element has a numeric position in the array, known as its index. JavaScript arrays are untyped: an array element may be of any type, and different elements of the same array may be of different types. Array elements may even be objects or other arrays, which allows you to create complex data structures, such as arrays of objects and arrays of arrays. JavaScript arrays are zero-based and use 32-bit indexes: the index of the first element is 0, and the highest possible index is 4294967294 (2<sup>32</sup>−2), for a maximum array size of 4,294,967,295 elements. JavaScript arrays are dynamic: they grow or shrink as needed, and there is no need to declare a fixed size for the array when you create it or to reallocate it when the size changes. JavaScript arrays may be sparse: the elements need not have contiguous indexes, and there may be gaps. Every JavaScript array has a length property. For nonsparse arrays, this property specifies the number of elements in the array. For sparse arrays, length is larger than the highest index of any element.</p>
<blockquote>
<p>本章记录了数组、一个在 JavaScript 和大多数其他编程语言中的基本数据类型。数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。JavaScript 数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可能有不同的类型。数组的元素甚至也可能是对象或其他数组，这允许创建复杂的数据结构，如对象的数组和数组的数组。JavaScript 数组的索引是基于零的 32 位数值：第一个元素的索引为 0，最大可能的索引为 4,294,967,294（2<sup>32</sup>-2），数组最大能容纳 4,294,967,295 个元素。JavaScript 数组是动态的：根据需要它们会增长或缩减，并且在创建数组时无须声明一个固定的大小或者在数组大小变化时无须重新分配空间。JavaScript 数组可能是稀疏的：数组元素的索引不一定要连续的，它们之间可以有空缺。每个 JavaScript 数组都有一个 length 属性。针对非稀疏数组，该属性就是数组元素的个数。针对稀疏数组，length 大于任何元素的最高索引。</p>
</blockquote>
<p>JavaScript arrays are a specialized form of JavaScript object, and array indexes are really little more than property names that happen to be integers. We’ll talk more about the specializations of arrays elsewhere in this chapter. Implementations typically optimize arrays so that access to numerically indexed array elements is generally significantly faster than access to regular object properties.</p>
<blockquote>
<p>JavaScript 数组是 JavaScript 对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。我们将在本章的其他地方更多地讨论特殊化的数组。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。</p>
</blockquote>
<p>Arrays inherit properties from Array.prototype, which defines a rich set of array manipulation methods, covered in §7.8. Most of these methods are generic, which means that they work correctly not only for true arrays, but for any “array-like object.” We’ll discuss array-like objects in §7.9. Finally, JavaScript strings behave like arrays of characters, and we’ll discuss this in §7.10.</p>
<blockquote>
<p>数组继承自 Array.prototype 中的属性，它定义了一套丰富的数组操作方法，§7.8 涵盖这方面内容。大多数这些方法是通用的，这意味着它们不仅对真正的数组有效，而且对“类数组对象”同样有效。§7.9 讨论类数组对象。最后，JavaScript 字符串的行为与字符数组类似，我们将在 §7.10 讨论。</p>
</blockquote>
<p>ES6 introduces a set of new array classes known collectively as “typed arrays.” Unlike regular JavaScript arrays, typed arrays have a fixed length and a fixed numeric element type. They offer high performance and byte-level access to binary data and are covered in §11.2.</p>
<blockquote>
<p>ES6 引入了一组新的数组类，这些类统称为“类型化数组”。与常规的 JavaScript 数组不同，类型化数组有固定的长度和固定的数值元素类型。它们提供高性能和对二进制数据的字节级访问，在 §11.2 中有介绍。</p>
</blockquote>
<h2 id="7-1-Creating-Arrays"><a href="#7-1-Creating-Arrays" class="headerlink" title="7.1 Creating Arrays"></a>7.1 Creating Arrays</h2><p>There are several ways to create arrays. The subsections that follow explain how to create arrays with:</p>
<blockquote>
<p>有很多种创建数组的方法。以下小节将说明如何使用以下方式创建数组：</p>
</blockquote>
<p>Array literals</p>
<blockquote>
<p>数组字面量</p>
</blockquote>
<p>The … spread operator on an iterable object</p>
<blockquote>
<p>可迭代数组 … 展开运算符</p>
</blockquote>
<p>The Array() constructor</p>
<blockquote>
<p>Array() 构造函数</p>
</blockquote>
<p>The Array.of() and Array.from() factory methods</p>
<blockquote>
<p>Array.of() 和 Array.from() 工厂方法</p>
</blockquote>
<h3 id="7-1-1-Array-Literals"><a href="#7-1-1-Array-Literals" class="headerlink" title="7.1.1 Array Literals"></a>7.1.1 Array Literals</h3><p>By far the simplest way to create an array is with an array literal, which is simply a comma-separated list of array elements within square brackets. For example:</p>
<blockquote>
<p>到目前为止使用数组字面量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> empty = [];                 <span class="comment">// An array with no elements</span></span><br><span class="line"><span class="keyword">let</span> primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>];  <span class="comment">// An array with 5 numeric elements</span></span><br><span class="line"><span class="keyword">let</span> misc = [ <span class="number">1.1</span>, <span class="literal">true</span>, <span class="string">&quot;a&quot;</span>, ]; <span class="comment">// 3 elements of various types + trailing comma</span></span><br></pre></td></tr></table></figure>
<p>The values in an array literal need not be constants; they may be arbitrary expressions:</p>
<blockquote>
<p>数组字面量中的值不一定要是常量；它们可以是任意的表达式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> base = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> table = [base, base+<span class="number">1</span>, base+<span class="number">2</span>, base+<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>Array literals can contain object literals or other array literals:</p>
<blockquote>
<p>数组字面量可以包含对象字面量或其他数组字面量：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = [[<span class="number">1</span>, &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;], [<span class="number">2</span>, &#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span>&#125;]];</span><br></pre></td></tr></table></figure>
<p>If an array literal contains multiple commas in a row, with no value between, the array is sparse (see §7.3). Array elements for which values are omitted do not exist but appear to be undefined if you query them:</p>
<blockquote>
<p>如果数组字面量在一行中包含多个逗号，之间没有值，则数组是稀疏的（请参阅 §7.3）。省略值的数组元素不存在，但如果查询它们则返回 undefined：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> count = [<span class="number">1</span>,,<span class="number">3</span>]; <span class="comment">// Elements at indexes 0 and 2. No element at index 1</span></span><br><span class="line"><span class="keyword">let</span> undefs = [,,];  <span class="comment">// An array with no elements but a length of 2</span></span><br></pre></td></tr></table></figure>
<p>Array literal syntax allows an optional trailing comma, so [,,] has a length of 2, not 3.</p>
<blockquote>
<p>数组字面量语法允许可选的尾部逗号，所以 [,,] 的长度是 2，不是3。</p>
</blockquote>
<h3 id="7-1-2-The-Spread-Operator"><a href="#7-1-2-The-Spread-Operator" class="headerlink" title="7.1.2 The Spread Operator"></a>7.1.2 The Spread Operator</h3><p>In ES6 and later, you can use the “spread operator,” …, to include the elements of one array within an array literal:</p>
<blockquote>
<p>ES6 之后，可以使用展开操作符 … 将一个数组中的元素展开在数组字面量中：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [<span class="number">0</span>, ...a, <span class="number">4</span>];  <span class="comment">// b == [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>The three dots “spread” the array a so that its elements become elements within the array literal that is being created. It is as if the …a was replaced by the elements of the array a, listed literally as part of the enclosing array literal. (Note that, although we call these three dots a spread operator, this is not a true operator because it can only be used in array literals and, as we’ll see later in the book, function invocations.)</p>
<blockquote>
<p>三个点展开数组 a，所以它的元素变成了数组字面量，并被创建在数组中。就像 …a 被数组 a 的元素所替换，被列出作为未闭合的数组字面量的一部分。（注意，尽管我们称三点是展开运算符，但这并不是一个操作，因为它只能用于数组字面量和本书后面提到的函数调用。）</p>
</blockquote>
<p>The spread operator is a convenient way to create a (shallow) copy of an array:</p>
<blockquote>
<p>展开运算符可以方便的创建一个数组的拷贝（浅拷贝）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> original = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> copy = [...original];</span><br><span class="line">copy[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// Modifying the copy does not change the original</span></span><br><span class="line">original[<span class="number">0</span>]   <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>The spread operator works on any iterable object. (Iterable objects are what the for&#x2F;of loop iterates over; we first saw them in §5.4.4, and we’ll see much more about them in Chapter 12.) Strings are iterable, so you can use a spread operator to turn any string into an array of single-character strings:</p>
<blockquote>
<p>展开运算符可以作用于任何可迭代对象。（可迭代对象是可以用 for&#x2F;of 进行循环的对象；第一次在 §5.4.4 中提到，在第 12 章会看到更多关于它们的描述。）字符串是可迭代对象，所以可以使用展开操作符将字符串转换成单个字符的数组。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> digits = [...<span class="string">&quot;0123456789ABCDEF&quot;</span>];</span><br><span class="line">digits <span class="comment">// =&gt; [&quot;0&quot;,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;]</span></span><br></pre></td></tr></table></figure>
<p>Set objects (§11.1.1) are iterable, so an easy way to remove duplicate elements from an array is to convert the array to a set and then immediately convert the set back to an array using the spread operator:</p>
<blockquote>
<p>Set 对象（§11.1.1）是可迭代对象，所以数组去重有一种简单的方法是用展开运算符将数组转换成 set 然后再转成数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letters = [...<span class="string">&quot;hello world&quot;</span>];</span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Set</span>(letters)]  <span class="comment">// =&gt; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;o&quot;,&quot; &quot;,&quot;w&quot;,&quot;r&quot;,&quot;d&quot;]</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-3-The-Array-Constructor"><a href="#7-1-3-The-Array-Constructor" class="headerlink" title="7.1.3 The Array() Constructor"></a>7.1.3 The Array() Constructor</h3><p>Another way to create an array is with the Array() constructor. You can invoke this constructor in three distinct ways:</p>
<blockquote>
<p>另一种创建数组的方法是使用 Array() 构造函数。可以用三种不同的方式调用这个构造函数：</p>
</blockquote>
<p>Call it with no arguments:</p>
<blockquote>
<p>调用时没有实参：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br></pre></td></tr></table></figure>
<p>This method creates an empty array with no elements and is equivalent to the array literal [].</p>
<blockquote>
<p>这个方法创建了一个没有元素的空数组，它等价于 [] 数组字面量。</p>
</blockquote>
<p>Call it with a single numeric argument, which specifies a length:</p>
<blockquote>
<p>调用时有一个数值实参，它指定了数组的长度：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>This technique creates an array with the specified length. This form of the Array() constructor can be used to preallocate an array when you know in advance how many elements will be required. Note that no values are stored in the array, and the array index properties “0”, “1”, and so on are not even defined for the array.</p>
<blockquote>
<p>该技术创建指定长度的数组。当预先知道所需元素个数时，这种形式的 Array() 构造函数可以用来预分配一个数组空间。注意，数组中没有存储值，甚至数组的索引属性“0”、“1”等还未定义。</p>
</blockquote>
<p>Explicitly specify two or more array elements or a single non-numeric element for the array:</p>
<blockquote>
<p>为数组显式指定两个或多个数组元素或者非数值元素：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;testing, testing&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>In this form, the constructor arguments become the elements of the new array. Using an array literal is almost always simpler than this usage of the Array() constructor.</p>
<blockquote>
<p>以这种形式，构造函数的实参将会成为新数组的元素。使用数组字面量比这样使用 Array() 构造函数要简单多了。</p>
</blockquote>
<h3 id="7-1-4-Array-of"><a href="#7-1-4-Array-of" class="headerlink" title="7.1.4 Array.of()"></a>7.1.4 Array.of()</h3><p>When the Array() constructor function is invoked with one numeric argument, it uses that argument as an array length. But when invoked with more than one numeric argument, it treats those arguments as elements for the array to be created. This means that the Array() constructor cannot be used to create an array with a single numeric element.</p>
<blockquote>
<p>当 Array() 构造函数调用时有一个数值型实参，它会将实参作为数组的长度。但当调用时不止一个数值型实参时，它会将那些实参作为数组的元素创建。这意味着 Array() 构造函数不能创建只有一个数值型元素的数组。</p>
</blockquote>
<p>In ES6, the Array.of() function addresses this problem: it is a factory method that creates and returns a new array, using its argument values (regardless of how many of them there are) as the array elements:</p>
<blockquote>
<p>在 ES6 中，Array.of() 函数修复了这个问题：它是一个将其实参值（无论有多少个实参）作为数组元素创建并返回一个新数组的工厂方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>()        <span class="comment">// =&gt; []; returns empty array with no arguments</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">10</span>)      <span class="comment">// =&gt; [10]; can create arrays with a single numeric argument</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)   <span class="comment">// =&gt; [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="7-1-5-Array-from"><a href="#7-1-5-Array-from" class="headerlink" title="7.1.5 Array.from()"></a>7.1.5 Array.from()</h3><p>Array.from is another array factory method introduced in ES6. It expects an iterable or array-like object as its first argument and returns a new array that contains the elements of that object. With an iterable argument, Array.from(iterable) works like the spread operator […iterable] does. It is also a simple way to make a copy of an array:</p>
<blockquote>
<p>Array.from 是 ES6 中另外一个数组工厂方法。它期望一个可迭代或类数组对象作为它的第一个实参，并返回一个包含对象中元素的新数组。使用一个可迭代实参，Array.from(iterable) 工作方式类似于展开运算符 […iterable]。它也可以简单的拷贝一个数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copy = <span class="title class_">Array</span>.<span class="title function_">from</span>(original);</span><br></pre></td></tr></table></figure>
<p>Array.from() is also important because it defines a way to make a true-array copy of an array-like object. Array-like objects are non-array objects that have a numeric length property and have values stored with properties whose names happen to be integers. When working with client-side JavaScript, the return values of some web browser methods are array-like, and it can be easier to work with them if you first convert them to true arrays:</p>
<blockquote>
<p>Array.from() 也很重要，因为它定义了一个将类数组对象拷贝成数组的方法。类数组对象是一个不是数组的对象，它有一个数值型的 length 属性，并且它的值碰巧保存在属性名为整数的属性中。当使用客户端 JavaScript 时，一些浏览器方法的返回值是类数组的，并且当将其转化成真正的数组后会更容易操作它们：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> truearray = <span class="title class_">Array</span>.<span class="title function_">from</span>(arraylike);</span><br></pre></td></tr></table></figure>
<p>Array.from() also accepts an optional second argument. If you pass a function as the second argument, then as the new array is being built, each element from the source object will be passed to the function you specify, and the return value of the function will be stored in the array instead of the original value. (This is very much like the array map() method that will be introduced later in the chapter, but it is more efficient to perform the mapping while the array is being built than it is to build the array and then map it to another new array.)</p>
<blockquote>
<p>Array.from() 第二个实参为可选实参。如果传递一个函数作为第二个实参，那么当新数组被创建，每一个元素都会被作为实参传入这个指定函数中，并且这个函数的每个返回值保存在数组中代替原来的值。（这很像后面会介绍的数组 map() 方法，但是，它会更加高效的执行映射，因其为没有创建数组，而是直接进行映射到另外一个数组。）</p>
</blockquote>
<h2 id="7-2-Reading-and-Writing-Array-Elements"><a href="#7-2-Reading-and-Writing-Array-Elements" class="headerlink" title="7.2 Reading and Writing Array Elements"></a>7.2 Reading and Writing Array Elements</h2><p>You access an element of an array using the [] operator. A reference to the array should appear to the left of the brackets. An arbitrary expression that has a non-negative integer value should be inside the brackets. You can use this syntax to both read and write the value of an element of an array. Thus, the following are all legal JavaScript statements:</p>
<blockquote>
<p>使用 [] 运算符来访问数组中的一个元素。数组的引用位于方括号的左边。方括号中是一个返回非负整数值的任意表达式。使用该语法既可以读又可以写数组的一个元素。因此，如下代码都是合法的 JavaScript 语句：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;world&quot;</span>];     <span class="comment">// Start with a one-element array</span></span><br><span class="line"><span class="keyword">let</span> value = a[<span class="number">0</span>];      <span class="comment">// Read element 0</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="number">3.14</span>;           <span class="comment">// Write element 1</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">2</span>;</span><br><span class="line">a[i] = <span class="number">3</span>;              <span class="comment">// Write element 2</span></span><br><span class="line">a[i + <span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;    <span class="comment">// Write element 3</span></span><br><span class="line">a[a[i]] = a[<span class="number">0</span>];        <span class="comment">// Read elements 0 and 2, write element 3</span></span><br></pre></td></tr></table></figure>
<p>What is special about arrays is that when you use property names that are non-negative integers less than 2<sup>32</sup>–1, the array automatically maintains the value of the length property for you. In the preceding, for example, we created an array a with a single element. We then assigned values at indexes 1, 2, and 3. The length property of the array changed as we did, so:</p>
<blockquote>
<p>数组特殊的是，当使用小于 2<sup>32</sup>–1 的非负整数属性名时，数组会自动维护 length 属性。例如，上文中我们创建了只有一个元素的数组 a。然后我们为其序列为 1、2 和 3 的元素进行赋值。数组 length 属性会自动改变：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="property">length</span>       <span class="comment">// =&gt; 4</span></span><br></pre></td></tr></table></figure>

<p>Remember that arrays are a specialized kind of object. The square brackets used to access array elements work just like the square brackets used to access object properties. JavaScript converts the numeric array index you specify to a string—the index 1 becomes the string “1”—then uses that string as a property name. There is nothing special about the conversion of the index from a number to a string: you can do that with regular objects, too:</p>
<blockquote>
<p>请记住，数组是对象的特殊形式。使用方括号访问数组元素就像用方括号访问对象的属性一样。JavaScript 将指定的数字索引值转换成字符串（索引值 1 变成“1”）然后将其作为属性名来使用。关于索引值从数字转换为字符串没什么特别之处：对常规对象也可以这么做：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;&#125;;    <span class="comment">// Create a plain object</span></span><br><span class="line">o[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;  <span class="comment">// Index it with an integer</span></span><br><span class="line">o[<span class="string">&quot;1&quot;</span>]         <span class="comment">// =&gt; &quot;one&quot;; numeric and string property names are the same</span></span><br></pre></td></tr></table></figure>
<p>It is helpful to clearly distinguish an array index from an object property name. All indexes are property names, but only property names that are integers between 0 and 2<sup>32</sup>–2 are indexes. All arrays are objects, and you can create properties of any name on them. If you use properties that are array indexes, however, arrays have the special behavior of updating their length property as needed.</p>
<blockquote>
<p>清晰地区分数组的索引和对象的属性名是非常有用的。所有的索引都是属性名，但只有在 0～2<sup>32</sup>-2 之间的整数属性名才是索引。所有的数组都是对象，可以为其创建任意名字的属性。但如果使用的属性是数组的索引，数组的特殊行为就是将根据需要更新它们的 length 属性值。</p>
</blockquote>
<p>Note that you can index an array using numbers that are negative or that are not integers. When you do this, the number is converted to a string, and that string is used as the property name. Since the name is not a non-negative integer, it is treated as a regular object property, not an array index. Also, if you index an array with a string that happens to be a non-negative integer, it behaves as an array index, not an object property. The same is true if you use a floating-point number that is the same as an integer:</p>
<blockquote>
<p>注意，可以使用负数或非整数来索引数组。这种情况下，数值转换为字符串，字符串作为属性名来用。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性。当使用的一个浮点数和一个整数相等时情况也是一样的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[-<span class="number">1.23</span>] = <span class="literal">true</span>;  <span class="comment">// This creates a property named &quot;-1.23&quot;</span></span><br><span class="line">a[<span class="string">&quot;1000&quot;</span>] = <span class="number">0</span>;    <span class="comment">// This the 1001st element of the array</span></span><br><span class="line">a[<span class="number">1.000</span>] = <span class="number">1</span>;     <span class="comment">// Array index 1. Same as a[1] = 1;</span></span><br></pre></td></tr></table></figure>
<p>The fact that array indexes are simply a special type of object property name means that JavaScript arrays have no notion of an “out of bounds” error. When you try to query a nonexistent property of any object, you don’t get an error; you simply get undefined. This is just as true for arrays as it is for objects:</p>
<blockquote>
<p>事实上数组索引仅仅是对象属性名的一种特殊类型，这意味着 JavaScript 数组没有“越界”错误的概念。当试图查询任何对象中不存在的属性时，都不会报错，只会得到 undefined 值。类似于对象，对于对象同样存在这种情况。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="literal">true</span>, <span class="literal">false</span>]; <span class="comment">// This array has elements at indexes 0 and 1</span></span><br><span class="line">a[<span class="number">2</span>]                   <span class="comment">// =&gt; undefined; no element at this index.</span></span><br><span class="line">a[-<span class="number">1</span>]                  <span class="comment">// =&gt; undefined; no property with this name.</span></span><br></pre></td></tr></table></figure>
<h2 id="7-3-Sparse-Arrays"><a href="#7-3-Sparse-Arrays" class="headerlink" title="7.3 Sparse Arrays"></a>7.3 Sparse Arrays</h2><p>A sparse array is one in which the elements do not have contiguous indexes starting at 0. Normally, the length property of an array specifies the number of elements in the array. If the array is sparse, the value of the length property is greater than the number of elements. Sparse arrays can be created with the Array() constructor or simply by assigning to an array index larger than the current array length.</p>
<blockquote>
<p>稀疏数组就是包含从 0 开始的不连续索引的数组。通常，数组的 length 属性值代表数组中元素的个数。如果数组是稀疏的，length 属性值大于元素的个数。可以用 Array() 构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>); <span class="comment">// No elements, but a.length is 5.</span></span><br><span class="line">a = [];               <span class="comment">// Create an array with no elements and length = 0.</span></span><br><span class="line">a[<span class="number">1000</span>] = <span class="number">0</span>;          <span class="comment">// Assignment adds one element but sets length to 1001.</span></span><br></pre></td></tr></table></figure>
<p>We’ll see later that you can also make an array sparse with the delete operator.</p>
<blockquote>
<p>后面会看到你也可以用 delete 运算符来生产稀疏数组。</p>
</blockquote>
<p>Arrays that are sufficiently sparse are typically implemented in a slower, more memory-efficient way than dense arrays are, and looking up elements in such an array will take about as much time as regular object property lookup.</p>
<blockquote>
<p>足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。</p>
</blockquote>
<p>Note that when you omit a value in an array literal (using repeated commas as in [1,,3]), the resulting array is sparse, and the omitted elements simply do not exist:</p>
<blockquote>
<p>注意，当在数组字面量中省略值时（像 [1,,3] 中使用重复的逗号）返回的是稀疏数组，省略掉的值是不存在的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a1 = [,];           <span class="comment">// This array has no elements and length 1</span></span><br><span class="line"><span class="keyword">let</span> a2 = [<span class="literal">undefined</span>];   <span class="comment">// This array has one undefined element</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a1                 <span class="comment">// =&gt; false: a1 has no element with index 0</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> a2                 <span class="comment">// =&gt; true: a2 has the undefined value at index 0</span></span><br></pre></td></tr></table></figure>
<p>Understanding sparse arrays is an important part of understanding the true nature of JavaScript arrays. In practice, however, most JavaScript arrays you will work with will not be sparse. And, if you do have to work with a sparse array, your code will probably treat it just as it would treat a nonsparse array with undefined elements.</p>
<blockquote>
<p>了解稀疏数组是了解 JavaScript 数组的真实本质的一部分。尽管如此，实际上你所碰到的绝大多数 JavaScript 数组不是稀疏数组。并且，如果你确实碰到了稀疏数组，你的代码很可能像对待非稀疏数组一样来对待它们，只不过它们包含一些 undefined 元素。</p>
</blockquote>
<h2 id="7-4-Array-Length"><a href="#7-4-Array-Length" class="headerlink" title="7.4 Array Length"></a>7.4 Array Length</h2><p>Every array has a length property, and it is this property that makes arrays different from regular JavaScript objects. For arrays that are dense (i.e., not sparse), the length property specifies the number of elements in the array. Its value is one more than the highest index in the array:</p>
<blockquote>
<p>每个数组有一个 length 属性，就是这个属性使其区别于常规的 JavaScript 对象。针对稠密（也就是非稀疏）数组，length 属性值代表数组中元素的个数。其值比数组中最大的索引大 1：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[].<span class="property">length</span>             <span class="comment">// =&gt; 0: the array has no elements</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>].<span class="property">length</span>  <span class="comment">// =&gt; 3: highest index is 2, length is 3</span></span><br></pre></td></tr></table></figure>
<p>When an array is sparse, the length property is greater than the number of elements, and all we can say about it is that length is guaranteed to be larger than the index of every element in the array. Or, put another way, an array (sparse or not) will never have an element whose index is greater than or equal to its length. In order to maintain this invariant, arrays have two special behaviors. The first we described above: if you assign a value to an array element whose index i is greater than or equal to the array’s current length, the value of the length property is set to i+1.</p>
<blockquote>
<p>当数组是稀疏的时，length 属性值大于元素的个数。而且关于此我们可以说数组长度保证大于它每个元素的索引值。或者，换一种说法，在数组中（无论稀疏与否）肯定找不到一个元素的索引值大于或等于它的长度。为了维持此规则不变化，数组有两个特殊的行为。第一个如同上面的描述：如果为一个数组元素赋值，它的索引 i 大于或等于现有数组的长度时，length 属性的值将设置为 i+1。</p>
</blockquote>
<p>The second special behavior that arrays implement in order to maintain the length invariant is that, if you set the length property to a non-negative integer n smaller than its current value, any array elements whose index is greater than or equal to n are deleted from the array:</p>
<blockquote>
<p>第二个特殊的行为就是设置 length 属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于 n 的元素将从中删除：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];     <span class="comment">// Start with a 5-element array.</span></span><br><span class="line">a.<span class="property">length</span> = <span class="number">3</span>;        <span class="comment">// a is now [1,2,3].</span></span><br><span class="line">a.<span class="property">length</span> = <span class="number">0</span>;        <span class="comment">// Delete all elements.  a is [].</span></span><br><span class="line">a.<span class="property">length</span> = <span class="number">5</span>;        <span class="comment">// Length is 5, but no elements, like new Array(5)</span></span><br></pre></td></tr></table></figure>
<p>You can also set the length property of an array to a value larger than its current value. Doing this does not actually add any new elements to the array; it simply creates a sparse area at the end of the array.</p>
<blockquote>
<p>还可以将数组的 length 属性值设置为大于其当前的长度。实际上这不会向数组中添加新的元素，它只是在数组尾部创建一个稀疏区域。</p>
</blockquote>
<h2 id="7-5-Adding-and-Deleting-Array-Elements"><a href="#7-5-Adding-and-Deleting-Array-Elements" class="headerlink" title="7.5 Adding and Deleting Array Elements"></a>7.5 Adding and Deleting Array Elements</h2><p>We’ve already seen the simplest way to add elements to an array: just assign values to new indexes:</p>
<blockquote>
<p>我们已经见过添加数组元素最简单的方法：为新索引赋值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];      <span class="comment">// Start with an empty array.</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;   <span class="comment">// And add elements to it.</span></span><br><span class="line">a[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>You can also use the push() method to add one or more values to the end of an array:</p>
<blockquote>
<p>也可以使用push()方法在数组末尾增加一个或多个元素：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];           <span class="comment">// Start with an empty array</span></span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&quot;zero&quot;</span>);       <span class="comment">// Add a value at the end.  a = [&quot;zero&quot;]</span></span><br><span class="line">a.<span class="title function_">push</span>(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>); <span class="comment">// Add two more values.  a = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]</span></span><br></pre></td></tr></table></figure>
<p>Pushing a value onto an array a is the same as assigning the value to a[a.length]. You can use the unshift() method (described in §7.8) to insert a value at the beginning of an array, shifting the existing array elements to higher indexes. The pop() method is the opposite of push(): it removes the last element of the array and returns it, reducing the length of an array by 1. Similarly, the shift() method removes and returns the first element of the array, reducing the length by 1 and shifting all elements down to an index one lower than their current index. See §7.8 for more on these methods.</p>
<blockquote>
<p>在数组尾部压入一个元素与给 a[a.length] 赋值是一样的。可以使用 unshift() 方法（§7.8 有描述）在数组的首部插入一个元素，并且将其他元素依次移到更高的索引处。pop() 方法与 push() 相反：它移除数组最后一个元素并返回这个元素，使数组 length 减 1。同样，shift() 方法移除并返回数组的第一个元素，使数组 length 减 1，并将其他元素依次移到低 1 的索引处。§7.8 有更多关于这些方法的描述。</p>
</blockquote>
<p>You can delete array elements with the delete operator, just as you can delete object properties:</p>
<blockquote>
<p>可以像删除对象属性一样使用 delete 运算符来删除数组元素：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">delete</span> a[<span class="number">2</span>];   <span class="comment">// a now has no element at index 2</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">in</span> a         <span class="comment">// =&gt; false: no array index 2 is defined</span></span><br><span class="line">a.<span class="property">length</span>       <span class="comment">// =&gt; 3: delete does not affect array length</span></span><br></pre></td></tr></table></figure>
<p>Deleting an array element is similar to (but subtly different than) assigning undefined to that element. Note that using delete on an array element does not alter the length property and does not shift elements with higher indexes down to fill in the gap that is left by the deleted property. If you delete an element from an array, the array becomes sparse.</p>
<blockquote>
<p>删除数组元素与为其赋 undefined 值是类似的（但有一些微妙的区别）。注意，对一个数组元素使用 delete 不会修改数组的 length 属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，它就变成稀疏数组。</p>
</blockquote>
<p>As we saw above, you can also remove elements from the end of an array simply by setting the length property to the new desired length.</p>
<blockquote>
<p>正如上面所看到的，也可以通过设置新的所需长度，即可从数组尾部删除元素。</p>
</blockquote>
<p>Finally, splice() is the general-purpose method for inserting, deleting, or replaci ng array elements. It alters the length property and shifts array elements to higher or lower indexes as needed. See §7.8 for details.</p>
<blockquote>
<p>最后，splice() 是一个通用的方法来插入、删除或替换数组元素。它会根据需要修改 length 属性并移动元素到更高或较低的索引处。详细内容见 §7.8。</p>
</blockquote>
<h2 id="7-6-Iterating-Arrays"><a href="#7-6-Iterating-Arrays" class="headerlink" title="7.6 Iterating Arrays"></a>7.6 Iterating Arrays</h2><p>As of ES6, the easiest way to loop through each of the elements of an array (or any iterable object) is with the for&#x2F;of loop, which was covered in detail in §5.4.4:</p>
<blockquote>
<p>在 ES6 中，最容易遍历数组元素（或可迭代对象）的方法是 for&#x2F;of 循环，在 §5.4.4 中详细介绍：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letters = [...<span class="string">&quot;Hello world&quot;</span>];  <span class="comment">// An array of letters</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> letter <span class="keyword">of</span> letters) &#123;</span><br><span class="line">    string += letter;</span><br><span class="line">&#125;</span><br><span class="line">string  <span class="comment">// =&gt; &quot;Hello world&quot;; we reassembled the original text</span></span><br></pre></td></tr></table></figure>
<p>The built-in array iterator that the for&#x2F;of loop uses returns the elements of an array in ascending order. It has no special behavior for sparse arrays and simply returns undefined for any array elements that do not exist.</p>
<blockquote>
<p>内置数组迭代器 for&#x2F;of 循环按照升序返回数组元素。对于稀疏数组它没有特殊的行为，数组中不存在的元素只是单纯的返回 undefined。</p>
</blockquote>
<p>If you want to use a for&#x2F;of loop for an array and need to know the index of each array element, use the entries() method of the array, along with destructuring assignment, like this:</p>
<blockquote>
<p>如果使用 for&#x2F;of 循环一个数组时还需要知道每个元素的索引，可以像这样将数组的 entries() 方法和解构语句一同使用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> everyother = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [index, letter] <span class="keyword">of</span> letters.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">2</span> === <span class="number">0</span>) everyother += letter;  <span class="comment">// letters at even indexes</span></span><br><span class="line">&#125;</span><br><span class="line">everyother  <span class="comment">// =&gt; &quot;Hlowrd&quot;</span></span><br></pre></td></tr></table></figure>
<p>Another good way to iterate arrays is with forEach(). This is not a new form of the for loop, but an array method that offers a functional approach to array iteration. You pass a function to the forEach() method of an array, and forEach() invokes your function once on each element of the array:</p>
<blockquote>
<p>另一种不错的遍历数组方法是用 forEach()。这不是 for 循环的新形式，而是提供数组遍历功能方法的数组方法。可以给数组的 forEach() 方法传递一个函数，forEach() 会对数组中每一个元素调用这个方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uppercase = <span class="string">&quot;&quot;</span>;</span><br><span class="line">letters.<span class="title function_">forEach</span>(<span class="function"><span class="params">letter</span> =&gt;</span> &#123;  <span class="comment">// Note arrow function syntax here</span></span><br><span class="line">    uppercase += letter.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;);</span><br><span class="line">uppercase  <span class="comment">// =&gt; &quot;HELLO WORLD&quot;</span></span><br></pre></td></tr></table></figure>
<p>As you would expect, forEach() iterates the array in order, and it actually passes the array index to your function as a second argument, which is occasionally useful. Unlike the for&#x2F;of loop, the forEach() is aware of sparse arrays and does not invoke your function for elements that are not there.</p>
<blockquote>
<p>正如期望的，forEach() 按顺序对数组进行计算，实际上它将数组索引作为第二个实参传递到函数，这有时很有用。与 for&#x2F;of 循环不同，forEach() 能意识到稀疏数组，并且不会为不存在的元素调用函数。</p>
</blockquote>
<p>§7.8.1 documents the forEach() method in more detail. That section also covers related methods such as map() and filter() that perform specialized kinds of array iteration.</p>
<blockquote>
<p>§7.8.1 更详细地记录了 forEach() 方法。该部分还介绍演示了特定类型的数组遍历方法，如 map() 和 filter()。</p>
</blockquote>
<p>You can also loop through the elements of an array with a good old-fashioned for loop (§5.4.3):</p>
<blockquote>
<p>也可以用一种非常老旧方式遍历数组的元素（§5.4.3）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vowels = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; letters.<span class="property">length</span>; i++) &#123; <span class="comment">// For each index in the array</span></span><br><span class="line">    <span class="keyword">let</span> letter = letters[i];              <span class="comment">// Get the element at that index</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[aeiou]/</span>.<span class="title function_">test</span>(letter)) &#123;         <span class="comment">// Use a regular expression test</span></span><br><span class="line">        vowels += letter;                 <span class="comment">// If it is a vowel, remember it</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">vowels  <span class="comment">// =&gt; &quot;eoo&quot;</span></span><br></pre></td></tr></table></figure>
<p>In nested loops, or other contexts where performance is critical, you may sometimes see this basic array iteration loop written so that the array length is only looked up once rather than on each iteration. Both of the following for loop forms are idiomatic, though not particularly common, and with modern JavaScript interpreters, it is not at all clear that they have any performance impact:</p>
<blockquote>
<p>在嵌套循环或其他性能至关重要的上下文中，有时可能会看到这样的数组遍历，以便数组长度仅被查一次，而不是在每次循环都去查询。以下两种形式都是符合习惯的 for 循环，虽然不是特别常用，而且对于现代 JavaScript 解释器，它们是否对性能有任何影响尚不清楚：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the array length into a local variable</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = letters.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// loop body remains the same</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate backwards from the end of the array to the start</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = letters.<span class="property">length</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// loop body remains the same</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These examples assume that the array is dense and that all elements contain valid data. If this is not the case, you should test the array elements before using them. If you want to skip undefined and nonexistent elements, you might write:</p>
<blockquote>
<p>这些示例假定数组是稠密的，并且所有元素都包含有效的数据。如果不是这样，应该在使用数组元素之前测试它们。如果要跳过 undefined 和不存在的元素，可以编写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; a.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] === <span class="literal">undefined</span>) <span class="keyword">continue</span>; <span class="comment">// Skip undefined + nonexistent elements</span></span><br><span class="line">    <span class="comment">// loop body here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-7-Multidimensional-Arrays"><a href="#7-7-Multidimensional-Arrays" class="headerlink" title="7.7 Multidimensional Arrays"></a>7.7 Multidimensional Arrays</h2><p>JavaScript does not support true multidimensional arrays, but you can approximate them with arrays of arrays. To access a value in an array of arrays, simply use the [] operator twice. For example, suppose the variable matrix is an array of arrays of numbers. Every element in matrix[x] is an array of numbers. To access a particular number within this array, you would write matrix[x][y]. Here is a concrete example that uses a two-dimensional array as a multiplication table:</p>
<blockquote>
<p>JavaScript 不支持真正的多维数组，但可以用数组的数组来近似。访问数组的数组中的元素，只要简单地使用两次 [] 操作符即可。例如，假设变量 matrix 是一个数组的数组，它的基本元素是数值，那么 matrix[x] 的每个元素是包含一个数值数组，访问数组中特定数值的代码为 matrix[x][y]。这里有一个具体的例子，它使用二维数组作为一个九九乘法表：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a multidimensional array</span></span><br><span class="line"><span class="keyword">let</span> table = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);               <span class="comment">// 10 rows of the table</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; table.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    table[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>);            <span class="comment">// Each row has 10 columns</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the array</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> row = <span class="number">0</span>; row &lt; table.<span class="property">length</span>; row++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; table[row].<span class="property">length</span>; col++) &#123;</span><br><span class="line">        table[row][col] = row*col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use the multidimensional array to compute 5*7</span></span><br><span class="line">table[<span class="number">5</span>][<span class="number">7</span>]  <span class="comment">// =&gt; 35</span></span><br></pre></td></tr></table></figure>
<h2 id="7-8-Array-Methods"><a href="#7-8-Array-Methods" class="headerlink" title="7.8 Array Methods"></a>7.8 Array Methods</h2><p>The preceding sections have focused on basic JavaScript syntax for working with arrays. In general, though, it is the methods defined by the Array class that are the most powerful. The next sections document these methods. While reading about these methods, keep in mind that some of them modify the array they are called on and some of them leave the array unchanged. A number of the methods return an array: sometimes, this is a new array, and the original is unchanged. Other times, a method will modify the array in place and will also return a reference to the modified array.</p>
<blockquote>
<p>前面几节重点介绍了用于处理数组的基本 JavaScript 语法。但通常，由 Array 类定义的方法是最强大的。下一节将记录这些方法。在阅读有关这些方法时，请记住，其中一些方法修改了调用的数组，而其中一些方法使数组保持不变。许多方法返回数组：有时，这是一个新数组，原始数组保持不变。其他时候，方法将修改数组，并且返回对修改后数组的引用。</p>
</blockquote>
<p>Each of the subsections that follows covers a group of related array methods:</p>
<blockquote>
<p>以下每个小节都涵盖一组相关的数组方法：</p>
</blockquote>
<p>Iterator methods loop over the elements of an array, typically invoking a function that you specify on each of those elements.</p>
<blockquote>
<p>迭代器方法循环遍历数组的元素，通常调用在每个元素上指定的函数。</p>
</blockquote>
<p>Stack and queue methods add and remove array elements to and from the beginning and the end of an array.</p>
<blockquote>
<p>堆栈和队列方法在数组的开头和结尾添加和删除数组元素。</p>
</blockquote>
<p>Subarray methods are for extracting, deleting, inserting, filling, and copying contiguous regions of a larger array.</p>
<blockquote>
<p>子数组方法用于提取、删除、插入、填充和复制一个更大数组中相邻的区域。</p>
</blockquote>
<p>Searching and sorting methods are for locating elements within an array and for sorting the elements of an array.</p>
<blockquote>
<p>搜索和排序方法用于查找数组中的元素和排序数组的元素。</p>
</blockquote>
<p>The following subsections also cover the static methods of the Array class and a few miscellaneous methods for concatenating arrays and converting arrays to strings.</p>
<blockquote>
<p>以下小节还介绍 Array 类的静态方法和一些用于连接数组和将数组转换为字符串的各种方法。</p>
</blockquote>
<h3 id="7-8-1-Array-Iterator-Methods"><a href="#7-8-1-Array-Iterator-Methods" class="headerlink" title="7.8.1 Array Iterator Methods"></a>7.8.1 Array Iterator Methods</h3><p>The methods described in this section iterate over arrays by passing array elements, in order, to a function you supply, and they provide convenient ways to iterate, map, filter, test, and reduce arrays.</p>
<blockquote>
<p>本节中介绍的方法通过将数组元素按顺序传递到所指定的函数来遍历数组，它们提供了迭代、映射、筛选、测试和减少数组的便捷方法。</p>
</blockquote>
<p>Before we explain the methods in detail, however, it is worth making some generalizations about them. First, all of these methods accept a function as their first argument and invoke that function once for each element (or some elements) of the array. If the array is sparse, the function you pass is not invoked for nonexistent elements. In most cases, the function you supply is invoked with three arguments: the value of the array element, the index of the array element, and the array itself. Often, you only need the first of these argument values and can ignore the second and third values.</p>
<blockquote>
<p>然而，在详细解释这些方法之前，值得对它们进行一些概括。首先，所有这些方法都接受函数作为其第一个实参，并使用调用数组的每个元素（或某些元素）作为实参调用该函数。如果数组是稀疏的，则不会为不存在的元素调用传递的函数。在大多数情况下，提供的函数被调用时有三个实参：数组元素的值、数组元素的索引和数组本身。通常，只需要这些实参值中的第一个，并且可以忽略第二个和第三个值。</p>
</blockquote>
<p>Most of the iterator methods described in the following subsections accept an optional second argument. If specified, the function is invoked as if it is a method of this second argument. That is, the second argument you pass becomes the value of the this keyword inside of the function you pass as the first argument. The return value of the function you pass is usually important, but different methods handle the return value in different ways. None of the methods described here modify the array on which they are invoked (though the function you pass can modify the array, of course).</p>
<blockquote>
<p>以下小节中描述的大多数迭代器方法都接受可选的第二个实参。如果指定，则调用函数就像它是第二个实参的方法一样。也就是说，传递的第二个实参将成为第一个函数实参内部的 this 值。传递的函数的返回值通常很重要，但不同的方法以不同的方式处理返回值。此处描述的方法都没有修改调用它们的数组（当然，传递的函数可以修改这个数组）。</p>
</blockquote>
<p>Each of these functions is invoked with a function as its first argument, and it is very common to define that function inline as part of the method invocation expression instead of using an existing function that is defined elsewhere. Arrow function syntax (see §8.1.3) works particularly well with these methods, and we will use it in the examples that follow.</p>
<blockquote>
<p>这节的每个函数都调用它的第一个函数实参，并且通常将该函数内联定义为方法调用表达式的一部分，而不是使用在其他地方显示定义的函数。箭头函数语法（参见 §8.1.3）在这些方法中特别有效，我们将在下面的示例中使用它。</p>
</blockquote>
<h4 id="FOREACH"><a href="#FOREACH" class="headerlink" title="FOREACH()"></a>FOREACH()</h4><p>The forEach() method iterates through an array, invoking a function you specify for each element. As we’ve described, you pass the function as the first argument to forEach(). forEach() then invokes your function with three arguments: the value of the array element, the index of the array element, and the array itself. If you only care about the value of the array element, you can write a function with only one parameter—the additional arguments will be ignored:</p>
<blockquote>
<p>forEach() 方法遍历数组，调用为每个元素指定的函数。正如我们已经描述的那样，将函数作为第一个实参传递给 forEach()。forEach() 然后使用三个实参调用函数：数组元素的值、数组元素的索引和数组本身。如果只关心数组元素的值，则编写一个只有一个实参的函数（将忽略其他实参）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// Compute the sum of the elements of the array</span></span><br><span class="line">data.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123; sum += value; &#125;);          <span class="comment">// sum == 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Now increment each array element</span></span><br><span class="line">data.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">v, i, a</span>) &#123; a[i] = v + <span class="number">1</span>; &#125;); <span class="comment">// data == [2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>
<p>Note that forEach() does not provide a way to terminate iteration before all elements have been passed to the function. That is, there is no equivalent of the break statement you can use with a regular for loop.</p>
<blockquote>
<p>请注意，forEach() 不提供在所有元素传递给函数之前终止迭代的方法。也就是说，没有等效于常规 for 循环的 break 语句可以使用。</p>
</blockquote>
<h4 id="MAP"><a href="#MAP" class="headerlink" title="MAP()"></a>MAP()</h4><p>The map() method passes each element of the array on which it is invoked to the function you specify and returns an array containing the values returned by your function. For example:</p>
<blockquote>
<p>map() 方法将调用数组的每个元素传递到指定的函数，并返回一个包含函数返回的值的数组。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x*x)   <span class="comment">// =&gt; [1, 4, 9]: the function takes input x and returns x*x</span></span><br></pre></td></tr></table></figure>
<p>The function you pass to map() is invoked in the same way as a function passed to forEach(). For the map() method, however, the function you pass should return a value. Note that map() returns a new array: it does not modify the array it is invoked on. If that array is sparse, your function will not be called for the missing elements, but the returned array will be sparse in the same way as the original array: it will have the same length and the same missing elements.</p>
<blockquote>
<p>传递到 map() 的函数的调用方式与传递给 forEach() 的函数相同。但是，对于 map() 方法，传递的函数应返回一个值。请注意，map() 返回一个新数组：它不会修改调用它的数组。如果该数组是稀疏的，则不会为缺失的元素调用函数，但返回的数组将稀疏，其确实元素与原始数组的位置相同：它将具有相同的长度和相同的缺失元素。</p>
</blockquote>
<h4 id="FILTER"><a href="#FILTER" class="headerlink" title="FILTER()"></a>FILTER()</h4><p>The filter() method returns an array containing a subset of the elements of the array on which it is invoked. The function you pass to it should be predicate: a function that returns true or false. The predicate is invoked just as for forEach() and map(). If the return value is true, or a value that converts to true, then the element passed to the predicate is a member of the subset and is added to the array that will become the return value. Examples:</p>
<blockquote>
<p>filter() 方法返回一个数组，其中包含调用该数组的数组元素的子集。传递给它的函数应该是断言：返回真或假的函数。断言函数的调用就像 forEach() 和 map() 调用一样。如果返回值为 true，或者能转换为 true 的值，则传递给断言的元素是子集的成员，并将添加到将成为返回值的数组中。例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line">a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">3</span>)         <span class="comment">// =&gt; [2, 1]; values less than 3</span></span><br><span class="line">a.<span class="title function_">filter</span>(<span class="function">(<span class="params">x,i</span>) =&gt;</span> i%<span class="number">2</span> === <span class="number">0</span>) <span class="comment">// =&gt; [5, 3, 1]; every other value</span></span><br></pre></td></tr></table></figure>
<p>Note that filter() skips missing elements in sparse arrays and that its return value is always dense. To close the gaps in a sparse array, you can do this:</p>
<blockquote>
<p>注意 filter() 跳过稀疏数组中的丢失元素并且返回值也总是稠密的。要缩小稀疏数组的间距，可以这样做：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dense = sparse.<span class="title function_">filter</span>(<span class="function">() =&gt;</span> <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>And to close gaps and remove undefined and null elements, you can use filter, like this:</p>
<blockquote>
<p>要缩小间隙并移除 undefined 和 null 元素，可以用 filter 这样做：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a.<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="literal">undefined</span> &amp;&amp; x !== <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="FIND-AND-FINDINDEX"><a href="#FIND-AND-FINDINDEX" class="headerlink" title="FIND() AND FINDINDEX()"></a>FIND() AND FINDINDEX()</h4><p>The find() and findIndex() methods are like filter() in that they iterate through your array looking for elements for which your predicate function returns a truthy value. Unlike filter(), however, these two methods stop iterating the first time the predicate finds an element. When that happens, find() returns the matching element, and findIndex() returns the index of the matching element. If no matching element is found, find() returns undefined and findIndex() returns -1:</p>
<blockquote>
<p>find() 和 findIndex() 方法就像 filter()，因为它们在数组中迭代，查找断言函数返回真实值的元素。但是，与 filter()不同，这两种方法在断言首次查找元素到时停止遍历。发生这种情况时，find() 返回匹配元素，而 findIndex() 返回匹配元素的索引。如果未找到匹配元素，find() 返回 undefined，findIndex() 返回 -1：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span> =&gt;</span> x === <span class="number">3</span>)  <span class="comment">// =&gt; 2; the value 3 appears at index 2</span></span><br><span class="line">a.<span class="title function_">findIndex</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">0</span>)    <span class="comment">// =&gt; -1; no negative numbers in the array</span></span><br><span class="line">a.<span class="title function_">find</span>(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">5</span> === <span class="number">0</span>)   <span class="comment">// =&gt; 5: this is a multiple of 5</span></span><br><span class="line">a.<span class="title function_">find</span>(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">7</span> === <span class="number">0</span>)   <span class="comment">// =&gt; undefined: no multiples of 7 in the array</span></span><br></pre></td></tr></table></figure>
<h4 id="EVERY-AND-SOME"><a href="#EVERY-AND-SOME" class="headerlink" title="EVERY() AND SOME()"></a>EVERY() AND SOME()</h4><p>The every() and some() methods are array predicates: they apply a predicate function you specify to the elements of the array, then return true or false.</p>
<blockquote>
<p>every() 和 some() 方法是数组断言：它们将指定的断言函数应用于数组的元素，然后返回 true 或 false。</p>
</blockquote>
<p>The every() method is like the mathematical “for all” quantifier ∀: it returns true if and only if your predicate function returns true for all elements in the array:</p>
<blockquote>
<p>every() 方法与数学全称量化符号 ∀ 相似：如果数组中所有元素执行断言函数返回值都为 true，则返回 true：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">10</span>)      <span class="comment">// =&gt; true: all values are &lt; 10.</span></span><br><span class="line">a.<span class="title function_">every</span>(<span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span>) <span class="comment">// =&gt; false: not all values are even.</span></span><br></pre></td></tr></table></figure>
<p>The some() method is like the mathematical “there exists” quantifier ∃: it returns true if there exists at least one element in the array for which the predicate returns true and returns false if and only if the predicate returns false for all elements of the array:</p>
<blockquote>
<p>some() 方法与数学存在限定符 ∃ 相同：如果数组中存在至少有一个元素调用断言函数返回 true 的返回 true，仅在断言全部返回 false 时返回 false：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">some</span>(<span class="function"><span class="params">x</span> =&gt;</span> x%<span class="number">2</span>===<span class="number">0</span>)  <span class="comment">// =&gt; true; a has some even numbers.</span></span><br><span class="line">a.<span class="title function_">some</span>(<span class="built_in">isNaN</span>)         <span class="comment">// =&gt; false; a has no non-numbers.</span></span><br></pre></td></tr></table></figure>
<p>Note that both every() and some() stop iterating array elements as soon as they know what value to return. some() returns true the first time your predicate returns true and only iterates through the entire array if your predicate always returns false. every() is the opposite: it returns false the first time your predicate returns false and only iterates all elements if your predicate always returns true. Note also that, by mathematical convention, every() returns true and some returns false when invoked on an empty array.</p>
<blockquote>
<p>请注意，every() 和 some() 只要它们知道要返回的值，都停止对数组元素的遍历。some() 在断言函数第一次返回 true 时返回 true，并且只有在每个元素调用断言函数都返回 false 时，才会遍历整个数组 。every() 正好相反：它返回 false 时，您的谓词返回 false，并且仅在谓词始终返回 true 时，才会回注所有元素。另请注意，根据数学约定，every() 返回 true，有些返回 false，当在空数组上调用时，某些返回 false。</p>
</blockquote>
<h4 id="REDUCE-AND-REDUCERIGHT"><a href="#REDUCE-AND-REDUCERIGHT" class="headerlink" title="REDUCE() AND REDUCERIGHT()"></a>REDUCE() AND REDUCERIGHT()</h4><p>The reduce() and reduceRight() methods combine the elements of an array, using the function you specify, to produce a single value. This is a common operation in functional programming and also goes by the names “inject” and “fold.” Examples help illustrate how it works:</p>
<blockquote>
<p>reduce() 和 reduceRight() 方法使用指定的函数将数组元素进行组合，生成单个值。这在函数式编程中是常见的操作，也可以称为“注入”和“折叠”。举例说明它是如何工作的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y, <span class="number">0</span>)          <span class="comment">// =&gt; 15; the sum of the values</span></span><br><span class="line">a.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x*y, <span class="number">1</span>)          <span class="comment">// =&gt; 120; the product of the values</span></span><br><span class="line">a.<span class="title function_">reduce</span>(<span class="function">(<span class="params">x,y</span>) =&gt;</span> (x &gt; y) ? x : y) <span class="comment">// =&gt; 5; the largest of the values</span></span><br></pre></td></tr></table></figure>
<p>reduce() takes two arguments. The first is the function that performs the reduction operation. The task of this reduction function is to somehow combine or reduce two values into a single value and to return that reduced value. In the examples we’ve shown here, the functions combine two values by adding them, multiplying them, and choosing the largest. The second (optional) argument is an initial value to pass to the function.</p>
<blockquote>
<p>reduce() 需要两个实参。第一个是执行化简操作的函数。化简函数的任务就是用某种方法把两个值组合或化简为一个值，并返回化简后的值。在上述例子中，函数通过加法、乘法或取最大值的方法组合两个值。第二个（可选）的实参是一个传递给函数的初始值。</p>
</blockquote>
<p>Functions used with reduce() are different than the functions used with forEach() and map(). The familiar value, index, and array values are passed as the second, third, and fourth arguments. The first argument is the accumulated result of the reduction so far. On the first call to the function, this first argument is the initial value you passed as the second argument to reduce(). On subsequent calls, it is the value returned by the previous invocation of the function. In the first example, the reduction function is first called with arguments 0 and 1. It adds these and returns 1. It is then called again with arguments 1 and 2 and returns 3. Next, it computes 3+3&#x3D;6, then 6+4&#x3D;10, and finally 10+5&#x3D;15. This final value, 15, becomes the return value of reduce().</p>
<blockquote>
<p>reduce() 使用的函数与 forEach() 和 map() 使用的函数不同。比较熟悉的是，数组元素、元素的索引和数组本身将作为第 2～4 个实参传递给函数。第一个实参是到目前为止的化简操作累积的结果。第一次调用函数时，第一个实参是一个初始值，它就是传递给 reduce() 的第二个实参。在接下来的调用中，这个值就是上一次化简函数的返回值。在上面的第一个例子中，第一次调用化简函数时的实参是 0 和 1。将两者相加并返回 1。再次调用时的实参是 1 和 2，它返回 3。然后它计算 3+3&#x3D;6、6+4&#x3D;10， 最后计算 10+5&#x3D;15。最后的值是 15，reduce() 返回这个值。</p>
</blockquote>
<p>You may have noticed that the third call to reduce() in this example has only a single argument: there is no initial value specified. When you invoke reduce() like this with no initial value, it uses the first element of the array as the initial value. This means that the first call to the reduction function will have the first and second array elements as its first and second arguments. In the sum and product examples, we could have omitted the initial value argument.</p>
<blockquote>
<p>可能已经注意到了，上面第三次调用 reduce() 时只有一个实参：没有指定初始值。当不指定初始值调用 reduce() 时，它将使用数组的第一个元素作为其初始值。这意味着第一次调用化简函数就使用了第一个和第二个数组元素作为其第一个和第二个实参。在上面求和与求积的例子中，可以省略初始值实参。</p>
</blockquote>
<p>Calling reduce() on an empty array with no initial value argument causes a TypeError. If you call it with only one value—either an array with one element and no initial value or an empty array and an initial value—it simply returns that one value without ever calling the reduction function.</p>
<blockquote>
<p>在空数组上，不带初始值实参调用 reduce() 将导致类型错误异常。如果调用它的时候只有一个值（数组只有一个元素并且没有指定初始值，或者有一个空数组并且指定一个初始值）reduce() 只是简单地返回那个值而不会调用化简函数。</p>
</blockquote>
<p>reduceRight() works just like reduce(), except that it processes the array from highest index to lowest (right-to-left), rather than from lowest to highest. You might want to do this if the reduction operation has right-to-left associativity, for example:</p>
<blockquote>
<p>reduceRight() 的工作原理和 reduce() 一样，不同的是它按照数组索引从高到低（从右到左）处理数组，而不是从低到高。如果 reduction 操作的优先顺序是从右到左，你可能想使用它，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute 2^(3^4).  Exponentiation has right-to-left precedence</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">a.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">acc,val</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(val,acc)) <span class="comment">// =&gt; 2.4178516392292583e+24</span></span><br></pre></td></tr></table></figure>
<p>Note that neither reduce() nor reduceRight() accepts an optional argument that specifies the this value on which the reduction function is to be invoked. The optional initial value argument takes its place. See the Function.bind() method (§8.7.5) if you need your reduction function invoked as a method of a particular object.</p>
<blockquote>
<p>注意，reduce() 和 reduceRight() 都能接收一个可选的实参，它指定了化简函数调用时的 this 关键字的值。可选的初始值实参仍然需要占一个位置。如果想让化简函数作为一个特殊对象的方法调用，请参看 Function.bind() 方法（§8.7.5）。</p>
</blockquote>
<p>The examples shown so far have been numeric for simplicity, but reduce() and reduceRight() are not intended solely for mathematical computations. Any function that can combine two values (such as two objects) into one value of the same type can be used as a reduction function. On the other hand, algorithms expressed using array reductions can quickly become complex and hard to understand, and you may find that it is easier to read, write, and reason about your code if you use regular looping constructs to process your arrays.</p>
<blockquote>
<p>为了简单起见，到目前位置所展示的例子都是数值的，但数学计算不是 reduce() 和 reduceRight() 的唯一意图。任何想要将两个相同类型的值（例如两个对象）合并到一个值的函数都可以用化简函数。另一方面，使用数组化简的算法可能很快变得复杂且难以理解，可能会发现，如果使用常规循环构造来处理数组则更容易读、写和推理。</p>
</blockquote>
<h3 id="7-8-2-Flattening-arrays-with-flat-and-flatMap"><a href="#7-8-2-Flattening-arrays-with-flat-and-flatMap" class="headerlink" title="7.8.2 Flattening arrays with flat() and flatMap()"></a>7.8.2 Flattening arrays with flat() and flatMap()</h3><p>In ES2019, the flat() method creates and returns a new array that contains the same elements as the array it is called on, except that any elements that are themselves arrays are “flattened” into the returned array. For example:</p>
<blockquote>
<p>在 ES2019 中，flat() 方法创建并返回一个新的数组，该数组包含与调用的数组相同的元素，只不过作为数组的任何元素都”展平”到返回的数组中。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>]].<span class="title function_">flat</span>()    <span class="comment">// =&gt; [1, 2, 3]</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].<span class="title function_">flat</span>()  <span class="comment">// =&gt; [1, 2, [3]]</span></span><br></pre></td></tr></table></figure>
<p>When called with no arguments, flat() flattens one level of nesting. Elements of the original array that are themselves arrays are flattened, but array elements of those arrays are not flattened. If you want to flatten more levels, pass a number to flat():</p>
<blockquote>
<p>当调用时没有实参，flat() 将平展一个级别的嵌套。作为数组的原始数组的元素被展平，但这些数组的数组元素不会展平。如果要展平更多级别，需要传递数字给 flat()：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]];</span><br><span class="line">a.<span class="title function_">flat</span>(<span class="number">1</span>)   <span class="comment">// =&gt; [1, 2, [3, [4]]]</span></span><br><span class="line">a.<span class="title function_">flat</span>(<span class="number">2</span>)   <span class="comment">// =&gt; [1, 2, 3, [4]]</span></span><br><span class="line">a.<span class="title function_">flat</span>(<span class="number">3</span>)   <span class="comment">// =&gt; [1, 2, 3, 4]</span></span><br><span class="line">a.<span class="title function_">flat</span>(<span class="number">4</span>)   <span class="comment">// =&gt; [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>The flatMap() method works just like the map() method (see “map()”) except that the returned array is automatically flattened as if passed to flat(). That is, calling a.flatMap(f) is the same as (but more efficient than) a.map(f).flat():</p>
<blockquote>
<p>flatMap() 方法的工作方式与 map() 方法（见“map()”）类似，只不过返回的数组会自动展平，就像传递到 flat()。也就是说，调用 a.flatMap(f) 与 a.map(f).flat()（但更高效）相同：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> phrases = [<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;the definitive guide&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> words = phrases.<span class="title function_">flatMap</span>(<span class="function"><span class="params">phrase</span> =&gt;</span> phrase.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>));</span><br><span class="line">words <span class="comment">// =&gt; [&quot;hello&quot;, &quot;world&quot;, &quot;the&quot;, &quot;definitive&quot;, &quot;guide&quot;];</span></span><br></pre></td></tr></table></figure>
<p>You can think of flatMap() as a generalization of map() that allows each element of the input array to map to any number of elements of the output array. In particular, flatMap() allows you to map input elements to an empty array, which flattens to nothing in the output array:</p>
<blockquote>
<p>可以将 flatMap() 视为 map() 的泛化，它允许输入数组的每个元素映射到输出数组的多个元素。特别的是，flatMap() 允许将输入元素映射到空数组，该数组在平展后不输出到数组中：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map non-negative numbers to their square roots</span></span><br><span class="line">[-<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>].<span class="title function_">flatMap</span>(<span class="function"><span class="params">x</span> =&gt;</span> x &lt; <span class="number">0</span> ? [] : <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(x)) <span class="comment">// =&gt; [1, 2**0.5]</span></span><br></pre></td></tr></table></figure>
<h3 id="7-8-3-Adding-arrays-with-concat"><a href="#7-8-3-Adding-arrays-with-concat" class="headerlink" title="7.8.3 Adding arrays with concat()"></a>7.8.3 Adding arrays with concat()</h3><p>The concat() method creates and returns a new array that contains the elements of the original array on which concat() was invoked, followed by each of the arguments to concat(). If any of these arguments is itself an array, then it is the array elements that are concatenated, not the array itself. Note, however, that concat() does not recursively flatten arrays of arrays. concat() does not modify the array on which it is invoked:</p>
<blockquote>
<p>concat() 方法创建并返回一个新数组，它的元素包括调用 concat() 的原始数组的元素和 concat() 的每个实参。如果这些实参中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat() 不会递归扁平化数组的数组。concat() 也不会修改调用的数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">concat</span>(<span class="number">4</span>, <span class="number">5</span>)          <span class="comment">// =&gt; [1,2,3,4,5]</span></span><br><span class="line">a.<span class="title function_">concat</span>([<span class="number">4</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">7</span>])   <span class="comment">// =&gt; [1,2,3,4,5,6,7]; arrays are flattened</span></span><br><span class="line">a.<span class="title function_">concat</span>(<span class="number">4</span>, [<span class="number">5</span>,[<span class="number">6</span>,<span class="number">7</span>]])  <span class="comment">// =&gt; [1,2,3,4,5,[6,7]]; but not nested arrays</span></span><br><span class="line">a                       <span class="comment">// =&gt; [1,2,3]; the original array is unmodified</span></span><br></pre></td></tr></table></figure>
<p>Note that concat() makes a new copy of the array it is called on. In many cases, this is the right thing to do, but it is an expensive operation. If you find yourself writing code like <code>a = a.concat(x)</code>, then you should think about modifying your array in place with push() or splice() instead of creating a new one.</p>
<blockquote>
<p>请注意，concat() 创建调用数组的新副本。在许多情况下，这是正确的做法，但它是一个昂贵的操作。如果您发现自己编写代码像 <code>a = a.concat(x)</code>，那么您应该考虑使用 push() 或 splice() 修改数组，而不是创建新的数组。</p>
</blockquote>
<h3 id="7-8-4-Stacks-and-Queues-with-push-pop-shift-and-unshift"><a href="#7-8-4-Stacks-and-Queues-with-push-pop-shift-and-unshift" class="headerlink" title="7.8.4 Stacks and Queues with push(), pop(), shift(), and unshift()"></a>7.8.4 Stacks and Queues with push(), pop(), shift(), and unshift()</h3><p>The push() and pop() methods allow you to work with arrays as if they were stacks. The push() method appends one or more new elements to the end of an array and returns the new length of the array. Unlike concat(), push() does not flatten array arguments. The pop() method does the reverse: it deletes the last element of an array, decrements the array length, and returns the value that it removed. Note that both methods modify the array in place. The combination of push() and pop() allows you to use a JavaScript array to implement a first-in, last-out stack. For example:</p>
<blockquote>
<p>push() 和 pop() 方法允许将数组当做栈来使用。push() 方法在数组的尾部添加一个或多个元素，并返回数组新的长度。pop() 方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。注意，两个方法都修改并替换原始数组而非生成一个修改版的新数组。组合使用 push() 和 pop() 能够用 JavaScript 数组实现先进后出的栈。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stack = [];       <span class="comment">// stack == []</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">1</span>,<span class="number">2</span>);      <span class="comment">// stack == [1,2];</span></span><br><span class="line">stack.<span class="title function_">pop</span>();          <span class="comment">// stack == [1]; returns 2</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="number">3</span>);        <span class="comment">// stack == [1,3]</span></span><br><span class="line">stack.<span class="title function_">pop</span>();          <span class="comment">// stack == [1]; returns 3</span></span><br><span class="line">stack.<span class="title function_">push</span>([<span class="number">4</span>,<span class="number">5</span>]);    <span class="comment">// stack == [1,[4,5]]</span></span><br><span class="line">stack.<span class="title function_">pop</span>()           <span class="comment">// stack == [1]; returns [4,5]</span></span><br><span class="line">stack.<span class="title function_">pop</span>();          <span class="comment">// stack == []; returns 1</span></span><br></pre></td></tr></table></figure>
<p>The push() method does not flatten an array you pass to it, but if you want to push all of the elements from one array onto another array, you can use the spread operator (§8.3.4) to flatten it explicitly:</p>
<blockquote>
<p>push() 方法不展平传入的数组，但如果想要将数组的元素全部压入另外一个数组，可以使用展开运算符（§8.3.4）来显示展开：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.<span class="title function_">push</span>(...values);</span><br></pre></td></tr></table></figure>
<p>The unshift() and shift() methods behave much like push() and pop(), except that they insert and remove elements from the beginning of an array rather than from the end. unshift() adds an element or elements to the beginning of the array, shifts the existing array elements up to higher indexes to make room, and returns the new length of the array. shift() removes and returns the first element of the array, shifting all subsequent elements down one place to occupy the newly vacant space at the start of the array. You could use unshift() and shift() to implement a stack, but it would be less efficient than using push() and pop() because the array elements need to be shifted up or down every time an element is added or removed at the start of the array. Instead, though, you can implement a queue data structure by using push() to add elements at the end of an array and shift() to remove them from the start of the array:</p>
<blockquote>
<p>unshift() 和 shift() 方法的行为非常类似于 push() 和 pop()，不一样的是前者是在数组的头部而非尾部进行元素的插入和删除操作。unshift() 在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度。shift() 删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺。可以使用 unshift() 和 shift() 实现栈，但它比使用 push() 和 pop() 的效率低，因为每次在数组头部添加或删除元素时，都需要向上或向下移动数组元素。但是，您可以使用 push() 在数组末尾添加元素并 shift() 从数组的头部删除它们来实现队列数据解构：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> q = [];            <span class="comment">// q == []</span></span><br><span class="line">q.<span class="title function_">push</span>(<span class="number">1</span>,<span class="number">2</span>);           <span class="comment">// q == [1,2]</span></span><br><span class="line">q.<span class="title function_">shift</span>();             <span class="comment">// q == [2]; returns 1</span></span><br><span class="line">q.<span class="title function_">push</span>(<span class="number">3</span>)              <span class="comment">// q == [2, 3]</span></span><br><span class="line">q.<span class="title function_">shift</span>()              <span class="comment">// q == [3]; returns 2</span></span><br><span class="line">q.<span class="title function_">shift</span>()              <span class="comment">// q == []; returns 3</span></span><br></pre></td></tr></table></figure>
<p>There is one feature of unshift() that is worth calling out because you may find it surprising. When passing multiple arguments to unshift(), they are inserted all at once, which means that they end up in the array in a different order than they would be if you inserted them one at a time:</p>
<blockquote>
<p>unshift() 有一个特性是值得一提的，你可能会觉得它令人惊讶。将多个实参传入 unshift() 时，它们将一次全部插入，这意味着它们最终在数组中的顺序与一次插入一个实参的顺序时不同的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [];            <span class="comment">// a == []</span></span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="number">1</span>)           <span class="comment">// a == [1]</span></span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="number">2</span>)           <span class="comment">// a == [2, 1]</span></span><br><span class="line">a = [];                <span class="comment">// a == []</span></span><br><span class="line">a.<span class="title function_">unshift</span>(<span class="number">1</span>,<span class="number">2</span>)         <span class="comment">// a == [1, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="7-8-5-Subarrays-with-slice-splice-fill-and-copyWithin"><a href="#7-8-5-Subarrays-with-slice-splice-fill-and-copyWithin" class="headerlink" title="7.8.5 Subarrays with slice(), splice(), fill(), and copyWithin()"></a>7.8.5 Subarrays with slice(), splice(), fill(), and copyWithin()</h3><p>Arrays define a number of methods that work on contiguous regions, or subarrays or “slices” of an array. The following sections describe methods for extracting, replacing, filling, and copying slices.</p>
<blockquote>
<p>数组定义了许多在连续区域，子数组或数组的“片段”上工作的方法。 以下各节描述了提取，替换，填充和复制片段的方法。</p>
</blockquote>
<h4 id="SLICE"><a href="#SLICE" class="headerlink" title="SLICE()"></a>SLICE()</h4><p>The slice() method returns a slice, or subarray, of the specified array. Its two arguments specify the start and end of the slice to be returned. The returned array contains the element specified by the first argument and all subsequent elements up to, but not including, the element specified by the second argument. If only one argument is specified, the returned array contains all elements from the start position to the end of the array. If either argument is negative, it specifies an array element relative to the length of the array. An argument of –1, for example, specifies the last element in the array, and an argument of –2 specifies the element before that one. Note that slice() does not modify the array on which it is invoked. Here are some examples:</p>
<blockquote>
<p>slice() 方法返回指定数组的一个片段或子数组。它的两个实参分别指定了片段的开始和结束的位置。返回的数组包含第一个实参指定的位置到（但不包含）第二个实参指定的位置之间的所有数组元素。如果只指定一个实参，返回的数组将包含从开始位置到数组结尾的所有元素。如实参中出现负数，它表示相对于数组 length 的位置。例如，实参 -1 指定了最后一个元素，而 -2 指定了它前面的元素。注意，slice() 不会修改调用的数组。下面有一些示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">0</span>,<span class="number">3</span>);    <span class="comment">// Returns [1,2,3]</span></span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">3</span>);      <span class="comment">// Returns [4,5]</span></span><br><span class="line">a.<span class="title function_">slice</span>(<span class="number">1</span>,-<span class="number">1</span>);   <span class="comment">// Returns [2,3,4]</span></span><br><span class="line">a.<span class="title function_">slice</span>(-<span class="number">3</span>,-<span class="number">2</span>);  <span class="comment">// Returns [3]</span></span><br></pre></td></tr></table></figure>
<h4 id="SPLICE"><a href="#SPLICE" class="headerlink" title="SPLICE()"></a>SPLICE()</h4><p>splice() is a general-purpose method for inserting or removing elements from an array. Unlike slice() and concat(), splice() modifies the array on which it is invoked. Note that splice() and slice() have very similar names but perform substantially different operations.</p>
<blockquote>
<p>splice() 方法是在数组中插入或删除元素的通用方法。不同于 slice() 和 concat()，splice() 会修改调用的数组。注意，splice() 和 slice() 拥有非常相似的名字， 但它们的功能却有本质的区别。</p>
</blockquote>
<p>splice() can delete elements from an array, insert new elements into an array, or perform both operations at the same time. Elements of the array that come after the insertion or deletion point have their indexes increased or decreased as necessary so that they remain contiguous with the rest of the array. The first argument to splice() specifies the array position at which the insertion and&#x2F;or deletion is to begin. The second argument specifies the number of elements that should be deleted from (spliced out of) the array. (Note that this is another difference between these two methods. The second argument to slice() is an end position. The second argument to splice() is a length.) If this second argument is omitted, all array elements from the start element to the end of the array are removed. splice() returns an array of the deleted elements, or an empty array if no elements were deleted. For example:</p>
<blockquote>
<p>splice() 能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。在插入或删除点之后的数组元素会根据需要增加或减小它们的索引值，因此数组的其他部分仍然保持连续的。splice() 的第一个实参指定了插入和（或）删除的起始位置。第二个实参指定了应该从数组中删除的元素的个数。（注意这里是这两个方法的另外一个不同。slice() 的第二个实参是结束的位置。splice() 的第二个实参是长度。）如果省略第二个实参，从起始点开始到数组结尾的所有元素都将被删除。splice() 返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>];</span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">4</span>)    <span class="comment">// =&gt; [5,6,7,8]; a is now [1,2,3,4]</span></span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">// =&gt; [2,3]; a is now [1,4]</span></span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>)  <span class="comment">// =&gt; [4]; a is now [1]</span></span><br></pre></td></tr></table></figure>
<p>The first two arguments to splice() specify which array elements are to be deleted. These arguments may be followed by any number of additional arguments that specify elements to be inserted into the array, starting at the position specified by the first argument. For example:</p>
<blockquote>
<p>splice() 的前两个实参指定了需要删除的数组元素。紧随其后的任意个数的实参指定了需要插入到数组中的元素，从第一个实参指定的位置开始插入。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">0</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>)  <span class="comment">// =&gt; []; a is now [1,2,&quot;a&quot;,&quot;b&quot;,3,4,5]</span></span><br><span class="line">a.<span class="title function_">splice</span>(<span class="number">2</span>,<span class="number">2</span>,[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>)  <span class="comment">// =&gt; [&quot;a&quot;,&quot;b&quot;]; a is now [1,2,[1,2],3,3,4,5]</span></span><br></pre></td></tr></table></figure>
<p>Note that, unlike concat(), splice() inserts arrays themselves, not the elements of those arrays.</p>
<blockquote>
<p>注意，不同于 concat()，splice() 插入数组本身，不是数组的元素。</p>
</blockquote>
<h4 id="FILL"><a href="#FILL" class="headerlink" title="FILL()"></a>FILL()</h4><p>The fill() method sets the elements of an array, or a slice of an array, to a specified value. It mutates the array it is called on, and also returns the modified array:</p>
<blockquote>
<p>fill() 方法将数组或数组片段的元素填充为指定值。它将对调用它的数组进行突变，并返回修改后的数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">5</span>);   <span class="comment">// Start with no elements and length 5</span></span><br><span class="line">a.<span class="title function_">fill</span>(<span class="number">0</span>)               <span class="comment">// =&gt; [0,0,0,0,0]; fill the array with zeros</span></span><br><span class="line">a.<span class="title function_">fill</span>(<span class="number">9</span>, <span class="number">1</span>)            <span class="comment">// =&gt; [0,9,9,9,9]; fill with 9 starting at index 1</span></span><br><span class="line">a.<span class="title function_">fill</span>(<span class="number">8</span>, <span class="number">2</span>, -<span class="number">1</span>)        <span class="comment">// =&gt; [0,9,8,8,9]; fill with 8 at indexes 2, 3</span></span><br></pre></td></tr></table></figure>
<p>The first argument to fill() is the value to set array elements to. The optional second argument specifies the starting index. If omitted, filling starts at index 0. The optional third argument specifies the ending index—array elements up to, but not including, this index will be filled. If this argument is omitted, then the array is filled from the start index to the end. You can specify indexes relative to the end of the array by passing negative numbers, just as you can for slice().</p>
<blockquote>
<p>fill() 的第一个实参是将数组元素填充的值。可选的第二个实参指定起始索引。如果省略，则填充将从索引 0 开始。可选的第三个实参指定结束索引，将填充到（但不包括）该索引的数组元素。 如果省略此实参，则从起始索引到末尾填充数组。可以通过传递负数来指定相对于数组末尾的索引，就像 slice() 一样。</p>
</blockquote>
<h4 id="COPYWITHIN"><a href="#COPYWITHIN" class="headerlink" title="COPYWITHIN()"></a>COPYWITHIN()</h4><p>copyWithin() copies a slice of an array to a new position within the array. It modifies the array in place and returns the modified array, but it will not change the length of the array. The first argument specifies the destination index to which the first element will be copied. The second argument specifies the index of the first element to be copied. If this second argument is omitted, 0 is used. The third argument specifies the end of the slice of elements to be copied. If omitted, the length of the array is used. Elements from the start index up to, but not including, the end index will be copied. You can specify indexes relative to the end of the array by passing negative numbers, just as you can for slice():</p>
<blockquote>
<p>copyWithin() 将数组的一个片段复制到数组中的新位置。它在适当的位置修改数组并返回修改后的数组，但不会更改数组的长度。第一个实参指定将第一个元素复制到的目标索引。第二个实参指定被复制的第一个元素的索引。如果省略此第二个实参，则使用 0。第三个实参指定被复制的元素片段的结尾。如果省略，则使用数组的长度。从开始索引到结束索引（但不包括结束索引）的元素将被复制。可以通过传递负数来指定相对于数组末尾的索引，就像 slice() 一样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">a.<span class="title function_">copyWithin</span>(<span class="number">1</span>)       <span class="comment">// =&gt; [1,1,2,3,4]: copy array elements up one</span></span><br><span class="line">a.<span class="title function_">copyWithin</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">// =&gt; [1,2,3,4,4]: copy last 2 elements to index 2</span></span><br><span class="line">a.<span class="title function_">copyWithin</span>(<span class="number">0</span>, -<span class="number">2</span>)   <span class="comment">// =&gt; [4,4,3,4,4]: negative offsets work, too</span></span><br></pre></td></tr></table></figure>
<p>copyWithin() is intended as a high-performance method that is particularly useful with typed arrays (see §11.2). It is modeled after the memmove() function from the C standard library. Note that the copy will work correctly even if there is overlap between the source and destination regions.</p>
<blockquote>
<p>copyWithin() 旨在作为一种高性能方法，对类型化数组特别有用（请参见 §11.2）。它模仿的 C 标准库中 memmove() 函数。 请注意，即使源区域和目标区域之间存在重叠，该拷贝也可以正常工作。</p>
</blockquote>
<h3 id="7-8-6-Array-Searching-and-Sorting-Methods"><a href="#7-8-6-Array-Searching-and-Sorting-Methods" class="headerlink" title="7.8.6 Array Searching and Sorting Methods"></a>7.8.6 Array Searching and Sorting Methods</h3><p>Arrays implement indexOf(), lastIndexOf(), and includes() methods that are similar to the same-named methods of strings. There are also sort() and reverse() methods for reordering the elements of an array. These methods are described in the subsections that follow.</p>
<blockquote>
<p>数组实现 indexOf()、lastIndexOf() 和 include() 方法，这些方法类似于名称相同的字符串方法。还有 sort() 和 reverse() 方法，用于对数组元素进行重新排序。这些方法在下面的小节中介绍。</p>
</blockquote>
<h4 id="INDEXOF-AND-LASTINDEXOF"><a href="#INDEXOF-AND-LASTINDEXOF" class="headerlink" title="INDEXOF() AND LASTINDEXOF()"></a>INDEXOF() AND LASTINDEXOF()</h4><p>indexOf() and lastIndexOf() search an array for an element with a specified value and return the index of the first such element found, or -1 if none is found. indexOf() searches the array from beginning to end, and lastIndexOf() searches from end to beginning:</p>
<blockquote>
<p>indexOf() 和 lastIndexOf() 在数组中搜索具有指定值的元素，并返回找到的第一个元素的索引，如果未找到，则返回 -1。indexOf() 从头到尾搜索数组，lastIndexOf() 从尾到头搜索：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>];</span><br><span class="line">a.<span class="title function_">indexOf</span>(<span class="number">1</span>)       <span class="comment">// =&gt; 1: a[1] is 1</span></span><br><span class="line">a.<span class="title function_">lastIndexOf</span>(<span class="number">1</span>)   <span class="comment">// =&gt; 3: a[3] is 1</span></span><br><span class="line">a.<span class="title function_">indexOf</span>(<span class="number">3</span>)       <span class="comment">// =&gt; -1: no element has value 3</span></span><br></pre></td></tr></table></figure>
<p>indexOf() and lastIndexOf() compare their argument to the array elements using the equivalent of the &#x3D;&#x3D;&#x3D; operator. If your array contains objects instead of primitive values, these methods check to see if two references both refer to exactly the same object. If you want to actually look at the content of an object, try using the find() method with your own custom predicate function instead.</p>
<blockquote>
<p>indexOf() 和 lastIndexOf() 使用 &#x3D;&#x3D;&#x3D; 运算符将其实参与数组元素进行比较。如果数组包含对象而不是原始值，则这些方法将检查两个引用是否都指向完全相同的对象。如果要实际查看对象的内容，尝试将 find() 方法代替自定义的断言函数。</p>
</blockquote>
<p>indexOf() and lastIndexOf() take an optional second argument that specifies the array index at which to begin the search. If this argument is omitted, indexOf() starts at the beginning and lastIndexOf() starts at the end. Negative values are allowed for the second argument and are treated as an offset from the end of the array, as they are for the slice() method: a value of –1, for example, specifies the last element of the array.</p>
<blockquote>
<p>indexOf() 和 lastIndexOf() 采用可选的第二个实参，该实参指定开始搜索的数组索引。如果省略此参数，则 indexOf() 从开头开始，lastIndexOf() 从结尾开始。第二个参数允许使用负值，并将其视为距数组末端的偏移量，就像 slice() 方法一样：例如，值 –1 指定数组的最后一个元素。</p>
</blockquote>
<p>The following function searches an array for a specified value and returns an array of all matching indexes. This demonstrates how the second argument to indexOf() can be used to find matches beyond the first.</p>
<blockquote>
<p>以下函数在数组中搜索指定的值，并返回所有匹配索引的数组。这演示了如何使用 indexOf() 的第二个参数来查找第一个参数之外的匹配项。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find all occurrences of a value x in an array a and return an array</span></span><br><span class="line"><span class="comment">// of matching indexes</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findall</span>(<span class="params">a, x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> results = [],            <span class="comment">// The array of indexes we&#x27;ll return</span></span><br><span class="line">        len = a.<span class="property">length</span>,          <span class="comment">// The length of the array to be searched</span></span><br><span class="line">        pos = <span class="number">0</span>;                 <span class="comment">// The position to search from</span></span><br><span class="line">    <span class="keyword">while</span>(pos &lt; len) &#123;           <span class="comment">// While more elements to search...</span></span><br><span class="line">        pos = a.<span class="title function_">indexOf</span>(x, pos); <span class="comment">// Search</span></span><br><span class="line">        <span class="keyword">if</span> (pos === -<span class="number">1</span>) <span class="keyword">break</span>;   <span class="comment">// If nothing found, we&#x27;re done.</span></span><br><span class="line">        results.<span class="title function_">push</span>(pos);       <span class="comment">// Otherwise, store index in array</span></span><br><span class="line">        pos = pos + <span class="number">1</span>;           <span class="comment">// And start next search at next element</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;              <span class="comment">// Return array of indexes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that strings have indexOf() and lastIndexOf() methods that work like these array methods, except that a negative second argument is treated as zero.</p>
<blockquote>
<p>请注意，字符串具有 indexOf() 和 lastIndexOf() 方法，它们与这些数组方法一样工作，不同之处在于第二个实参是负数时被视为零。</p>
</blockquote>
<h4 id="INCLUDES"><a href="#INCLUDES" class="headerlink" title="INCLUDES()"></a>INCLUDES()</h4><p>The ES2016 includes() method takes a single argument and returns true if the array contains that value or false otherwise. It does not tell you the index of the value, only whether it exists. The includes() method is effectively a set membership test for arrays. Note, however, that arrays are not an efficient representation for sets, and if you are working with more than a few elements, you should use a real Set object (§11.1.1).</p>
<blockquote>
<p>ES2016 的 includes() 方法采用单个实参，如果数组包含该值返回 true 否则 false。它不会告诉你值的索引，只告诉你该值是否存在。includes() 方法实际上是数组集的成员身份测试。但是请注意，数组不是 Set 的高效表示形式，如果使用多个元素，则应使用真正的 Set 对象（§11.1.1）。</p>
</blockquote>
<p>The includes() method is slightly different than the indexOf() method in one important way. indexOf() tests equality using the same algorithm that the &#x3D;&#x3D;&#x3D; operator does, and that equality algorithm considers the not-a-number value to be different from every other value, including itself. includes() uses a slightly different version of equality that does consider NaN to be equal to itself. This means that indexOf() will not detect the NaN value in an array, but includes() will:</p>
<blockquote>
<p>includes() 方法在一个重要方面与 indexOf() 方法略有不同。indexOf() 与 &#x3D;&#x3D;&#x3D; 运算符使用相同的算法测试相等性，并且这个相等算法认为非数字值与所有其他值（包括自身）不同。includes() 使用略有不同的相等算法，它认为 NaN 等于自身。这意味着 indexOf() 不会检测数组中的 NaN 值，但 includes() 可以：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="literal">true</span>,<span class="number">3</span>,<span class="title class_">NaN</span>];</span><br><span class="line">a.<span class="title function_">includes</span>(<span class="literal">true</span>)            <span class="comment">// =&gt; true</span></span><br><span class="line">a.<span class="title function_">includes</span>(<span class="number">2</span>)               <span class="comment">// =&gt; false</span></span><br><span class="line">a.<span class="title function_">includes</span>(<span class="title class_">NaN</span>)             <span class="comment">// =&gt; true</span></span><br><span class="line">a.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>)              <span class="comment">// =&gt; -1; indexOf can&#x27;t find NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="SORT"><a href="#SORT" class="headerlink" title="SORT()"></a>SORT()</h4><p>sort() sorts the elements of an array in place and returns the sorted array. When sort() is called with no arguments, it sorts the array elements in alphabetical order (temporarily converting them to strings to perform the comparison, if necessary):</p>
<blockquote>
<p>sort() 对数组的元素直接进行排序，并返回排序后的数组。当调用 sort() 时，它会按字母顺序对数组元素进行排序（如有必要，暂时将它们转换为字符串以执行比较）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;apple&quot;</span>];</span><br><span class="line">a.<span class="title function_">sort</span>(); <span class="comment">// a == [&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;]</span></span><br></pre></td></tr></table></figure>
<p>If an array contains undefined elements, they are sorted to the end of the array.</p>
<blockquote>
<p>如果数组中包含 undefined 元素，它们会被放在数组的结尾。</p>
</blockquote>
<p>To sort an array into some order other than alphabetical, you must pass a comparison function as an argument to sort(). This function decides which of its two arguments should appear first in the sorted array. If the first argument should appear before the second, the comparison function should return a number less than zero. If the first argument should appear after the second in the sorted array, the function should return a number greater than zero. And if the two values are equivalent (i.e., if their order is irrelevant), the comparison function should return 0. So, for example, to sort array elements into numerical rather than alphabetical order, you might do this:</p>
<blockquote>
<p>若要将数组按字母顺序以外的顺序排序，必须将比较函数作为实参传递给 sort()。该函数决定了它的两个实参在排好序的数组中的先后顺序。假设第一个实参应该在前，比较函数应该返回一个小于 0 的数值。反之，假设第一个参数应该在后，函数应该返回一个大于 0 的数值。并且，假设两个值相等（也就是说，它们的顺序无关紧要），函数应该返回 0。例如，用数值大小而非字母表顺序进行数组排序，代码如下：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">33</span>, <span class="number">4</span>, <span class="number">1111</span>, <span class="number">222</span>];</span><br><span class="line">a.<span class="title function_">sort</span>();               <span class="comment">// a == [1111, 222, 33, 4]; alphabetical order</span></span><br><span class="line">a.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>) &#123;  <span class="comment">// Pass a comparator function</span></span><br><span class="line">    <span class="keyword">return</span> a-b;         <span class="comment">// Returns &lt; 0, 0, or &gt; 0, depending on order</span></span><br><span class="line">&#125;);                     <span class="comment">// a == [4, 33, 222, 1111]; numerical order</span></span><br><span class="line">a.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>) =&gt;</span> b-a);   <span class="comment">// a == [1111, 222, 33, 4]; reverse numerical order</span></span><br></pre></td></tr></table></figure>
<p>As another example of sorting array items, you might perform a case-insensitive alphabetical sort on an array of strings by passing a comparison function that converts both of its arguments to lowercase (with the toLowerCase() method) before comparing them:</p>
<blockquote>
<p>另外一个数组元素排序的例子，也许需要对一个字符串数组执行不区分大小写的字母表排序，比较函数首先将实参都转化为小写字符串（使用 toLowerCase() 方法），再开始比较：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;ant&quot;</span>, <span class="string">&quot;Bug&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;Dog&quot;</span>];</span><br><span class="line">a.<span class="title function_">sort</span>();    <span class="comment">// a == [&quot;Bug&quot;,&quot;Dog&quot;,&quot;ant&quot;,&quot;cat&quot;]; case-sensitive sort</span></span><br><span class="line">a.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">s,t</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = s.<span class="title function_">toLowerCase</span>();</span><br><span class="line">    <span class="keyword">let</span> b = t.<span class="title function_">toLowerCase</span>();</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;);   <span class="comment">// a == [&quot;ant&quot;,&quot;Bug&quot;,&quot;cat&quot;,&quot;Dog&quot;]; case-insensitive sort</span></span><br></pre></td></tr></table></figure>
<h4 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE()"></a>REVERSE()</h4><p>The reverse() method reverses the order of the elements of an array and returns the reversed array. It does this in place; in other words, it doesn’t create a new array with the elements rearranged but instead rearranges them in the already existing array:</p>
<blockquote>
<p>reverse() 方法反转数组中元素的顺序并返回反转后的数组。它直接在数组中操作，换一种说法，它不创建一个新的数组，它不创建一个新的带有排序后的元素的数组，而是直接在已存在的数组中进行排序。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">reverse</span>();   <span class="comment">// a == [3,2,1]</span></span><br></pre></td></tr></table></figure>
<h3 id="7-8-7-Array-to-String-Conversions"><a href="#7-8-7-Array-to-String-Conversions" class="headerlink" title="7.8.7 Array to String Conversions"></a>7.8.7 Array to String Conversions</h3><p>The Array class defines three methods that can convert arrays to strings, which is generally something you might do when creating log and error messages. (If you want to save the contents of an array in textual form for later reuse, serialize the array with JSON.stringify() [§6.8] instead of using the methods described here.)</p>
<blockquote>
<p>Array 类定义了三个方法来将数组转化为字符串，通常在创建日志和错误信息时会用到。（如果要以文本形式保存数组的内容供以后重用，请使用 JSON.stringify()（§6.8）序列化数组，而不是使用此处描述的方法。）</p>
</blockquote>
<p>The join() method converts all the elements of an array to strings and concatenates them, returning the resulting string. You can specify an optional string that separates the elements in the resulting string. If no separator string is specified, a comma is used:</p>
<blockquote>
<p>join() 方法将数组的所有元素转换为字符串并连接它们，返回生成的字符串。可以指定一个可选字符串来分隔生成的字符串中的元素。如果未指定分隔符字符串，则使用逗号：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.<span class="title function_">join</span>()               <span class="comment">// =&gt; &quot;1,2,3&quot;</span></span><br><span class="line">a.<span class="title function_">join</span>(<span class="string">&quot; &quot;</span>)            <span class="comment">// =&gt; &quot;1 2 3&quot;</span></span><br><span class="line">a.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)             <span class="comment">// =&gt; &quot;123&quot;</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>); <span class="comment">// An array of length 10 with no elements</span></span><br><span class="line">b.<span class="title function_">join</span>(<span class="string">&quot;-&quot;</span>)            <span class="comment">// =&gt; &quot;---------&quot;: a string of 9 hyphens</span></span><br></pre></td></tr></table></figure>
<p>The join() method is the inverse of the String.split() method, which creates an array by breaking a string into pieces.</p>
<blockquote>
<p>join() 方法是 String.split() 方法的反向方法，该方法通过将字符串拆分为多个片段来创建数组。</p>
</blockquote>
<p>Arrays, like all JavaScript objects, have a toString() method. For an array, this method works just like the join() method with no arguments:</p>
<blockquote>
<p>数组与所有 JavaScript 对象一样，具有 toString() 方法。对于数组，此方法的工作方式与没有参数的 join() 方法相同：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">toString</span>()          <span class="comment">// =&gt; &quot;1,2,3&quot;</span></span><br><span class="line">[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>].<span class="title function_">toString</span>()  <span class="comment">// =&gt; &quot;a,b,c&quot;</span></span><br><span class="line">[<span class="number">1</span>, [<span class="number">2</span>,<span class="string">&quot;c&quot;</span>]].<span class="title function_">toString</span>()     <span class="comment">// =&gt; &quot;1,2,c&quot;</span></span><br></pre></td></tr></table></figure>
<p>Note that the output does not include square brackets or any other sort of delimiter around the array value.</p>
<blockquote>
<p>请注意，输出不包括方括号或数组值周围的任何其他分隔符。</p>
</blockquote>
<p>toLocaleString() is the localized version of toString(). It converts each array element to a string by calling the toLocaleString() method of the element, and then it concatenates the resulting strings using a locale-specific (and implementation-defined) separator string.</p>
<blockquote>
<p>toLocaleString() 是 toString() 的本地化版本。它通过调用元素的 toLocaleString() 方法将每个数组元素转换为字符串，然后使用特定于区域设置（和实现定义）分隔符字符串连接生成的字符串。</p>
</blockquote>
<h3 id="7-8-8-Static-Array-Functions"><a href="#7-8-8-Static-Array-Functions" class="headerlink" title="7.8.8 Static Array Functions"></a>7.8.8 Static Array Functions</h3><p>In addition to the array methods we’ve already documented, the Array class also defines three static functions that you can invoke through the Array constructor rather than on arrays. Array.of() and Array.from() are factory methods for creating new arrays. They were documented in §7.1.4 and §7.1.5.</p>
<blockquote>
<p>除了我们已经记录的数组方法之外，Array 类还定义了三个静态函数，可以通过 Array 构造函数而不是数组调用。Array.of() 和 Array.from() 是用于创建新数组的工厂方法。它们记录在 §7.1.4 和 §7.1.5 中。</p>
</blockquote>
<p>The one other static array function is Array.isArray(), which is useful for determining whether an unknown value is an array or not:</p>
<blockquote>
<p>另外一个静态数组方法是 Array.isArray()，用来判断一个未知值是否是数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>([])     <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;)     <span class="comment">// =&gt; false</span></span><br></pre></td></tr></table></figure>
<h2 id="7-9-Array-Like-Objects"><a href="#7-9-Array-Like-Objects" class="headerlink" title="7.9 Array-Like Objects"></a>7.9 Array-Like Objects</h2><p>As we’ve seen, JavaScript arrays have some special features that other objects do not have:</p>
<blockquote>
<p>我们已经看到，JavaScript 数组的有一些特性是其他对象所没有的：</p>
</blockquote>
<p>The length property is automatically updated as new elements are added to the list.</p>
<blockquote>
<p>当有新的元素添加到列表中时，自动更新 length 属性。</p>
</blockquote>
<p>Setting length to a smaller value truncates the array.</p>
<blockquote>
<p>length 设置为一个较小值将截断数组。</p>
</blockquote>
<p>Arrays inherit useful methods from Array.prototype.</p>
<blockquote>
<p>从 Array.prototype 中继承一些有用的方法。</p>
</blockquote>
<p>Array.isArray() returns true for arrays.</p>
<blockquote>
<p>数组传入 Array.isArray() 方法返回 true。</p>
</blockquote>
<p>These are the features that make JavaScript arrays distinct from regular objects. But they are not the essential features that define an array. It is often perfectly reasonable to treat any object with a numeric length property and corresponding non-negative integer properties as a kind of array.</p>
<blockquote>
<p>这些特性让 JavaScript 数组和常规的对象有明显的区别。但是它们不是定义数组的本质特性。一种常常完全合理的看法是把拥有一个数值型 length 属性和对应非负整数属性的对象看作数组的同类。</p>
</blockquote>
<p>These “array-like” objects actually do occasionally appear in practice, and although you cannot directly invoke array methods on them or expect special behavior from the length property, you can still iterate through them with the same code you’d use for a true array. It turns out that many array algorithms work just as well with array-like objects as they do with real arrays. This is especially true if your algorithms treat the array as read-only or if they at least leave the array length unchanged.</p>
<blockquote>
<p>实际上这些“类数组”对象在实践中偶尔出现，虽然不能通过它们直接调用数组方法或者期望 length 属性有什么特殊的行为，但是仍然可以用针对真正数组遍历代码来遍历它们。结论就是很多数组算法针对类数组对象同样奏效，就像针对真正的数组一样。尤其是这种情况，算法把数组看成只读的或者如果保持数组长度不变。</p>
</blockquote>
<p>The following code takes a regular object, adds properties to make it an array-like object, and then iterates through the “elements” of the resulting pseudo-array:</p>
<blockquote>
<p>以下代码为一个常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;  <span class="comment">// Start with a regular empty object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add properties to make it &quot;array-like&quot;</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">a.<span class="property">length</span> = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now iterate through it as if it were a real array</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; a.<span class="property">length</span>; j++) &#123;</span><br><span class="line">    total += a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In client-side JavaScript, a number of methods for working with HTML documents (such as document.querySelectorAll(), for example) return array-like objects. Here’s a function you might use to test for objects that work like arrays:</p>
<blockquote>
<p>在客户端 JavaScript 中，很多作用于 HTML documents 的方法（例如 document.querySelectorAll()）返回类数组对象。下面这个函数可能会用于测试对象是否可以用作类数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Determine if o is an array-like object.</span></span><br><span class="line"><span class="comment">// Strings and functions have numeric length properties, but are</span></span><br><span class="line"><span class="comment">// excluded by the typeof test. In client-side JavaScript, DOM text</span></span><br><span class="line"><span class="comment">// nodes have a numeric length property, and may need to be excluded</span></span><br><span class="line"><span class="comment">// with an additional o.nodeType !== 3 test.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isArrayLike</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                            <span class="comment">// o is not null, undefined, etc.</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">&quot;object&quot;</span> &amp;&amp;        <span class="comment">// o is an object</span></span><br><span class="line">        <span class="title class_">Number</span>.<span class="built_in">isFinite</span>(o.<span class="property">length</span>) &amp;&amp;    <span class="comment">// o.length is a finite number</span></span><br><span class="line">        o.<span class="property">length</span> &gt;= <span class="number">0</span> &amp;&amp;                <span class="comment">// o.length is non-negative</span></span><br><span class="line">        <span class="title class_">Number</span>.<span class="title function_">isInteger</span>(o.<span class="property">length</span>) &amp;&amp;   <span class="comment">// o.length is an integer</span></span><br><span class="line">        o.<span class="property">length</span> &lt; <span class="number">4294967295</span>) &#123;        <span class="comment">// o.length &lt; 2^32 - 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                    <span class="comment">// Then o is array-like.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                   <span class="comment">// Otherwise it is not.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ll see in a later section that strings behave like arrays. Nevertheless, tests like this one for array-like objects typically return false for strings—they are usually best handled as strings, not as arrays.</p>
<blockquote>
<p>我们会在下一节看到字符串的行为像数组一样。尽管如此，对于数组这种测试（对字符串通常返回 false ）它们通常最好作为字符串处理，而不是作为数组处理。</p>
</blockquote>
<p>Most JavaScript array methods are purposely defined to be generic so that they work correctly when applied to array-like objects in addition to true arrays. Since array-like objects do not inherit from Array.prototype, you cannot invoke array methods on them directly. You can invoke them indirectly using the Function.call method, however (see §8.7.4 for details):</p>
<blockquote>
<p>大多数 JavaScript 数组方法都特意定义为泛型，以便它们在应用于除数组之外的类数组可以正常工作。由于类数组对象不会从 Array.prototype 继承，因此不能直接在它们上调用数组方法。但是，可以使用 Function.call 方法间接调用它们（详情请参阅 §8.7.4）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="string">&quot;0&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;1&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;2&quot;</span>: <span class="string">&quot;c&quot;</span>, <span class="attr">length</span>: <span class="number">3</span>&#125;; <span class="comment">// An array-like object</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(a, <span class="string">&quot;+&quot;</span>)                  <span class="comment">// =&gt; &quot;a+b+c&quot;</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>.<span class="title function_">call</span>(a, <span class="function"><span class="params">x</span> =&gt;</span> x.<span class="title function_">toUpperCase</span>())  <span class="comment">// =&gt; [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(a, <span class="number">0</span>)   <span class="comment">// =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]: true array copy</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(a)                      <span class="comment">// =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]: easier array copy</span></span><br></pre></td></tr></table></figure>
<p>The second-to-last line of this code invokes the Array slice() method on an array-like object in order to copy the elements of that object into a true array object. This is an idiomatic trick that exists in much legacy code, but is now much easier to do with Array.from().</p>
<blockquote>
<p>此代码倒数第二行调用数组类对象上的 Array slice() 方法，以便将该对象的元素复制到真正的数组对象中。这是一个惯用的技巧，存在于许多旧代码中，但现在使用 Array.from() 要容易得多。</p>
</blockquote>
<h2 id="7-10-Strings-as-Arrays"><a href="#7-10-Strings-as-Arrays" class="headerlink" title="7.10 Strings as Arrays"></a>7.10 Strings as Arrays</h2><p>JavaScript strings behave like read-only arrays of UTF-16 Unicode characters. Instead of accessing individual characters with the charAt() method, you can use square brackets:</p>
<blockquote>
<p>JavaScript 字符串的行为类似于 UTF-16 Unicode 字符的只读数组。可以使用方括号替代 charAt() 方法访问单个字符：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">s.<span class="title function_">charAt</span>(<span class="number">0</span>)    <span class="comment">// =&gt; &quot;t&quot;</span></span><br><span class="line">s[<span class="number">1</span>]           <span class="comment">// =&gt; &quot;e&quot;</span></span><br></pre></td></tr></table></figure>
<p>The typeof operator still returns “string” for strings, of course, and the Array.isArray() method returns false if you pass it a string.</p>
<blockquote>
<p>当然，字符串使用 typeof 运算符仍然返回 “string”，如果将字符串传递给 Array.isArray() 方法，则返回 false。</p>
</blockquote>
<p>The primary benefit of indexable strings is simply that we can replace calls to charAt() with square brackets, which are more concise and readable, and potentially more efficient. The fact that strings behave like arrays also means, however, that we can apply generic array methods to them. For example:</p>
<blockquote>
<p>可索引字符串的主要好处是，我们可以用方括号替换对 charAt() 的调用，方括号更简洁、更可读，而且可能更高效。但是，字符串的行为类似于数组，也意味着我们可以对它们应用泛型数组方法。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span>.<span class="title function_">call</span>(<span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot; &quot;</span>)  <span class="comment">// =&gt; &quot;J a v a S c r i p t&quot;</span></span><br></pre></td></tr></table></figure>
<p>Keep in mind that strings are immutable values, so when they are treated as arrays, they are read-only arrays. Array methods like push(), sort(), reverse(), and splice() modify an array in place and do not work on strings. Attempting to modify a string using an array method does not, however, cause an error: it simply fails silently.</p>
<blockquote>
<p>请记住，字符串是不可变值，因此当字符串被视为数组时，它们是只读数组。数组方法 push()、sort()、reverse() 和 splice() 直接修改数组，它们不能处理字符串。但是，尝试使用数组方法修改字符串不会引发异常：它只是静默失败。</p>
</blockquote>
<h2 id="7-11-Summary"><a href="#7-11-Summary" class="headerlink" title="7.11 Summary"></a>7.11 Summary</h2><p>This chapter has covered JavaScript arrays in depth, including esoteric details about sparse arrays and array-like objects. The main points to take from this chapter are:</p>
<blockquote>
<p>本章深入介绍了 JavaScript 数组，包括有关稀疏数组和类数组对象的深奥细节。本章要点包括：</p>
</blockquote>
<p>Array literals are written as comma-separated lists of values within square brackets.</p>
<blockquote>
<p>数组字面量编写：方括号内逗号分隔值列表。</p>
</blockquote>
<p>Individual array elements are accessed by specifying the desired array index within square brackets.</p>
<blockquote>
<p>通过在方括号内指定所需的数组索引来访问单个数组元素。</p>
</blockquote>
<p>The for&#x2F;of loop and … spread operator introduced in ES6 are particularly useful ways to iterate arrays.</p>
<blockquote>
<p>for&#x2F;of 循环和 ES6 中引入的 … 展开运算符是遍历数组的特别有用的方法。</p>
</blockquote>
<p>The Array class defines a rich set of methods for manipulating arrays, and you should be sure to familiarize yourself with the Array API.</p>
<blockquote>
<p>Array 类定义了一组用于操作数组的丰富方法，应该确保熟悉 Array API。</p>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Jack hou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/')">第7章 数组</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wechat/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=第7章 数组&amp;url=http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/&amp;pic=https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.houyanbin.com" target="_blank">Jackhou Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>《JavaScript权威指南》<span class="tagsPageCount">17</span></a><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">17</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第8章 函数</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch6/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第6章 对象</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch1/" title="第1章 JavaScript 概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第1章 JavaScript 概述</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch12/" title="第12章 迭代器和生成器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第12章 迭代器和生成器</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch10/" title="第10章 模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第10章 模块</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch11/" title="第11章 JavaScript 标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第11章 JavaScript 标准库</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch14/" title="第14章 元编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第14章 元编程</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch17/" title="第17章 JavaScript 工具和扩展"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第17章 JavaScript 工具和扩展</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">Hi，这是我的博客网站，欢迎你能到访~</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">我会在这里分享我的<b style="color:#fff">技术知识</b>、<b style="color:#fff">日常生活</b>和<b style="color:#fff">人生经验。</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Jack hou</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/YingxueSec" target="_blank" title="Github"><i class="fab fa-github faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/478589474" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=jackhou921@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wxgzh1.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Creating-Arrays"><span class="toc-text">7.1 Creating Arrays</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-Array-Literals"><span class="toc-text">7.1.1 Array Literals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-The-Spread-Operator"><span class="toc-text">7.1.2 The Spread Operator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-The-Array-Constructor"><span class="toc-text">7.1.3 The Array() Constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-Array-of"><span class="toc-text">7.1.4 Array.of()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-5-Array-from"><span class="toc-text">7.1.5 Array.from()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Reading-and-Writing-Array-Elements"><span class="toc-text">7.2 Reading and Writing Array Elements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Sparse-Arrays"><span class="toc-text">7.3 Sparse Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Array-Length"><span class="toc-text">7.4 Array Length</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Adding-and-Deleting-Array-Elements"><span class="toc-text">7.5 Adding and Deleting Array Elements</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Iterating-Arrays"><span class="toc-text">7.6 Iterating Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7-Multidimensional-Arrays"><span class="toc-text">7.7 Multidimensional Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8-Array-Methods"><span class="toc-text">7.8 Array Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-1-Array-Iterator-Methods"><span class="toc-text">7.8.1 Array Iterator Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FOREACH"><span class="toc-text">FOREACH()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MAP"><span class="toc-text">MAP()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FILTER"><span class="toc-text">FILTER()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIND-AND-FINDINDEX"><span class="toc-text">FIND() AND FINDINDEX()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EVERY-AND-SOME"><span class="toc-text">EVERY() AND SOME()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REDUCE-AND-REDUCERIGHT"><span class="toc-text">REDUCE() AND REDUCERIGHT()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-2-Flattening-arrays-with-flat-and-flatMap"><span class="toc-text">7.8.2 Flattening arrays with flat() and flatMap()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-3-Adding-arrays-with-concat"><span class="toc-text">7.8.3 Adding arrays with concat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-4-Stacks-and-Queues-with-push-pop-shift-and-unshift"><span class="toc-text">7.8.4 Stacks and Queues with push(), pop(), shift(), and unshift()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-5-Subarrays-with-slice-splice-fill-and-copyWithin"><span class="toc-text">7.8.5 Subarrays with slice(), splice(), fill(), and copyWithin()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SLICE"><span class="toc-text">SLICE()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPLICE"><span class="toc-text">SPLICE()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FILL"><span class="toc-text">FILL()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#COPYWITHIN"><span class="toc-text">COPYWITHIN()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-6-Array-Searching-and-Sorting-Methods"><span class="toc-text">7.8.6 Array Searching and Sorting Methods</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#INDEXOF-AND-LASTINDEXOF"><span class="toc-text">INDEXOF() AND LASTINDEXOF()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INCLUDES"><span class="toc-text">INCLUDES()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SORT"><span class="toc-text">SORT()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#REVERSE"><span class="toc-text">REVERSE()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-7-Array-to-String-Conversions"><span class="toc-text">7.8.7 Array to String Conversions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-8-8-Static-Array-Functions"><span class="toc-text">7.8.8 Static Array Functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9-Array-Like-Objects"><span class="toc-text">7.9 Array-Like Objects</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10-Strings-as-Arrays"><span class="toc-text">7.10 Strings as Arrays</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-11-Summary"><span class="toc-text">7.11 Summary</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="做情人真的没有好下场吗？"/></a><div class="content"><a class="title" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？">做情人真的没有好下场吗？</a><time datetime="2023-08-14T16:00:00.000Z" title="发表于 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不爱前行"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行">不爱前行</a><time datetime="2023-07-29T16:00:00.000Z" title="发表于 2023-07-30 00:00:00">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="租房时光"/></a><div class="content"><a class="title" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光">租房时光</a><time datetime="2023-07-21T16:00:00.000Z" title="发表于 2023-07-22 00:00:00">2023-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="故宫记"/></a><div class="content"><a class="title" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记">故宫记</a><time datetime="2023-06-10T16:00:00.000Z" title="发表于 2023-06-11 00:00:00">2023-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息收集道道之外网信息收集"/></a><div class="content"><a class="title" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集">信息收集道道之外网信息收集</a><time datetime="2023-05-28T16:00:00.000Z" title="发表于 2023-05-29 00:00:00">2023-05-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 By <a class="footer-bar-link" href="/" title="Jack hou" target="_blank">Jack hou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 0.88rem; color: rgb(183, 5, 106);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem; color: rgb(61, 106, 155);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem; color: rgb(13, 4, 97);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem; color: rgb(163, 188, 186);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; color: rgb(79, 71, 173);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem; color: rgb(3, 180, 192);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 0.88rem; color: rgb(9, 76, 83);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem; color: rgb(3, 1, 125);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 0.88rem; color: rgb(108, 84, 120);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem; color: rgb(108, 97, 131);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 0.88rem; color: rgb(17, 29, 29);">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 0.88rem; color: rgb(194, 57, 41);">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem; color: rgb(8, 158, 41);">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem; color: rgb(200, 110, 13);">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 0.88rem; color: rgb(143, 75, 114);">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 0.88rem; color: rgb(191, 22, 92);">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 0.88rem; color: rgb(146, 53, 23);">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem; color: rgb(72, 26, 78);">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 0.88rem; color: rgb(140, 54, 195);">越权<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8868465080" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8868465080&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("4/15/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Jack hou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("4/15/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.houyanbin.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>