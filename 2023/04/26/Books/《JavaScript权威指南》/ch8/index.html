<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>第8章 函数 | Jackhou Blog</title><meta name="keywords" content="《JavaScript权威指南》,JavaScript"><meta name="author" content="Jack hou"><meta name="copyright" content="Jack hou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="第8章 函数"><meta name="application-name" content="第8章 函数"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="第8章 函数"><meta property="og:url" content="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/index.html"><meta property="og:site_name" content="Jackhou Blog"><meta property="og:description" content="This chapter covers JavaScript functions. Functions are a fundamental building block for JavaScript programs and a common feature in almost all pro"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg"><meta property="article:author" content="Jack hou"><meta property="article:tag" content="Jackhou, blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg"><meta name="description" content="This chapter covers JavaScript functions. Functions are a fundamental building block for JavaScript programs and a common feature in almost all pro"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.houyanbin.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Jack hou","link":"链接: ","source":"来源: Jackhou Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Jackhou Blog',
  title: '第8章 函数',
  postAI: '',
  pageFillDescription: '8.1 Defining Functions, 8.1.1 Function Declarations, 8.1.2 Function Expressions, 8.1.3 Arrow Functions, 8.1.4 Nested Functions, 8.2 Invoking Functions, 8.2.1 Function Invocation, CONDITIONAL INVOCATION, RECURSIVE FUNCTIONS AND THE STACK, 8.2.2 Method Invocation, METHOD CHAINING, 8.2.3 Constructor Invocation, 8.2.4 Indirect Invocation, 8.2.5 Implicit Function Invocation, 8.3 Function Arguments and Parameters, 8.3.1 Optional Parameters and Defaults, 8.3.2 Rest Parameters and Variable-Length Argument Lists, 8.3.3 The Arguments Object, 8.3.4 The Spread Operator for Function Calls, 8.3.5 Destructuring Function Arguments into Parameters, 8.3.6 Argument Types, 8.4 Functions as Values, 8.4.1 Defining Your Own Function Properties, 8.5 Functions as Namespaces, 8.6 Closures, 8.7 Function Properties Methods and Constructor, 8.7.1 The length Property, 8.7.2 The name Property, 8.7.3 The prototype Property, 8.7.4 The call() and apply() Methods, 8.7.5 The bind() Method, 8.7.6 The toString() Method, 8.7.7 The Function() Constructor, 8.8 Functional Programming, 8.8.1 Processing Arrays with Functions, 8.8.2 Higher-Order Functions, 8.8.3 Partial Application of Functions, 8.8.4 Memoization, 8.9 Summary本章介绍了函数函数是程序的基本构建块也是几乎所有编程语言的共同特性你可能已经了解函数的概念如子例程或过程函数是一个代码块只定义一次但可以执行或调用任意次数函数是参数化的一个函数定义可以包含一个标识符列表称为参数作为函数体的局部变量函数调用为函数的参数提供值或实参函数通常使用它们的实参值来计算一个返回值该返回值成为函数调用表达式的值除了参数之外每次调用都有另一个值调用上下文即关键字的值如果函数挂载在一个对象上作为其属性它就被称为方法当该方法在对象中被调用或通过对象调用时该对象就是该方法函数的调用上下文或值用于初始化新创建的对象的函数称为构造函数构造函数在中有介绍我们将在第章中再次谈到它在中函数是对象它们可以被程序操作例如可以将函数赋给变量并将它们传递给其他函数由于函数是对象所以您可以给它们设置属性甚至调用它们的方法函数可以嵌套在其他函数中定义并且它们可以访问定义它们所处的作用域内任何变量这意味着函数是闭包支持闭包是非常重要的它是非常强大的编程技巧定义函数最直接的方法是使用关键字它既可以用作声明又可以用作表达式定义了一种不使用关键字的重要新方法来定义的函数箭头函数它具有特别简洁语法并且在将一个函数作为参数传递给另一个函数的场景中非常实用接下来的小节将介绍这三种定义函数的方法注意关于函数定义语法包含的函数参数相关内容将在中介绍在对象字面量和类定义中有一种方便的快捷语法来定义方法这种简写语法在中有介绍相当于通过对象字面量语法将函数定义表达式用最基本的属性名属性值的方式赋值给对象的属性在另一种特殊情况下可以在对象字面量中使用关键字和来定义特殊的属性和方法这个函数定义语法在中介绍过注意函数也可以用构造函数来定义这是的主题此外还定义了一些特殊类型的函数定义函数生成器见第章和定义异步函数见第章函数声明由关键字组成后面跟着这些组件函数名称标识符名称是函数声明的必要部分它用作变量的名称并将新定义的函数对象赋值给该变量一对圆括号其中包含由个或者多个用逗号分隔的标识符组成的列表这些标识符是函数的参数名它们的行为类似于函数体中的局部变量一对花括号其中包含由条或者多条语句这些语句构成了函数体每当函数调用时就会执行这些语句下面是一些函数声明的例子重中之重要理解函数声明是函数名变成一个变量这个变量的值是函数本身函数声明语句被提前到脚本函数块之前因此这种方式定义的函数可以在它定义之前被调用另一种说法是所有声明在代码块中的函数在块内始终是有定义的它们定义在解释器开始解释执行块内任何语句之前和函数计算一个值它们用来将这个值返回给调用者语句导致函数停止执行并返回它的表达式的值如果有的话给调用者如果语句没有一个与之相关的表达式则函数返回值函数不同它负责输出对象属性的名称和值没有返回值的必要并且该函数也不包含一个语句调用函数的返回值永远是如果一个函数不包含一个语句它仅仅执行函数体内每一条语句直到结束并返回给调用者在之前函数只允许在文件顶层或者其他函数中声明然而一些实现违反规约在循环体条件体或者其他块中定义函数在的严格模式下函数允许在块内进行声明一个定义在块内的函数只存在于该块内块外是不可见的函数表达式看起来很像函数声明但是它出现在一个它的上层表达式或语句的上下文中并且函数名称是可选项下面是一些函数表达式的例子注意函数名称在函数表达式中是可选项在大部分函数表达式中我们省略了它函数声明实际上声明了一个变量并且将函数对象赋值给它按照这个角度来看函数表达式没有声明一个变量可以根据它是否会多次调用由你自己决定是将新定义的函数对象赋值给一个常量还是变量用定义函数表达式是一个非常好的做法你不会因为意外赋值而重写了你的函数可以给函数一个名称就像函数它需要调用它自己如果一个函数表达式包含一个名称那这个函数的局部函数作用域内会包含一个属性名为该函数名的对象其值绑定的是该函数实际上函数名变成这个函数的一个局部变量大多数函数表达式不需要函数名称这让它们的定义更简洁但是并没有下面要讲的箭头函数简洁在函数声明和函数表达式之间有一个非常重要的不同当你用函数声明该函数对象创建于该函数所在作用域的代码开始执行之前也就是声明提前所以你可以在函数定义之前调用他们如果用函数表达式来定义一个函数这样使用就是不对的该函数不会存在直到函数定义表达式真正被计算因为想要执行一个函数你必须可以引用它而一个函数表达式定义的函数一直到该函数赋值给一个变量后才能被引用所以要使用函数表达式需要在函数被调用之前定义在之后你可以用一个特别简洁的语法来定义函数被称为箭头函数这个语法联想到数学符号用一个箭头来分隔函数的参数和函数体关键字未使用并且由于箭头函数是表达式而不是声明语句也不需要一个函数名称一般箭头函数用圆括号包含一个逗号分隔的参数列表接一个箭头后面是花括号包含的函数体但是箭头函数支持更加简洁的语法如果函数体只有一个简单的语句你可以省略关键字分号和花括号都一起省略将函数体写成一个计算返回值的表达式而且如果一个箭头函数只有一个参数你可以省略参数列表的圆括号注意如果箭头函数没有参数必须写一对空圆括号注意当写一个箭头函数时函数参数和箭头之间不能换行否则可能会直接在赋值后中止就像因为它本身是一个语法上合法的赋值语句此外如果箭头函数体是一个单一的语句而且他返回的是一个对象字面量那必须将对象字面量用圆括号包起来避免将对象字面量的大括号误解成函数体的大括号这段代码的第三行函数就有歧义这段代码原本返回对象字面量被转化为一个标签语句所以一个返回的函数被创建第四行结构更复杂的对象字面量不是一个合法的语句这段代码会抛出一个语法异常简洁的箭头函数可以完美的传递一个函数给另外一个函数比如一些数组的常规操作方法和见例如箭头函数不同于用关键字定义的函数箭头函数从定义它们的环境继承关键字而不是像其他定义方式那样定义自己的调用上下文这是箭头函数一个重要且特别实用的特性我们会在这一章的后面再次提到它箭头函数也不同于其他函数它们没有有原型属性这意味着它不能被当作一个构造函数去创建一个类见在中函数可以嵌套在其他函数内例如嵌套函数的有趣之处在于它的变量作用域规则它们可以访问嵌套它们或多重嵌套的函数的参数和变量例如在上面的代码里内部函数可以读写外部函数定义的参数和这些作用域规则对嵌套函数非常重要我们会在再深入了解它们构成函数主体的代码在定义之时并不会执行只有调用该函数时它们才会执行函数可以以五种方式被调用作为函数作为方法作为构造函数通过它们的和方法间接调用隐式调用不同于普通函数调通过语言特性调用函数函数或方法通过调用表达式被调用调用表达式由以下部分组成计算函数对象的函数表达式一个开放圆括号逗号分隔的零个或多个实参表达式列表一个闭合圆括号如果函数表达式是属性访问表达式函数是一个对象的属性或者一个数组的元素那么它是一个方法调用表达式这种情况会通过下面的例子说明接下来这个代码包含了一些常规的函数调用表达式在调用中每个实参表达式圆括号内的执行计算返回值作为函数的实参这些值传给函数定义的参数在函数体内参数的引用指向对应实参的值对于常规的函数调用函数返回值变成函数调用表达式的值如果因解释器执行到函数结尾而返回返回值就是如果函数返回是因为解释器执行一个语句那么返回值是后面的表达式的计算结果如果语句没有值也返回在中你可以通过在函数表达式和圆括号之间插入符号使函数只有在不为和时候再调用表达式等价假设没有副作用于详细的条件执行语法描述在函数调用在非严格模式下调用上下文是全局对象然而在严格模式下调用上下文是注意箭头语法定义的函数行为是不同的实际上它们总是继承它们定义位置的值以函数形式调用的函数通常不使用关键字不过关键字可以用来判断当前是否是严格模式递归函数就像本章开始的函数它调用它自己某些算法如涉及基于树的数据结构可以使用递归函数特别优雅地实现在写递归函数时考虑内存分配是很重要的当函数调用函数然后函数又调用函数时编译器需要知道在哪里重新执行函数当函数执行完成后它需要知道在哪里执行函数你可以将执行上下文想象成一个栈当一个函数调用另外一个函数时一个新的执行上下文被压入栈中当被调用函数返回它的执行上下文对象从栈中弹出如果一个函数递归调用次那么会有个对象被压入栈中然后这个对象再依次从栈中弹出这种调用非常耗内存以现代的硬件递归调用次通常没什么问题但是如果一个函数递归上千次它可能会失败并报错方法只不过是对象属性函数如果有一个函数和一个对象可以用下面的代码给对象定义一个名为的方法给对象定义了方法用这种方式调用它或者需要两个实参可以这样调用它示例中的代码是一个调用表达式它包含一个函数表达式和两个实参表达式和函数表达式本身是一个属性访问表达式这意味着该函数被当作一个方法调用而不是一个普通的函数对方法调用的参数和返回值的处理和上面所描述的普通函数调用完全一致但是方法调用和函数调用有一个重要的区别即调用上下文属性访问表达式由两部分组成一个对象本例中的和属性名称在像这样的方法调用表达式里对象成为调用上下文函数体可以使用关键字引用该对象下面是一个具体的例子大多数方法调用使用点符号来访问属性使用方括号属性访问表达式也可以进行属性访问操作下面两个例子都是函数调用方法调用可能包括更复杂的属性访问表达式方法和关键字是面向对象编程范式的核心任何函数只要作为方法调用实际上都会传入一个隐式的实参对象就是调用这个方法对象本身通常来讲方法执行就是对象的某种操作方法调用的语法也清晰的表达了它是操作对象的函数比较下面两行代码我们假设这两行代码的功能完全一样它们都作用于一个假定的对象可以看出第一行的方法调用语法非常清晰地表明这个函数执行的载体是对象函数中的所有操作都将基于这个对象当方法返回一个对象这个对象还可以再调用它的方法这种方法调用序列中或链每次的调用结果都是另外一个表达式的组成部分比如基于的异步操作参见第章我们常常会这样写代码当方法并不需要返回值时最好直接返回如果在设计的中一直采用这种方式使用就可以用方法链风格的编程在这种编程风格中只要指定一次要调用的对象即可余下的方法都可以基于此进行调用需要注意的是是一个关键字不是变量也不是属性名的语法不允许给赋值关键字没有变量作用域的限制除了箭头函数嵌套函数不会从包含它的函数中继承如果嵌套函数作为方法调用其的值指向调用它的对象如果嵌套的函数作为函数调用不包含箭头函数其值不是全局对象非严格模式下就是严格模式下很多人误以为在一个方法中的函数声明并以函数调用的方式去执行可以用来获取方法的执行上下文下面这个例子说明了这个问题嵌套函数中关键之不等于对象这被广泛的认为是的一个缺陷了解这一点是很是很重要的上面的代码演示了一种常用的解决方案在方法中将值赋值给一个变量在签到函数中可以用代替来引用包含它的对象在之后有另外一种解决方案来解决这个问题将嵌套函数转换成箭头函数它会正确的继承值函数表达式不像函数声明声明提前所以为了让这种解决方案定义的函数可以被调用需要将函数定义表达式放在方法中这样它才可以在它被调用时存在另外还可以用嵌套函数的方法在指定对象上隐式调用一个新的函数关于方法将在中讲解如果函数或者方法调用之前带有关键字它就构成构造函数调用构造函数调用在和节有简单介绍第章会对构造函数做更详细的讨论构造函数调用和普通的函数调用以及方法调用在实参处理调用上下文和返回值方面都有不同如果构造函数调用在圆括号内包含一组实参列表先计算这些实参表达式然后传入函数内这和函数调用和方法调用是一致的但如果构造函数没有形参构造函数调用的语法是允许省略实参列表和圆括号的凡是没有形参的构造函数调用都可以省略圆括号比如下面这两行代码就是等价的构造函数调用创建一个新的空对象这个对象继承自构造函数的属性构造函数试图初始化这个新创建的对象并将这个对象用做其调用上下文因此构造函数内可以使用关键字来引用这个新创建的对象注意尽管构造函数看起来像一个方法调用它依然会使用这个新对象作为调用上下文也就是说在表达式中调用上下文并不是构造函数通常不使用关键字它们通常初始化新对象当构造函数的函数体执行完毕时它会隐式返回在这种情况下构造函数调用表达式的计算结果就是这个新对象的值然而如果构造函数显式地使用语句返回一个对象那么调用表达式的值就是这个对象如果构造函数使用语句但没有指定返回值或者返回一个原始值那么这时将忽略返回值同时使用这个新对象作为调用结果中的函数也是对象和其他对象没什么两样函数对象也可以包含方法其中的两个方法和可以用来间接地调用函数两个方法都允许显式指定调用所需的值也就是说任何函数可以作为任何对象的方法来调用哪怕这个函数不是那个对象的方法两个方法都可以指定调用的实参方法使用它自有的实参列表作为函数的实参方法则要求以数组的形式传入实参节会有关于和方法的详细讨论有各种各样的语言特性它们看起来不像函数调用但是却能调用函数额外小心编写函数时可能会隐式调用因为在隐式函数调用中副作用和性能问题都比普通的函数更难诊断和修复可能引起函数隐式调用的语言特性包括如果一个对象定义了或者方法获取或者设置它的属性值可能调用这些方法见有更多相关描述当对象用作一个字符串文本时例如对象和一个字符串连接它的方法会被调用同样的对象用作一个数值型文本时它的方法被调用详见当循环可迭代对象的元素时会产生很多方法调用第章介绍了迭代器在函数调用级别如何工作并演示如何编写方法来定义自己的可迭代类型可以伪装在模板字面量中在中演示如何在模板字符串中调用函数对象在中描述的行为完全由函数控制它的任何一个操作都会导致函数调用中的函数定义并未指定函数形参的类型函数调用也未对传入的实参值做任何类型检查实际上函数调用甚至不检查传入形参的个数下面几节将会讨论当调用函数时的实参个数和声明的形参个数不匹配时出现的状况同样介绍了如何显式测试函数实参的类型以避免非法的实参传入函数当调用函数的时候传入的实参比函数声明时指定的形参个数要少剩下的形参都将设置为值所以一些参数设置成可选的是非常实用的看下面这个例子第一行代码中可以使用运算符来代替一个语句这是一种习惯用法回忆一下介绍了运算符如果第一个实参是真值的话就返回第一个实参否则返回第二个实参在这个场景下如果作为第二个实参传入任意对象那么函数就会使用这个对象如果省略掉第二个实参或者传递以及其他任何假值那么就新创建一个空数组并赋值给需要注意的是当用这种可选实参来实现函数时需要将可选实参放在实参列表的最后那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参他们必须显地的将传入作为第一个实参在之后可以直接在函数的参数列表中为每个函数参数定义默认值直接在参数名后面接一个等号再接一个默认值用于没有实参提供给参数时参数的值默认参数表达式只有在函数调用时进行计算而不是在它定义时所以每一次函数只传一个实参调用时一个新的空数组被创建并传给参数最容易理解的就是参数默认值是常量或者字面量表达式和但这并不是必须的举个例子你可以用变量或者函数调用计算一个默认参数的值一个很有趣的情况是对于有多个参数的函数可以用前面的参数值来定义后面的参数默认值这段代码描述了箭头函数中的参数默认值方法函数和其他形式的函数定义也是如此调用函数时允许传入的实参比函数声明时指定的形参个数少剩余参数允许相反的情况它允许我们在调用函数时传入比型参多任意个数的实参下面是一个可以传入一个或多个数值型实参的例子并且返回其中最大的数剩余参数由三个开始必须是函数声明的最后一个参数调用有剩余参数的函数时传递的实参先赋值给非剩余参数然后其余所有的实参也就是剩余实参存储在一个数组中变成剩余参数的值最后一点非常重要在一个函数体中剩余参数的值总是一个数组这个数组可能是空的但是剩余参数永远不会是因此从不会给剩余参数设置默认值并且这也是不合法的类似这种函数可以接收任意个数的实参这种函数也称为不定实参函数这个术语源自古老的语言不要混淆定义函数的剩余参数和展开运算符将在描述展开运算符在函数调用中的应用剩余参数是在中加入的概念在这之前不定实参函数是用对象实现的在函数体中标识符是指向实参对象的引用对象是一个类数组对象参照这样可以通过数字下标就能访问传入函数的实参值而不用非要通过名字来得到实参下面的函数就是以前用对象代替剩余参数的例子对象可追溯到的最早时代并带有一些奇怪的历史包袱这使得它效率低下且难以优化尤其是不在严格模式下可能还会遇到一些代码使用对象但是在编写新代码时要避免使用可以用剩余函数来替代对象还有部分令人遗憾的遗产在严格模式下被视为保留字不能声明具有该名称的局部变量来定义函数的参数当需要单个值时展开运算符用来拆包或者说将元素从数组或者其他的任何和迭代对象例如字符串中展开到上下文我们已经在见到了展开运算符在数组字面量上的使用展开运算符可以在函数调用中以同样方式使用注意不是一个真正的运算符因为它不能通过计算来提供一个值它是一个可以用在数组字面量和函数调用中的特殊的语法在函数定义和函数调用中使用相同的语法时和展开运算符有着相仿的效果在中我们看到函数定义使用将复数个函数实参合并到一个数组中剩余参数和展开运算符经常一同使用就像下面这个函数用实参列表调用函数时实参的值最终赋值给函数定义的参数函数调用初始化阶段非常像变量赋值所以我们不必惊讶于可以将解构赋值见用于函数如果一个函数的参数带有方括号就说明函数要给每一个方括号传一个数组在一个调用进程中数组实参会被拆包传递给对应的参数例如假设我们将矢量表示为两个数字的数组其中第一个元素是坐标第二个元素是坐标用这个简单的数据结构编写下面这个函数计算两个矢量的和如果下面这种方式解构这两个矢量实参这段代码将更容易理解同样如果定义一个函数时需要对象实参你能对这个对象进行参数解构再次实用矢量的例子这一次我们用和参数包装成对象来描述矢量这个例子将一个简单的对象实参解构成两个参数是很简单的因为参数的名字和我们在对象中使用的属性名是匹配的当您需要将同一个名称的属性解构为具有不同名称的参数时语法更加冗长和难懂下面是一个矢量加法的例子基于对象矢量的实现像的解构语法棘手的是记住哪一个是属性名哪一个是参数名牢记解构赋值和解构函数调用的规则声明的变量或参数在对象字面量中的位置固定属性名总是在冒号的左边参数或变量名在右边可以使用解构参数定义参数默认值下面是适用于或矢量的矢量乘法一些语言像允许函数的调用者以型式指定实参这在有很多可选实参或者参数列表长到难以记住正确的顺序时是非常方便的不允许直接这样做但可以通过解构对象实参到函数参数中构思一个函数将指定数量的元素从一个数组复制到另一个数组中可以随意地为每个数组指定起始偏移量如下有五个可传入参数其中一些有默认值并且调用者很难记住参数的顺序来传递实参可以像这样定义和调用方法当解构一个数组在其被拆包时可以定义一个剩余参数将其余值放在数组中在方括号中的剩余参数和真正的函数中的剩余参数是完全不同的在也可以用剩余参数解构对象剩余参数是一个没有解构的属性的对象对象剩余参数经常与对象展开运算符连用这是的新特性最后请记住除了可以解构实参对象和数组也可以解构数组对象对象有数组属性并且对象还有对象的属性构思一个将圆表示为具有半径和颜色属性的对象的图形代码颜色属性是一个数组由组成你可以定义一个函数该函数希望将单个圆对象传递给它但其解构为六个单独的参数如果函数实参解构比这更复杂代码会变得更难读而不是更简单有时显示地对对象属性访问和数组索引会让代码更清晰方法的形参并未声明类型在形参传入函数体之前也未做任何类型检查可以采用语义化的单词来给函数实参命名并在函数注释给每一个实参详细描述以此使代码自文本化已经提到在必要时会进行类型转换因此如果函数期望接收一个字符串实参而调用函数时传入其他类型的值所传入的值会在函数体内将其用做字符串的地方转换为字符串类型所有的原始类型都可以转换为字符串所有的对象都包含方法尽管不一定有用所以这种场景下是不会有任何错误的然而事情不总是这样回头看一下刚才提到的方法这个方法期望获得一个或两个实参并且这些实参的类型错误会导致函数执行失败除非所写的私有函数只会被附近的代码调用你应当添加类似的实参类型检查逻辑因为宁愿程序在传入非法值时报错也不愿非法值导致程序在执行时报错相比而言逻辑执行时的报错消息不甚清晰且更难处理下面这个例子中的函数就做了这种类型检查函数可以定义也可以调用这是函数最重要的特性函数定义和调用是的词法特性对于其他大多数编程语言来说亦是如此然而在中函数不仅是一种语法也是值也就是说可以将函数赋值给变量存储在对象的属性或数组的元素中作为参数传入另外一个函数等为了便于理解中的函数是如何用做数据以及语法的来看一下这样一个函数定义这个定义创建一个新的函数对象并将其赋值给变量函数的名字实际上是无形的它仅仅是变量的名称这个变量是函数对象的引用函数还可以赋值给其他的变量并且仍可以正常工作除了可以将函数赋值给变量同样可以将函数赋值给对象的属性当函数作为对象的属性调用时函数就称为方法函数甚至不需要带名字就像把它们赋值给数组元素上面的例子看起来很奇怪但的确是合法的函数调用表达式举一个例子来说明将函数当作值来对待的益处考虑下方法这个方法用来对数组元素进行排序因为排序的规则有很多基于数值大小字母表顺序日期大小从小到大从大到小等方法可以接收一个函数作为参数用来处理具体的排序操作这个函数的作用非常简单对于任意两个值都返回一个值以指定它们在排序后的数组中的先后顺序这个函数参数使得具有更完美的通用性和无限可扩展性它可以对任何类型的数据进行任意排序有示例代码示例展示了将函数用做值时的一些例子这段代码可能会难读一些但注释解释了代码的具体含义示例用函数做值中的函数并不是原始值而是一种特殊的对象也就是说函数可以拥有属性当函数需要一个静态变量来在调用时保持某个值不变最方便的方式就是给函数定义属性而不是定义全局变量显然定义全局变量会让命名空间变得更加杂乱无章比如假设你想写一个返回一个唯一整数的函数不管在哪里调用函数都会返回这个整数而函数不能两次返回同一个值为了做到这一点函数必须能够跟踪它每次返回的值而且这些值的信息需要在不同的函数调过程中持久化可以将这些信息存放到全局变量中但这并不是必需的因为这个信息仅仅是函数本身用到的最好将这个信息保存到函数对象的一个属性中下面这个例子就实现了这样一个函数每次调用函数都会返回一个唯一的整数来看另外一个例子下面这个函数使用了自身的属性将自身当做数组来对待来缓存上一次的计算结果变量声明在函数内对于函数体外是不可见的因此有时定义函数作为临时命名空间非常有用您可以在其中定义变量而不弄乱全局命名空间比如假设你写了一段模块代码这段代码将要用在不同的程序中对于客户端来讲通常是用在各种各样的网页中和大多数代码一样假定这段代码定义了一个用以存储中间计算结果的变量这样问题就来了当模块代码放到不同的程序中运行时你无法得知这个变量是否已经创建了如果已经存在这个变量那么将会和代码发生冲突解决办法当然是将代码放入一个函数内然后调用这个函数这样全局变量就变成了函数内的局部变量这段代码仅仅定义了一个单独的全局变量名为的函数如果还是太麻烦可以用一个单独的表达式定义一个匿名函数并调用它这种定义匿名函数并立即在单个表达式中调用它的写法非常常见并给它起了个名字匿名调用函数表达式注意上面代码的圆括号的用法之前的左圆括号是必需的因为如果不写这个左圆括号解释器会试图将关键字解析为函数声明语句使用圆括号解释器才会正确地将其解析为函数定义表达式使用前导括号也有助于人类阅读时区分函数定义是立即执行还是供以后使用函数用作命名空间很常用在命名空间函数中定义一个或多个函数使用其中的变量然后将他们作为函数命名空间的返回值这样的函数称为闭包它们是下一节的主题和其他大多数现代编程语言一样也采用词法作用域也就是说函数的执行依赖于变量作用域这个作用域是在函数定义时决定的而不是函数调用时决定的为了实现这种词法作用域函数对象的内部状态不仅包含函数的代码逻辑还必须包括对函数定义出现的作用域的引用将函数对象可和作用域相互关联起来一对变量的绑定函数体内部的变量都可以保存在函数作用域内这种特性在计算机科学文献中称为闭包从技术的角度讲所有的函数都是闭包但是大多数函数调用和定义在同一个作用域内通常不会注意这里有涉及到闭包当调用函数不和其定义处于同一作用域内时事情就变得非常微妙当一个函数嵌套了另外一个函数外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情有很多强大的编程技术都利用到了这类嵌套的函数闭包以至于这种编程模式在中非常常见当你第一次碰到闭包时可能会觉得非常让人费解一旦你理解掌握了闭包之后就能非常自如地使用它了了解这一点至关重要理解闭包首先要了解嵌套函数的词法作用域规则看一下这段代码函数声明了一个局部变量然后定义并执行了一个函数函数返回了这个变量的值最后将函数的执行结果返回你应当非常清楚为什么调用会返回现在我们对这段代码做一点改动你知道这段代码返回什么吗在这段代码中我们将函数内的一对圆括号移动到了之后现在仅仅返回函数内嵌套的一个函数对象而不是直接返回结果在定义函数的作用域外面调用这个嵌套的函数包含最后一行代码的最后一对圆括号会发生什么事情呢回想一下词法作用域的基本规则函数的执行用到了作用域这个作用域是函数定义的时候创建的嵌套的函数定义在变量绑定的值是的作用域里这个绑定无论函数在何处调用都依然有效因此最后一行代码返回而不是简言之闭包的这个特性强大到让人吃惊它们可以捕捉到它们的外部函数所绑定的局部变量和参数在中定义了函数这个函数使用自身的一个属性来保存每次返回的值以便每次调用都能跟踪上次的返回值但这种做法有一个问题就是恶意代码可能将计数器重置或者把一个非整数赋值给它导致函数不一定能产生唯一的整数而闭包可以捕捉到单个函数调用的局部变量并将这些局部变量用做私有状态下面是如何用立即调用函数表达式重写来定义命名空间和闭包来保持其状态私有化你需要仔细阅读这段代码才能理解其含义粗略来看第一行代码看起来像将函数赋值给一个变量实际上这段代码定义了一个立即调用的函数函数的开始带有左圆括号因此是这个函数的返回值赋值给变量现在我们来看函数体这个函数的返回值是另外一个函数这是一个嵌套的函数我们将它赋值给变量嵌套的函数是可以访问作用域内的变量的而且可以访问外部函数中定义的变量当外部函数返回之后其他任何代码都无法访问变量只有内部的函数才能访问到它像一样的私有变量不是只能用在一个单独的闭包内在同一个外部函数内定义的多个嵌套函数也可以访问它这多个嵌套函数都共享一个作用域看一下这段代码函数返回了一个计数器对象这个对象包含两个方法返回下一个整数重置内部状态首先要理解这两个方法都可以访问私有变量再者每次调用都会创建一个新的作用域链和一个新的私有变量因此如果调用两次则会得到两个计数器对象而且彼此包含不同的私有变量调用其中一个计数器对象的或不会影响到另外一个对象从技术角度看其实可以将这个闭包合并为属性存取器方法和下面这段代码所示的函数的版本是中代码的变种所不同的是这里私有状态的实现是利用了闭包而不是利用普通的对象属性来实现需要注意的是这个版本的函数并未声明局部变量而只是使用参数来保存私有状态并与属性存取器方法共享这样的话调用的函数就可以指定私有变量的初始值了示例是这种使用闭包技术来共享的私有状态的通用做法这个例子定义了函数这个函数定义了一个私有变量以及两个嵌套的函数用来获取和设置这个私有变量的值它将这些嵌套函数添加为所指定对象的方法示例利用闭包实现的私有属性存取器方法我们已经看到了很多例子在同一个作用域中定义两个闭包这两个闭包共享同样的私有变量或变量这是一种非常重要的技术但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包了解这一点也很重要看一下下面这段代码这段代码利用循环创建了很多个闭包当写类似这种代码的时候往往会犯一个错误那就是试图将循环代码移入定义这个闭包的函数之内看一下这段代码上面这段代码创建了个闭包并将它们存储到一个数组中这些闭包都是在同一个函数调用中定义的因此它们可以共享变量当返回时变量的值是所有的闭包都共享这一个值因此数组中的函数的返回值都是同一个值这不是我们想要的结果关联到闭包的作用域都是活动的记住这一点非常重要嵌套的函数不会将作用域内的私有成员复制一份也不会对所绑定的变量生成静态快照从根本上讲这里的问题是使用声明的变量它的定义贯穿整个函数我们的循环使用声明循环变量因此变量在整个函数中都有定义而不是更狭义地作用于循环的主体该代码演示了之前的常见类别但在中引入块级变量作用域解决了这个问题如果我们只是用或替换那么问题就消失了由于和是块级作用域因此循环的每个迭代都定义了一个独立于所有其他迭代的作用域并且每个作用域都有其自己的独立绑定书写闭包的时候还需注意一件事情是的关键字而不是变量正如之前讨论的箭头函数从包含它们的函数中继承值但是用关键字定义的函数不是所以如果写一个闭包需要使用包含它的函数的值要在闭包返回之前使用箭头函数或者用调用或者将值赋值给一个变量这样你的闭包会继承它我们看到在程序中函数是值对函数执行运算会返回字符串但是函数是中特殊的对象因为函数也是对象它们也可以拥有属性和方法就像普通的对象可以拥有属性和方法一样甚至可以用构造函数来创建新的函数对象接下来几节就会着重介绍函数和属性和方法以及构造函数函数的只读属性指定函数参数个数声明在其参数列表中的参数个数大多数函数期望的实参个数如果一个函数有一个剩余函数它的参数个数不被计算入属性经测试可选参数也不计算如果使用名称定义函数只读属性指定函数定义时用的名称或未命名函数表达式在首次创建时分配给的变量或属性的名称此属性在编写调试或错误消息时很有用所有函数都包含一个属性这个属性是指向一个对象的引用这个对象称做原型对象每一个函数都包含不同的原型对象当将函数用作构造函数的时候新创建的对象会从原型对象上继承属性讨论了原型和属性在第章里会有进一步讨论我们可以将和看做是某个对象的方法通过调用方法的形式来间接调用见函数和的第一个实参是要调用函数的母对象它是调用上下文在函数体内变成关键字的值要想以对象的方法来调用函数没有实参传递可以这样使用和每行代码和下面代码的功能类似假设对象中预先不存在名为的属性不要忘了箭头函数从它定义的位置的上下文继承值这不能被和方法重写如果通过箭头函数调用它俩任何一个方法第一个实参实际上都被忽略对于来说除了第一个作为调用上下文实参之后的所有实参就是要传入待调用函数的值并且这部分实参对于箭头函数来说不被忽略比如以对象的方法的形式调用函数并传入两个数可以使用这样的代码方法和类似但传入实参的形式和有所不同它的实参都放入一个数组中如果一个函数的实参可以是任意数量用方法允许你传入的参数数组可以是任意长度的在之后我们可以用展开运算符但是在的代码中你可以看到这种情况是用来替代比如不用展开运算符找出数组中最大的数值元素调用方法的时候可以给传入一个包含任意个元素的数组下面定义的与中定义的函数类似但是它对方法有效而不是函数它使用方法而不是展开运算符通过这样做它能够调用具有相同参数和与被包装方法相同的值的包装方法方法的主要作用就是将函数绑定至某个对象当在函数上调用方法并传入一个对象作为参数这个方法将返回一个新的函数以函数调用的方式调用新的函数将会把原始的函数当做的方法来调用传入新函数的任何实参都将传入原始函数比如箭头函数从它们定义的上下文中继承值并且其不可被方法重写所以如果上面的代码用箭头函数定义函数这个绑定不会生效调用方法的最常用场景是让不带箭头的函数的行为像箭头函数一样所以实际上绑定箭头函数的局限性并不是一个问题但是方法不仅仅是将函数绑定至一个对象它还附带一些其他应用除了第一个实参之外传入的实参也会绑定至值这个附带的应用在箭头函数上也同样生效是一种常见的函数式编程技术有时也被称为柯里化参照下面这个例子中的方法的实现返回函数的名称属性是调用的函数的名称属性前面加上前缀为单词和所有的对象一样函数也有方法规范规定这个方法返回一个字符串这个字符串和函数声明语句的语法相关实际上大多数非全部的方法的实现都返回函数的完整源码内置函数往往返回一个类似的字符串作为函数体因为函数是对象有一个构造函数可以用来创建新的函数这一行代码创建一个新的函数这个函数和通过下面代码定义的函数几乎等价构造函数可以传入任意数量的字符串实参最后一个实参所表示的文本就是函数体它可以包含任意的语句每两条语句之间用分号分隔传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串如果定义的函数不包含任何参数只须给构造函数简单地传入一个字符串函数体即可注意构造函数并不需要通过传入实参以指定函数名就像函数字面量一样构造函数创建一个匿名函数关于构造函数有几点需要特别注意构造函数允许在运行时动态地创建并编译函数每次调用构造函数都会解析函数体并创建新的函数对象如果是在一个循环或者多次调用的函数中执行这个构造函数执行效率会受影响相比之下循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译最后一点也是关于构造函数非常重要的一点就是它所创建的函数并不是使用词法作用域相反函数体代码的编译类似顶层函数如下面代码所示我们可以将构造函数认为是在全局作用域中执行的见可以在自己的私有作用域内定义新变量和函数构造函数在实际编程过程中很少会用到和不同并非函数式编程语言但在中可以像操控对象一样操控函数也就是说可以在中应用函数式编程技术数组方法诸如和就可以非常适合用于函数式编程风格接下来的几节将会着重介绍中的函数式编程技术函数式编程旨在扩展对函数功能功能的探索而不是为了良好的编程风格假设有一个数组数组元素都是数字我们想要计算这些元素的平均值和标准差若使用非函数式编程风格的话代码会是这样可以使用数组方法和来实现同样的计算这种实现极其简洁参照来查看这些方法这个新版本的代码看起来跟第一版有很大不同但是它仍然调用对象的方法所以它还是面向对象编程接下来用函数版本的和方法用这两个函数定义了和我们计算平均值和标准差变成这样所谓高阶函数就是操作函数的函数它接收一个或多个函数作为参数并返回一个新函数来看这个例子上面的函数就是一个高阶函数因为它接收一个函数作为参数并返回一个新函数另外一个例子来看下面的函数它也是接收一个函数作为实参并返回一个新函数这个新函数将一个数组映射到另一个使用这个函数的数组上这个函数使用了之前定义的函数但要首先理解这两个函数有哪里不同理解这一点至关重要这里是一个更常见的例子它接收两个函数和并返回一个新的函数用以计算本章后续几节中定义了和函数这两个函数是非常重要的高阶函数函数见的方法返回一个新函数给新函数传入特定的上下文和一组指定的参数然后调用函数我们说它把函数绑定至对象并传入一部分参数方法只是将实参放在完整实参列表的左侧也就是说传入的实参都是放在传入原始函数的实参列表开始的位置但有时我们期望将传入的实参放在完整实参列表的右侧利用这种不完全函数的编程技巧可以编写一些有意思的代码利用已有的函数来定义新的函数参照下面这个例子当将不完全调用和其他高阶函数整合在一起的时候事情就变得格外有趣了比如这里的例子定义了函数它用到了刚才提到的不完全调用我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码这种编码风格是非常纯粹的函数式编程注意这段代码计算平均值和标准差完全是函数调用没有涉及运算符并且括号的数量增长如此之大让开始看起来像代码同样这不是我提倡的编程风格但它是一个有趣的练习看看代码的功能有多深在中定义了一个阶乘函数它可以将上次的计算结果缓存起来在函数式编程当中这种缓存技巧叫做记忆下面的代码展示了一个高阶函数接收一个函数作为实参并返回带有记忆能力的函数函数创建一个新的对象这个对象被当做缓存的宿主并赋值给一个局部变量因此对于返回的函数来说它是私有的在闭包中所返回的函数将它的实参数组转换成字符串并将字符串用做缓存对象的属性名如果在缓存中存在这个值则直接返回它否则就调用既定的函数对实参进行计算将计算结果缓存起来并返回下面的代码展示了如何使用本章关键点总结如下可以用函数关键字和箭头函数来定义函数可以以方法和构造函数的方式调用函数一些特性允许参数设定默认值可以用剩余参数将多个参数搜集到一个数组中可以解构对象和数组实参到函数参数中可以用展开运算符传递数组元素或者其他可迭代对象到函数调用封闭函数内部定义并返回的函数保留对其词法作用域的访问因此可以读取和写入外部函数内定义的变量用这种方式使用的函数称为闭包这是一种值得理解的技术函数是可由操作的对象这使支持函数式编程这个术语最初是由提出的参见这看起来不足为奇但如果你对很熟悉你会发现中的函数是程序的一部分但无法被程序操作这似乎并不是一个特别有趣的点除非你熟悉更多的静态语言其中函数是程序的一部分但不能由程序操作',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:44:34',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Jackhou Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 1.05rem;">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 1.05rem;">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem;">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 1.05rem;">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 1.05rem;">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 1.05rem;">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 1.05rem;">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 1.05rem;">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.05rem;">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 1.05rem;">越权<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">37</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>《JavaScript权威指南》</span></a><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">第8章 函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:53.000Z" title="发表于 2023-04-26 00:00:53">2023-04-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:34.000Z" title="更新于 2023-04-26 21:44:34">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="第8章 函数"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url">《JavaScript权威指南》</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><h1 id="CrawlerTitle" itemprop="name headline">第8章 函数</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jack hou</span><time itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:53.000Z" title="发表于 2023-04-26 00:00:53">2023-04-26</time><time itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:34.000Z" title="更新于 2023-04-26 21:44:34">2023-04-26</time></header><meta name="referrer" content="no-referrer"/>


<p>This chapter covers JavaScript functions. Functions are a fundamental building block for JavaScript programs and a common feature in almost all programming languages. You may already be familiar with the concept of a function under a name such as subroutine or procedure.</p>
<blockquote>
<p>本章介绍了 JavaScript 函数。函数是 JavaScript 程序的基本构建块，也是几乎所有编程语言的共同特性。你可能已经了解函数的概念，如子例程或过程。</p>
</blockquote>
<p>A function is a block of JavaScript code that is defined once but may be executed, or invoked, any number of times. JavaScript functions are parameterized: a function definition may include a list of identifiers, known as parameters, that work as local variables for the body of the function. Function invocations provide values, or arguments, for the function’s parameters. Functions often use their argument values to compute a return value that becomes the value of the function-invocation expression. In addition to the arguments, each invocation has another value—the invocation context—that is the value of the this keyword.</p>
<blockquote>
<p>函数是一个 JavaScript 代码块，只定义一次，但可以执行或调用任意次数。JavaScript 函数是参数化的：一个函数定义可以包含一个标识符列表，称为参数，作为函数体的局部变量。函数调用为函数的参数提供值或实参。函数通常使用它们的实参值来计算一个返回值，该返回值成为函数调用表达式的值。除了参数之外，每次调用都有另一个值——调用上下文——即 this 关键字的值。</p>
</blockquote>
<p>If a function is assigned to a property of an object, it is known as a method of that object. When a function is invoked on or through an object, that object is the invocation context or this value for the function. Functions designed to initialize a newly created object are called constructors. Constructors were described in §6.2 and will be covered again in Chapter 9.</p>
<blockquote>
<p>如果函数挂载在一个对象上作为其属性，它就被称为方法。当该方法在对象中被调用或通过对象调用时，该对象就是该方法函数的调用上下文或 this 值。用于初始化新创建的对象的函数称为构造函数。构造函数在 §6.2 中有介绍，我们将在第 9 章中再次谈到它。</p>
</blockquote>
<p>In JavaScript, functions are objects, and they can be manipulated by programs. JavaScript can assign functions to variables and pass them to other functions, for example. Since functions are objects, you can set properties on them and even invoke methods on them.</p>
<blockquote>
<p>在 JavaScript 中，函数是对象，它们可以被程序操作。例如，JavaScript 可以将函数赋给变量，并将它们传递给其他函数。由于函数是对象，所以您可以给它们设置属性，甚至调用它们的方法。</p>
</blockquote>
<p>JavaScript function definitions can be nested within other functions, and they have access to any variables that are in scope where they are defined. This means that JavaScript functions are closures, and it enables important and powerful programming techniques.</p>
<blockquote>
<p>JavaScript 函数可以嵌套在其他函数中定义，并且它们可以访问定义它们所处的作用域内任何变量。这意味着 JavaScript 函数是闭包，支持闭包是非常重要的，它是非常强大的编程技巧。</p>
</blockquote>
<h2 id="8-1-Defining-Functions"><a href="#8-1-Defining-Functions" class="headerlink" title="8.1 Defining Functions"></a>8.1 Defining Functions</h2><p>The most straightforward way to define a JavaScript function is with the function keyword, which can be used as a declaration or as an expression. ES6 defines an important new way to define functions without the function keyword: “arrow functions” have a particularly compact syntax and are useful when passing one function as an argument to another function. The subsections that follow cover these three ways of defining functions. Note that some details of function definition syntax involving function parameters are deferred to §8.3.</p>
<blockquote>
<p>定义 JavaScript 函数最直接的方法是使用 function 关键字，它既可以用作声明又可以用作表达式。ES6 定义了一种不使用 function 关键字的重要新方法来定义的函数：“箭头函数”，它具有特别简洁语法，并且在将一个函数作为参数传递给另一个函数的场景中非常实用。接下来的小节将介绍这三种定义函数的方法。注意，关于函数定义语法包含的函数参数相关内容将在 §8.3 中介绍。</p>
</blockquote>
<p>In object literals and class definitions, there is a convenient shorthand syntax for defining methods. This shorthand syntax was covered in §6.10.5 and is equivalent to using a function definition expression and assigning it to an object property using the basic name:value object literal syntax. In another special case, you can use keywords get and set in object literals to define special property getter and setter methods. This function definition syntax was covered in §6.10.6.</p>
<blockquote>
<p>在对象字面量和类定义中，有一种方便的快捷语法来定义方法。这种简写语法在 §6.10.5 中有介绍，相当于通过对象字面量语法将函数定义表达式用最基本的属性名：属性值的方式赋值给对象的属性。在另一种特殊情况下，可以在对象字面量中使用关键字 get 和 set 来定义特殊的属性 getter 和 setter 方法。这个函数定义语法在 §6.10.6 中介绍过。</p>
</blockquote>
<p>Note that functions can also be defined with the Function() constructor, which is the subject of §8.7.7. Also, JavaScript defines some specialized kinds of functions. function* defines generator functions (see Chapter 12) and async function defines asynchronous functions (see Chapter 13).</p>
<blockquote>
<p>注意，函数也可以用 Function() 构造函数来定义，这是 §8.7.7 的主题。此外，JavaScript 还定义了一些特殊类型的函数。function* 定义函数生成器（见第 12 章）和 async function 定义异步函数（见第 13 章）。</p>
</blockquote>
<h3 id="8-1-1-Function-Declarations"><a href="#8-1-1-Function-Declarations" class="headerlink" title="8.1.1 Function Declarations"></a>8.1.1 Function Declarations</h3><p>Function declarations consist of the function keyword, followed by these components:</p>
<ul>
<li>An identifier that names the function. The name is a required part of function declarations: it is used as the name of a variable, and the newly defined function object is assigned to the variable.</li>
<li>A pair of parentheses around a comma-separated list of zero or more identifiers. These identifiers are the parameter names for the function, and they behave like local variables within the body of the function.</li>
<li>A pair of curly braces with zero or more JavaScript statements inside. These statements are the body of the function: they are executed whenever the function is invoked.</li>
</ul>
<hr>
<p>函数声明由 function 关键字组成，后面跟着这些组件:</p>
<ul>
<li>函数名称标识符。名称是函数声明的必要部分:它用作变量的名称，并将新定义的函数对象赋值给该变量。</li>
<li>一对圆括号，其中包含由0个或者多个用逗号分隔的标识符组成的列表。这些标识符是函数的参数名，它们的行为类似于函数体中的局部变量。</li>
<li>一对花括号，其中包含由0条或者多条 JavaScript 语句。这些语句构成了函数体：每当函数调用时，就会执行这些语句。</li>
</ul>
<p>Here are some example function declarations:</p>
<blockquote>
<p>下面是一些函数声明的例子:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print the name and value of each property of o.  Return undefined.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printprops</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> p <span class="keyword">in</span> o) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;p&#125;</span>: <span class="subst">$&#123;o[p]&#125;</span>\n`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the distance between Cartesian points (x1,y1) and (x2,y2).</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">distance</span>(<span class="params">x1, y1, x2, y2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> dx = x2 - x1;</span><br><span class="line">    <span class="keyword">let</span> dy = y2 - y1;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(dx*dx + dy*dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A recursive function (one that calls itself) that computes factorials</span></span><br><span class="line"><span class="comment">// Recall that x! is the product of x and all positive integers less than it.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x * <span class="title function_">factorial</span>(x-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>One of the important things to understand about function declarations is that the name of the function becomes a variable whose value is the function itself. Function declaration statements are “hoisted” to the top of the enclosing script, function, or block so that functions defined in this way may be invoked from code that appears before the definition. Another way to say this is that all of the functions declared in a block of JavaScript code will be defined throughout that block, and they will be defined before the JavaScript interpreter begins to execute any of the code in that block.</p>
<blockquote>
<p>重中之重要理解函数声明是函数名变成一个变量，这个变量的值是函数本身。函数声明语句“被提前”到脚本、函数、块之前，因此这种方式定义的函数可以在它定义之前被调用。另一种说法是所有声明在 Javascript 代码块中的函数，在块内始终是有定义的，它们定义在 JavaScript 解释器开始解释执行块内任何语句之前。</p>
</blockquote>
<p>The distance() and factorial() functions we’ve described are designed to compute a value, and they use return to return that value to their caller. The return statement causes the function to stop executing and to return the value of its expression (if any) to the caller. If the return statement does not have an associated expression, the return value of the function is undefined.</p>
<blockquote>
<p>distance() 和 factorial() 函数计算一个值，它们用 retrun 来将这个值返回给调用者。return 语句导致函数停止执行，并返回它的表达式的值（如果有的话）给调用者。如果 return 语句没有一个与之相关的表达式，则函数返回 undefined 值。</p>
</blockquote>
<p>The printprops() function is different: its job is to output the names and values of an object’s properties. No return value is necessary, and the function does not include a return statement. The value of an invocation of the printprops() function is always undefined. If a function does not contain a return statement, it simply executes each statement in the function body until it reaches the end, and returns the undefined value to the caller.</p>
<blockquote>
<p>printprops() 函数不同：它负责输出对象属性的名称和值。没有返回值的必要，并且该函数也不包含一个 return 语句。 调用 printprops() 函数的返回值永远是 undefined。如果一个函数不包含一个 return 语句，它仅仅执行函数体内每一条语句直到结束，并返回 undefined 给调用者。</p>
</blockquote>
<p>Prior to ES6, function declarations were only allowed at the top level within a JavaScript file or within another function. While some implementations bent the rule, it was not technically legal to define functions inside the body of loops, conditionals, or other blocks. In the strict mode of ES6, however, function declarations are allowed within blocks. A function defined within a block only exists within that block, however, and is not visible outside the block.</p>
<blockquote>
<p>在 ES6 之前，函数只允许在 JavaScript 文件顶层或者其他函数中声明。然而一些实现违反规约，在循环体条件体或者其他块中定义函数。在 ES6 的严格模式下，函数允许在块内进行声明。一个定义在块内的函数只存在于该块内，块外是不可见的。</p>
</blockquote>
<h3 id="8-1-2-Function-Expressions"><a href="#8-1-2-Function-Expressions" class="headerlink" title="8.1.2 Function Expressions"></a>8.1.2 Function Expressions</h3><p>Function expressions look a lot like function declarations, but they appear within the context of a larger expression or statement, and the name is optional.</p>
<blockquote>
<p>函数表达式看起来很像函数声明，但是它出现在一个它的上层表达式或语句的上下文中，并且函数名称是可选项。</p>
</blockquote>
<p> Here are some example function expressions:</p>
<blockquote>
<p>下面是一些函数表达式的例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function expression defines a function that squares its argument.</span></span><br><span class="line"><span class="comment">// Note that we assign it to a variable</span></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x*x; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function expressions can include names, which is useful for recursion.</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">function</span> <span class="title function_">fact</span>(<span class="params">x</span>) &#123; <span class="keyword">if</span> (x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">return</span> x*<span class="title function_">fact</span>(x-<span class="number">1</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function expressions can also be used as arguments to other functions:</span></span><br><span class="line">[<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>) &#123; <span class="keyword">return</span> a-b; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function expressions are sometimes defined and immediately invoked:</span></span><br><span class="line"><span class="keyword">let</span> tensquared = (<span class="keyword">function</span>(<span class="params">x</span>) &#123;<span class="keyword">return</span> x*x;&#125;(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p>Note that the function name is optional for functions defined as expressions, and most of the preceding function expressions we’ve shown omit it. A function declaration actually declares a variable and assigns a function object to it. A function expression, on the other hand, does not declare a variable: it is up to you to assign the newly defined function object to a constant or variable if you are going to need to refer to it multiple times. It is a good practice to use const with function expressions so you don’t accidentally overwrite your functions by assigning new values.</p>
<blockquote>
<p>注意函数名称在函数表达式中是可选项，在大部分函数表达式中我们省略了它。函数声明实际上声明了一个变量并且将函数对象赋值给它。按照这个角度来看，函数表达式没有声明一个变量：可以根据它是否会多次调用由你自己决定是将新定义的函数对象赋值给一个常量还是变量。用 const 定义函数表达式是一个非常好的做法，你不会因为意外赋值而重写了你的函数。</p>
</blockquote>
<p>A name is allowed for functions, like the factorial function, that need to refer to themselves. If a function expression includes a name, the local function scope for that function will include a binding of that name to the function object. In effect, the function name becomes a local variable within the function. Most functions defined as expressions do not need names, which makes their definition more compact (though not nearly as compact as arrow functions, described below).</p>
<blockquote>
<p>可以给函数一个名称，就像 factorial 函数，它需要调用它自己。如果一个函数表达式包含一个名称，那这个函数的局部函数作用域内会包含一个属性名为该函数名的对象，其值绑定的是该函数。实际上，函数名变成这个函数的一个局部变量。大多数函数表达式不需要函数名称，这让它们的定义更简洁（但是并没有下面要讲的箭头函数简洁）。</p>
</blockquote>
<p>There is an important difference between defining a function f() with a function declaration and assigning a function to the variable f after creating it as an expression. When you use the declaration form, the function objects are created before the code that contains them starts to run, and the definitions are hoisted so that you can call these functions from code that appears above the definition statement. This is not true for functions defined as expressions, however: these functions do not exist until the expression that defines them are actually evaluated. Furthermore, in order to invoke a function, you must be able to refer to it, and you can’t refer to a function defined as an expression until it is assigned to a variable, so functions defined with expressions cannot be invoked before they are defined.</p>
<blockquote>
<p>在函数声明和函数表达式之间有一个非常重要的不同。当你用函数声明，该函数对象创建于该函数所在作用域的代码开始执行之前，也就是声明提前，所以你可以在函数定义之前调用他们。如果用函数表达式来定义一个函数，这样使用就是不对的：该函数不会存在，直到函数定义表达式真正被计算。因为，想要执行一个函数，你必须可以引用它，而一个函数表达式定义的函数一直到该函数赋值给一个变量后才能被引用，所以要使用函数表达式需要在函数被调用之前定义。</p>
</blockquote>
<h3 id="8-1-3-Arrow-Functions"><a href="#8-1-3-Arrow-Functions" class="headerlink" title="8.1.3 Arrow Functions"></a>8.1.3 Arrow Functions</h3><p>In ES6, you can define functions using a particularly compact syntax known as “arrow functions.” This syntax is reminiscent of mathematical notation and uses an &#x3D;&gt; “arrow” to separate the function parameters from the function body. The function keyword is not used, and, since arrow functions are expressions instead of statements, there is no need for a function name, either. The general form of an arrow function is a comma-separated list of parameters in parentheses, followed by the &#x3D;&gt; arrow, followed by the function body in curly braces:</p>
<blockquote>
<p>在 ES6 之后，你可以用一个特别简洁的语法来定义函数，被称为“箭头函数”。这个语法联想到数学符号，用一个 &#x3D;&gt; “箭头”来分隔函数的参数和函数体。function 关键字未使用，并且，由于箭头函数是表达式而不是声明语句，也不需要一个函数名称。一般箭头函数用圆括号包含一个逗号分隔的参数列表，接一个 &#x3D;&gt; 箭头，后面是花括号包含的函数体。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; &#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>

<p>But arrow functions support an even more compact syntax. If the body of the function is a single return statement, you can omit the return keyword, the semicolon that goes with it, and the curly braces, and write the body of the function as the expression whose value is to be returned:</p>
<blockquote>
<p>但是箭头函数支持更加简洁的语法。如果函数体只有一个简单的 return 语句，你可以省略 return 关键字，分号和花括号都一起省略，将函数体写成一个计算返回值的表达式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x, y</span>) =&gt; x + y;</span><br></pre></td></tr></table></figure>

<p>Furthermore, if an arrow function has exactly one parameter, you can omit the parentheses around the parameter list:</p>
<blockquote>
<p>而且，如果一个箭头函数只有一个参数，你可以省略参数列表的圆括号。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">polynomial</span> = x =&gt; x*x + <span class="number">2</span>*x + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>Note, however, that an arrow function with no arguments at all must be written with an empty pair of parentheses:</p>
<blockquote>
<p>注意，如果箭头函数没有参数，必须写一对空圆括号。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">constantFunc</span> = (<span class="params"></span>) =&gt; <span class="number">42</span>;</span><br></pre></td></tr></table></figure>

<p>Note that, when writing an arrow function, you must not put a new line between the function parameters and the &#x3D;&gt; arrow. Otherwise, you could end up with a line like const polynomial &#x3D; x, which is a syntactically valid assignment statement on its own.</p>
<blockquote>
<p>注意，当写一个箭头函数时，函数参数和箭头之间不能换行。否则，可能会直接在赋值后中止，就像 const polynomial &#x3D; x，因为它本身是一个语法上合法的赋值语句。</p>
</blockquote>
<p>Also, if the body of your arrow function is a single return statement but the expression to be returned is an object literal, then you have to put the object literal inside parentheses to avoid syntactic ambiguity between the curly braces of a function body and the curly braces of an object literal:</p>
<blockquote>
<p>此外，如果箭头函数体是一个单一的 return 语句，而且他返回的是一个对象字面量，那必须将对象字面量用圆括号包起来，避免将对象字面量的大括号误解成函数体的大括号。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = x =&gt; &#123; <span class="keyword">return</span> &#123; <span class="attr">value</span>: x &#125;; &#125;;  <span class="comment">// Good: f() returns an object</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">g</span> = x =&gt; (&#123; <span class="attr">value</span>: x &#125;);            <span class="comment">// Good: g() returns an object</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">h</span> = x =&gt; &#123; <span class="attr">value</span>: x &#125;;              <span class="comment">// Bad: h() returns nothing</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">i</span> = x =&gt; &#123; <span class="attr">v</span>: x, <span class="attr">w</span>: x &#125;;            <span class="comment">// Bad: Syntax Error</span></span><br></pre></td></tr></table></figure>

<p>In the third line of this code, the function h() is truly ambiguous: the code you intended as an object literal can be parsed as a labeled statement, so a function that returns undefined is created. On the fourth line, however, the more complicated object literal is not a valid statement, and this illegal code causes a syntax error.</p>
<blockquote>
<p>这段代码的第三行，函数 h() 就有歧义：这段代码原本返回对象字面量被转化为一个标签语句，所以一个返回 undefined 的函数被创建。第四行，结构更复杂的对象字面量不是一个合法的语句，这段代码会抛出一个语法异常。</p>
</blockquote>
<p>The concise syntax of arrow functions makes them ideal when you need to pass one function to another function, which is a common thing to do with array methods like map(), filter(), and reduce() (see §7.8.1), for example:</p>
<blockquote>
<p>简洁的箭头函数可以完美的传递一个函数给另外一个函数，比如一些数组的常规操作方法 map()，filter() 和 reduce()（见 §7.8.1），例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make a copy of an array with null elements removed.</span></span><br><span class="line"><span class="keyword">let</span> filtered = [<span class="number">1</span>,<span class="literal">null</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">filter</span>(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="literal">null</span>); <span class="comment">// filtered == [1,2,3]</span></span><br><span class="line"><span class="comment">// Square some numbers:</span></span><br><span class="line"><span class="keyword">let</span> squares = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x*x);               <span class="comment">// squares == [1,4,9,16]</span></span><br></pre></td></tr></table></figure>

<p>Arrow functions differ from functions defined in other ways in one critical way: they inherit the value of the this keyword from the environment in which they are defined rather than defining their own invocation context as functions defined in other ways do. This is an important and very useful feature of arrow functions, and we’ll return to it again later in this chapter. Arrow functions also differ from other functions in that they do not have a prototype property, which means that they cannot be used as constructor functions for new classes (see §9.2).</p>
<blockquote>
<p>箭头函数不同于用关键字定义的函数：箭头函数从定义它们的环境继承 this 关键字，而不是像其他定义方式那样定义自己的调用上下文。这是箭头函数一个重要且特别实用的特性，我们会在这一章的后面再次提到它。箭头函数也不同于其他函数，它们没有有原型属性。这意味着它不能被当作一个构造函数去创建一个类（见 §9.2）。</p>
</blockquote>
<h3 id="8-1-4-Nested-Functions"><a href="#8-1-4-Nested-Functions" class="headerlink" title="8.1.4 Nested Functions"></a>8.1.4 Nested Functions</h3><p>In JavaScript, functions may be nested within other functions. For example:</p>
<blockquote>
<p>在 JavaScript 中，函数可以嵌套在其他函数内。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">hypotenuse</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x*x; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="title function_">square</span>(a) + <span class="title function_">square</span>(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The interesting thing about nested functions is their variable scoping rules: they can access the parameters and variables of the function (or functions) they are nested within. In the code shown here, for example, the inner function square() can read and write the parameters a and b defined by the outer function hypotenuse(). These scope rules for nested functions are very important, and we will consider them again in §8.6.</p>
<blockquote>
<p>嵌套函数的有趣之处在于它的变量作用域规则：它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量。例如，在上面的代码里，内部函数 square() 可以读写外部函数 hypotenuse() 定义的参数 a 和 b。这些作用域规则对嵌套函数非常重要，我们会在 §8.6 再深入了解它们。</p>
</blockquote>
<h2 id="8-2-Invoking-Functions"><a href="#8-2-Invoking-Functions" class="headerlink" title="8.2 Invoking Functions"></a>8.2 Invoking Functions</h2><p>The JavaScript code that makes up the body of a function is not executed when the function is defined, but rather when it is invoked. JavaScript functions can be invoked in five ways:</p>
<blockquote>
<p>构成函数主体的 JavaScript 代码在定义之时并不会执行，只有调用该函数时，它们才会执行。JavaScript 函数可以以五种方式被调用。</p>
</blockquote>
<p>As functions</p>
<p>As methods</p>
<p>As constructors</p>
<p>Indirectly through their call() and apply() methods</p>
<p>Implicitly, via JavaScript language features that do not appear like normal function invocations</p>
<blockquote>
<p>作为函数</p>
<p>作为方法</p>
<p>作为构造函数</p>
<p>通过它们的 call() 和 apply() 方法间接调用</p>
<p>隐式调用，不同于普通函数调，通过 JavaScript 语言特性调用函数。</p>
</blockquote>
<h3 id="8-2-1-Function-Invocation"><a href="#8-2-1-Function-Invocation" class="headerlink" title="8.2.1 Function Invocation"></a>8.2.1 Function Invocation</h3><p>Functions are invoked as functions or as methods with an invocation expression (§4.5). An invocation expression consists of a function expression that evaluates to a function object followed by an open parenthesis, a comma-separated list of zero or more argument expressions, and a close parenthesis. If the function expression is a property-access expression—if the function is the property of an object or an element of an array—then it is a method invocation expression. That case will be explained in the following example. The following code includes a number of regular function invocation expressions:</p>
<blockquote>
<p>函数或方法通过调用表达式（§4.5）被调用。调用表达式由以下部分组成，计算函数对象的函数表达式，一个开放圆括号，逗号分隔的零个或多个实参表达式列表，一个闭合圆括号。如果函数表达式是属性访问表达式（函数是一个对象的属性或者一个数组的元素）那么它是一个方法调用表达式。这种情况会通过下面的例子说明，接下来这个代码包含了一些常规的函数调用表达式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">printprops</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> total = <span class="title function_">distance</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>) + <span class="title function_">distance</span>(<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> probability = <span class="title function_">factorial</span>(<span class="number">5</span>)/<span class="title function_">factorial</span>(<span class="number">13</span>);</span><br></pre></td></tr></table></figure>
<p>In an invocation, each argument expression (the ones between the parentheses) is evaluated, and the resulting values become the arguments to the function. These values are assigned to the parameters named in the function definition. In the body of the function, a reference to a parameter evaluates to the corresponding argument value.</p>
<blockquote>
<p>在调用中，每个实参表达式（圆括号内的）执行计算，返回值作为函数的实参。这些值传给函数定义的参数。在函数体内，参数的引用指向对应实参的值。</p>
</blockquote>
<p>For regular function invocation, the return value of the function becomes the value of the invocation expression. If the function returns because the interpreter reaches the end, the return value is undefined. If the function returns because the interpreter executes a return statement, then the return value is the value of the expression that follows the return or is undefined if the return statement has no value.</p>
<blockquote>
<p>对于常规的函数调用，函数返回值变成函数调用表达式的值。如果因解释器执行到函数结尾而返回，返回值就是 undefined。如果函数返回是因为解释器执行一个 return 语句，那么返回值是 return 后面的表达式的计算结果，如果 return 语句没有值也返回 undefined。</p>
</blockquote>
<h4 id="CONDITIONAL-INVOCATION"><a href="#CONDITIONAL-INVOCATION" class="headerlink" title="CONDITIONAL INVOCATION"></a>CONDITIONAL INVOCATION</h4><p>In ES2020 you can insert ?. after the function expression and before the open parenthesis in a function invocation in order to invoke the function only if it is not null or undefined. That is, the expression f?.(x) is equivalent (assuming no side effects) to:</p>
<blockquote>
<p>在 ES2020 中你可以通过在函数表达式和圆括号之间插入 ?. 符号，使函数只有在不为 null 和 undefined 时候再调用。表达式 f?.(x) 等价（假设没有副作用）于：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(f !== <span class="literal">null</span> &amp;&amp; f !== <span class="literal">undefined</span>) ? <span class="title function_">f</span>(x) : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>Full details on this conditional invocation syntax are in §4.5.1.</p>
<blockquote>
<p>详细的条件执行语法描述在 §4.5.1。</p>
</blockquote>
<p>For function invocation in non-strict mode, the invocation context (the this value) is the global object. In strict mode, however, the invocation context is undefined. Note that functions defined using the arrow syntax behave differently: they always inherit the this value that is in effect where they are defined.</p>
<blockquote>
<p>函数调用在非严格模式下，调用上下文（ this ）是全局对象。然而在严格模式下，调用上下文是 undefined。注意箭头语法定义的函数行为是不同的：实际上它们总是继承它们定义位置的 this 值。</p>
</blockquote>
<p>Functions written to be invoked as functions (and not as methods) do not typically use the this keyword at all. The keyword can be used, however, to determine whether strict mode is in effect:</p>
<blockquote>
<p>以函数形式调用的函数通常不使用 this 关键字。不过，this 关键字可以用来判断当前是否是严格模式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define and invoke a function to determine if we&#x27;re in strict mode.</span></span><br><span class="line"><span class="keyword">const</span> strict = (<span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> !<span class="variable language_">this</span>; &#125;());</span><br></pre></td></tr></table></figure>
<h4 id="RECURSIVE-FUNCTIONS-AND-THE-STACK"><a href="#RECURSIVE-FUNCTIONS-AND-THE-STACK" class="headerlink" title="RECURSIVE FUNCTIONS AND THE STACK"></a>RECURSIVE FUNCTIONS AND THE STACK</h4><p>A recursive function is one, like the factorial() function at the start of this chapter, that calls itself. Some algorithms, such as those involving tree-based data structures, can be implemented particularly elegantly with recursive functions. When writing a recursive function, however, it is important to think about memory constraints. When a function A calls function B, and then function B calls function C, the JavaScript interpreter needs to keep track of the execution contexts for all three functions. When function C completes, the interpreter needs to know where to resume executing function B, and when function B completes, it needs to know where to resume executing function A. You can imagine these execution contexts as a stack. When a function calls another function, a new execution context is pushed onto the stack. When that function returns, its execution context object is popped off the stack. If a function calls itself recursively 100 times, the stack will have 100 objects pushed onto it, and then have those 100 objects popped off. This call stack takes memory. On modern hardware, it is typically fine to write recursive functions that call themselves hundreds of times. But if a function calls itself ten thousand times, it is likely to fail with an error such as “Maximum call-stack size exceeded.”</p>
<blockquote>
<p>递归函数就像本章开始的 factorial() 函数，它调用它自己。某些算法（如涉及基于树的数据结构）可以使用递归函数特别优雅地实现。在写递归函数时，考虑内存分配是很重要的。当函数 A 调用函数 B，然后函数 B 又调用函数 C 时，Javascript 编译器需要知道在哪里重新执行函数 B，当函数 B 执行完成后它需要知道在哪里执行函数 A。你可以将执行上下文想象成一个栈。当一个函数调用另外一个函数时，一个新的执行上下文被压入栈中。当被调用函数返回，它的执行上下文对象从栈中弹出。如果一个函数递归调用100次，那么会有100个对象被压入栈中，然后这100个对象再依次从栈中弹出。这种调用非常耗内存。以现代的硬件递归调用100次通常没什么问题。但是如果一个函数递归上千次，它可能会失败并报错“Maximum call-stack size exceeded.”。</p>
</blockquote>
<h3 id="8-2-2-Method-Invocation"><a href="#8-2-2-Method-Invocation" class="headerlink" title="8.2.2 Method Invocation"></a>8.2.2 Method Invocation</h3><p>A method is nothing more than a JavaScript function that is stored in a property of an object. If you have a function f and an object o, you can define a method named m of o with the following line:</p>
<blockquote>
<p>方法只不过是对象属性函数。如果有一个函数 f 和一个对象 o，可以用下面的代码给对象 o 定义一个名为 m 的方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.<span class="property">m</span> = f;</span><br></pre></td></tr></table></figure>
<p>Having defined the method m() of the object o, invoke it like this:</p>
<blockquote>
<p>给对象 o 定义了方法 m()，用这种方式调用它：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.<span class="title function_">m</span>();</span><br></pre></td></tr></table></figure>
<p>Or, if m() expects two arguments, you might invoke it like this:</p>
<blockquote>
<p>或者 m() 需要两个实参，可以这样调用它：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o.<span class="title function_">m</span>(x, y);</span><br></pre></td></tr></table></figure>
<p>The code in this example is an invocation expression: it includes a function expression o.m and two argument expressions, x and y. The function expression is itself a property access expression, and this means that the function is invoked as a method rather than as a regular function.</p>
<blockquote>
<p>示例中的代码是一个调用表达式：它包含一个函数表达式 o.m 和两个实参表达式 x 和 y。函数表达式本身是一个属性访问表达式，这意味着该函数被当作一个方法调用，而不是一个普通的函数。</p>
</blockquote>
<p>The arguments and return value of a method invocation are handled exactly as described for regular function invocation. Method invocations differ from function invocations in one important way, however: the invocation context. Property access expressions consist of two parts: an object (in this case o) and a property name (m). In a method-invocation expression like this, the object o becomes the invocation context, and the function body can refer to that object by using the keyword this. Here is a concrete example:</p>
<blockquote>
<p>对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致。但是，方法调用和函数调用有一个重要的区别，即：调用上下文。属性访问表达式由两部分组成：一个对象（本例中的 o）和属性名称（m）。在像这样的方法调用表达式里，对象 o 成为调用上下文，函数体可以使用关键字this引用该对象。下面是一个具体的例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> calculator = &#123; <span class="comment">// An object literal</span></span><br><span class="line">    <span class="attr">operand1</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">operand2</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="title function_">add</span>(<span class="params"></span>) &#123;        <span class="comment">// We&#x27;re using method shorthand syntax for this function</span></span><br><span class="line">        <span class="comment">// Note the use of the this keyword to refer to the containing object.</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">result</span> = <span class="variable language_">this</span>.<span class="property">operand1</span> + <span class="variable language_">this</span>.<span class="property">operand2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">calculator.<span class="title function_">add</span>();  <span class="comment">// A method invocation to compute 1+1.</span></span><br><span class="line">calculator.<span class="property">result</span>  <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>
<p>Most method invocations use the dot notation for property access, but property access expressions that use square brackets also cause method invocation. The following are both method invocations, for example:</p>
<blockquote>
<p>大多数方法调用使用点符号来访问属性，使用方括号（属性访问表达式）也可以进行属性访问操作。下面两个例子都是函数调用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o[<span class="string">&quot;m&quot;</span>](x,y);   <span class="comment">// Another way to write o.m(x,y).</span></span><br><span class="line">a[<span class="number">0</span>](z)        <span class="comment">// Also a method invocation (assuming a[0] is a function).</span></span><br></pre></td></tr></table></figure>
<p>Method invocations may also involve more complex property access expressions:</p>
<blockquote>
<p>方法调用可能包括更复杂的属性访问表达式：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customer.<span class="property">surname</span>.<span class="title function_">toUpperCase</span>(); <span class="comment">// Invoke method on customer.surname</span></span><br><span class="line"><span class="title function_">f</span>().<span class="title function_">m</span>();                        <span class="comment">// Invoke method m() on return value of f()</span></span><br></pre></td></tr></table></figure>
<p>Methods and the this keyword are central to the object-oriented programming paradigm. Any function that is used as a method is effectively passed an implicit argument—the object through which it is invoked. Typically, a method performs some sort of operation on that object, and the method-invocation syntax is an elegant way to express the fact that a function is operating on an object. Compare the following two lines:</p>
<blockquote>
<p>方法和 this 关键字是面向对象编程范式的核心。任何函数只要作为方法调用实际上都会传入一个隐式的实参对象，就是调用这个方法对象本身。通常来讲，方法执行就是对象的某种操作，方法调用的语法也清晰的表达了它是操作对象的函数，比较下面两行代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rect.<span class="title function_">setSize</span>(width, height);</span><br><span class="line"><span class="title function_">setRectSize</span>(rect, width, height);</span><br></pre></td></tr></table></figure>
<p>The hypothetical functions invoked in these two lines of code may perform exactly the same operation on the (hypothetical) object rect, but the method-invocation syntax in the first line more clearly indicates the idea that it is the object rect that is the primary focus of the operation.</p>
<blockquote>
<p>我们假设这两行代码的功能完全一样，它们都作用于一个假定的对象 rect。可以看出，第一行的方法调用语法非常清晰地表明这个函数执行的载体是 rect 对象，函数中的所有操作都将基于这个对象。</p>
</blockquote>
<h4 id="METHOD-CHAINING"><a href="#METHOD-CHAINING" class="headerlink" title="METHOD CHAINING"></a>METHOD CHAINING</h4><p>When methods return objects, you can use the return value of one method invocation as part of a subsequent invocation. This results in a series (or “chain”) of method invocations as a single expression. When working with Promise-based asynchronous operations (see Chapter 13), for example, it is common to write code structured like this:</p>
<blockquote>
<p>当方法返回一个对象，这个对象还可以再调用它的方法。这种方法调用序列中（或“链”）每次的调用结果都是另外一个表达式的组成部分。比如，基于 Promise 的异步操作（参见第 13 章），我们常常会这样写代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run three asynchronous operations in sequence, handling errors.</span></span><br><span class="line"><span class="title function_">doStepOne</span>().<span class="title function_">then</span>(doStepTwo).<span class="title function_">then</span>(doStepThree).<span class="title function_">catch</span>(handleErrors);</span><br></pre></td></tr></table></figure>
<p>When you write a method that does not have a return value of its own, consider having the method return this. If you do this consistently throughout your API, you will enable a style of programming known as method chaining1 in which an object can be named once and then multiple methods can be invoked on it:</p>
<blockquote>
<p>当方法并不需要返回值时，最好直接返回 this。如果在设计的 API 中一直采用这种方式，使用 API 就可以用方法链 ^1 风格的编程，在这种编程风格中，只要指定一次要调用的对象即可，余下的方法都可以基于此进行调用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Square</span>().<span class="title function_">x</span>(<span class="number">100</span>).<span class="title function_">y</span>(<span class="number">100</span>).<span class="title function_">size</span>(<span class="number">50</span>).<span class="title function_">outline</span>(<span class="string">&quot;red&quot;</span>).<span class="title function_">fill</span>(<span class="string">&quot;blue&quot;</span>).<span class="title function_">draw</span>();</span><br></pre></td></tr></table></figure>
<p>Note that this is a keyword, not a variable or property name. JavaScript syntax does not allow you to assign a value to this.</p>
<blockquote>
<p>需要注意的是，this 是一个关键字，不是变量，也不是属性名。JavaScript 的语法不允许给 this 赋值。</p>
</blockquote>
<p>The this keyword is not scoped the way variables are, and, except for arrow functions, nested functions do not inherit the this value of the containing function. If a nested function is invoked as a method, its this value is the object it was invoked on. If a nested function (that is not an arrow function) is invoked as a function, then its this value will be either the global object (non-strict mode) or undefined (strict mode). It is a common mistake to assume that a nested function defined within a method and invoked as a function can use this to obtain the invocation context of the method. The following code demonstrates the problem:</p>
<blockquote>
<p>关键字 this 没有变量作用域的限制，除了箭头函数，嵌套函数不会从包含它的函数中继承 this。如果嵌套函数作为方法调用，其 this 的值指向调用它的对象。如果嵌套的函数作为函数调用（不包含箭头函数），其 this 值不是全局对象（非严格模式下）就是 undefined（严格模式下）。很多人误以为在一个方法中的函数声明并以函数调用的方式去执行可以用 this 来获取方法的执行上下文。下面这个例子说明了这个问题：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;                 <span class="comment">// An object o.</span></span><br><span class="line">    <span class="attr">m</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;       <span class="comment">// Method m of the object.</span></span><br><span class="line">        <span class="keyword">let</span> self = <span class="variable language_">this</span>;  <span class="comment">// Save the &quot;this&quot; value in a variable.</span></span><br><span class="line">        <span class="variable language_">this</span> === o        <span class="comment">// =&gt; true: &quot;this&quot; is the object o.</span></span><br><span class="line">        <span class="title function_">f</span>();              <span class="comment">// Now call the helper function f().</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;    <span class="comment">// A nested function f</span></span><br><span class="line">            <span class="variable language_">this</span> === o    <span class="comment">// =&gt; false: &quot;this&quot; is global or undefined</span></span><br><span class="line">            self === o    <span class="comment">// =&gt; true: self is the outer &quot;this&quot; value.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">o.<span class="title function_">m</span>();                    <span class="comment">// Invoke the method m on the object o.</span></span><br></pre></td></tr></table></figure>
<p>Inside the nested function f(), the this keyword is not equal to the object o. This is widely considered to be a flaw in the JavaScript language, and it is important to be aware of it. The code above demonstrates one common workaround. Within the method m, we assign the this value to a variable self, and within the nested function f, we can use self instead of this to refer to the containing object.</p>
<blockquote>
<p>嵌套函数 f() 中，this 关键之不等于对象 o。这被广泛的认为是 JavaScript 的一个缺陷，了解这一点是很是很重要的。上面的代码演示了一种常用的解决方案。在方法 m 中，将 this 值赋值给一个变量 self，在签到函数 f 中，可以用 self 代替 this 来引用包含它的对象。</p>
</blockquote>
<p>In ES6 and later, another workaround to this issue is to convert the nested function f into an arrow function, which will properly inherit the this value:</p>
<blockquote>
<p>在 ES6 之后，有另外一种解决方案来解决这个问题，将嵌套函数 f 转换成箭头函数，它会正确的继承 this 值：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">this</span> === o  <span class="comment">// true, since arrow functions inherit this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Functions defined as expressions instead of statements are not hoisted, so in order to make this code work, the function definition for f will need to be moved within the method m so that it appears before it is invoked.</p>
<blockquote>
<p>函数表达式不像函数声明，声明提前，所以为了让这种解决方案定义的函数可以被调用，需要将 f 函数定义表达式放在方法 m 中，这样它才可以在它被调用时存在。</p>
</blockquote>
<p>Another workaround is to invoke the bind() method of the nested function to define a new function that is implicitly invoked on a specified object:</p>
<blockquote>
<p>另外还可以用嵌套函数的 bind() 方法，在指定对象上隐式调用一个新的函数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span> === o  <span class="comment">// true, since we bound this function to the outer this</span></span><br><span class="line">&#125;).<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure>
<p>We’ll talk more about bind() in §8.7.5.</p>
<blockquote>
<p>关于 bind() 方法将在 §8.7.5 中讲解。</p>
</blockquote>
<h3 id="8-2-3-Constructor-Invocation"><a href="#8-2-3-Constructor-Invocation" class="headerlink" title="8.2.3 Constructor Invocation"></a>8.2.3 Constructor Invocation</h3><p>If a function or method invocation is preceded by the keyword new, then it is a constructor invocation. (Constructor invocations were introduced in §4.6 and §6.2.2, and constructors will be covered in more detail in Chapter 9.) Constructor invocations differ from regular function and method invocations in their handling of arguments, invocation context, and return value.</p>
<blockquote>
<p>如果函数或者方法调用之前带有关键字 new，它就构成构造函数调用（构造函数调用在 §4.6 和 §6.2.2 节有简单介绍，第 9 章会对构造函数做更详细的讨论）。构造函数调用和普通的函数调用以及方法调用在实参处理、调用上下文和返回值方面都有不同。</p>
</blockquote>
<p>If a constructor invocation includes an argument list in parentheses, those argument expressions are evaluated and passed to the function in the same way they would be for function and method invocations. It is not common practice, but you can omit a pair of empty parentheses in a constructor invocation. The following two lines, for example, are equivalent:</p>
<blockquote>
<p>如果构造函数调用在圆括号内包含一组实参列表，先计算这些实参表达式，然后传入函数内，这和函数调用和方法调用是一致的。但如果构造函数没有形参，JavaScript 构造函数调用的语法是允许省略实参列表和圆括号的。凡是没有形参的构造函数调用都可以省略圆括号，比如，下面这两行代码就是等价的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">o = <span class="keyword">new</span> <span class="title class_">Object</span>;</span><br></pre></td></tr></table></figure>
<p>A constructor invocation creates a new, empty object that inherits from the object specified by the prototype property of the constructor. Constructor functions are intended to initialize objects, and this newly created object is used as the invocation context, so the constructor function can refer to it with the this keyword. Note that the new object is used as the invocation context even if the constructor invocation looks like a method invocation. That is, in the expression new o.m(), o is not used as the invocation context.</p>
<blockquote>
<p>构造函数调用创建一个新的空对象，这个对象继承自构造函数的 prototype 属性。构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文，因此构造函数内可以使用 this 关键字来引用这个新创建的对象。注意，尽管构造函数看起来像一个方法调用，它依然会使用这个新对象作为调用上下文。也就是说，在表达式 new o.m() 中，调用上下文并不是 o。</p>
</blockquote>
<p>Constructor functions do not normally use the return keyword. They typically initialize the new object and then return implicitly when they reach the end of their body. In this case, the new object is the value of the constructor invocation expression. If, however, a constructor explicitly uses the return statement to return an object, then that object becomes the value of the invocation expression. If the constructor uses return with no value, or if it returns a primitive value, that return value is ignored and the new object is used as the value of the invocation.</p>
<blockquote>
<p>构造函数通常不使用 return 关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会隐式返回。在这种情况下，构造函数调用表达式的计算结果就是这个新对象的值。然而如果构造函数显式地使用 return 语句返回一个对象，那么调用表达式的值就是这个对象。如果构造函数使用 return 语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果。</p>
</blockquote>
<h3 id="8-2-4-Indirect-Invocation"><a href="#8-2-4-Indirect-Invocation" class="headerlink" title="8.2.4 Indirect Invocation"></a>8.2.4 Indirect Invocation</h3><p>JavaScript functions are objects, and like all JavaScript objects, they have methods. Two of these methods, call() and apply(), invoke the function indirectly. Both methods allow you to explicitly specify the this value for the invocation, which means you can invoke any function as a method of any object, even if it is not actually a method of that object. Both methods also allow you to specify the arguments for the invocation. The call() method uses its own argument list as arguments to the function, and the apply() method expects an array of values to be used as arguments. The call() and apply() methods are described in detail in §8.7.4.</p>
<blockquote>
<p>JavaScript 中的函数也是对象，和其他 JavaScript 对象没什么两样，函数对象也可以包含方法。其中的两个方法 call() 和 apply() 可以用来间接地调用函数。两个方法都允许显式指定调用所需的 this 值，也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。两个方法都可以指定调用的实参。call() 方法使用它自有的实参列表作为函数的实参，apply() 方法则要求以数组的形式传入实参。§8.7.4 节会有关于 call() 和apply () 方法的详细讨论。</p>
</blockquote>
<h3 id="8-2-5-Implicit-Function-Invocation"><a href="#8-2-5-Implicit-Function-Invocation" class="headerlink" title="8.2.5 Implicit Function Invocation"></a>8.2.5 Implicit Function Invocation</h3><p>There are various JavaScript language features that do not look like function invocations but that cause functions to be invoked. Be extra careful when writing functions that may be implicitly invoked, because bugs, side effects, and performance issues in these functions are harder to diagnose and fix than in regular functions for the simple reason that it may not be obvious from a simple inspection of your code when they are being called.</p>
<blockquote>
<p>有各种各样的 JavaScript 语言特性，它们看起来不像函数调用但是却能调用函数。额外小心编写函数时可能会隐式调用，因为在隐式函数调用中 bug、副作用和性能问题都比普通的函数更难诊断和修复。</p>
</blockquote>
<p>The language features that can cause implicit function invocation include:</p>
<blockquote>
<p>可能引起函数隐式调用的语言特性包括：</p>
</blockquote>
<p>If an object has getters or setters defined, then querying or setting the value of its properties may invoke those methods. See §6.10.6 for more information.</p>
<blockquote>
<p>如果一个对象定义了 getter 或者 setter 方法，获取或者设置它的属性值可能调用这些方法。见 §6.10.6 有更多相关描述。</p>
</blockquote>
<p>When an object is used in a string context (such as when it is concatenated with a string), its toString() method is called. Similarly, when an object is used in a numeric context, its valueOf() method is invoked. See §3.9.3 for details.</p>
<blockquote>
<p>当对象用作一个字符串文本时（例如对象和一个字符串连接），它的 toString() 方法会被调用。同样的，对象用作一个数值型文本时，它的 valueOf() 方法被调用。详见 §3.9.3。</p>
</blockquote>
<p>When you loop over the elements of an iterable object, there are a number of method calls that occur. Chapter 12 explains how iterators work at the function call level and demonstrates how to write these methods so that you can define your own iterable types.</p>
<blockquote>
<p>当循环可迭代对象的元素时会产生很多方法调用。第 12 章介绍了迭代器在函数调用级别如何工作，并演示如何编写方法来定义自己的可迭代类型。</p>
</blockquote>
<p>A tagged template literal is a function invocation in disguise. §14.5 demonstrates how to write functions that can be used in conjunction with template literal strings.</p>
<blockquote>
<p>可以伪装在模板字面量中 。在 §14.5 中演示如何在模板字符串中调用函数。</p>
</blockquote>
<p>Proxy objects (described in §14.7) have their behavior completely controlled by functions. Just about any operation on one of these objects will cause a function to be invoked.</p>
<blockquote>
<p>Proxy 对象（在 §14.7 中描述）的行为完全由函数控制。它的任何一个操作都会导致函数调用。</p>
</blockquote>
<h2 id="8-3-Function-Arguments-and-Parameters"><a href="#8-3-Function-Arguments-and-Parameters" class="headerlink" title="8.3 Function Arguments and Parameters"></a>8.3 Function Arguments and Parameters</h2><p>JavaScript function definitions do not specify an expected type for the function parameters, and function invocations do not do any type checking on the argument values you pass. In fact, JavaScript function invocations do not even check the number of arguments being passed. The subsections that follow describe what happens when a function is invoked with fewer arguments than declared parameters or with more arguments than declared parameters. They also demonstrate how you can explicitly test the type of function arguments if you need to ensure that a function is not invoked with inappropriate arguments.</p>
<blockquote>
<p>JavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。下面几节将会讨论当调用函数时的实参个数和声明的形参个数不匹配时出现的状况，同样介绍了如何显式测试函数实参的类型，以避免非法的实参传入函数。</p>
</blockquote>
<h3 id="8-3-1-Optional-Parameters-and-Defaults"><a href="#8-3-1-Optional-Parameters-and-Defaults" class="headerlink" title="8.3.1 Optional Parameters and Defaults"></a>8.3.1 Optional Parameters and Defaults</h3><p>When a function is invoked with fewer arguments than declared parameters, the additional parameters are set to their default value, which is normally undefined. It is often useful to write functions so that some arguments are optional. Following is an example:</p>
<blockquote>
<p>当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为 undefined 值。所以一些参数设置成可选的是非常实用的。看下面这个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Append the names of the enumerable properties of object o to the</span></span><br><span class="line"><span class="comment">// array a, and return a.  If a is omitted, create and return a new array.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPropertyNames</span>(<span class="params">o, a</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a === <span class="literal">undefined</span>) a = [];  <span class="comment">// If undefined, use a new array</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> property <span class="keyword">in</span> o) a.<span class="title function_">push</span>(property);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getPropertyNames() can be invoked with one or two arguments:</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, p = &#123;<span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>&#125;;  <span class="comment">// Two objects for testing</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="title function_">getPropertyNames</span>(o); <span class="comment">// a == [&quot;x&quot;]; get o&#x27;s properties in a new array</span></span><br><span class="line"><span class="title function_">getPropertyNames</span>(p, a);      <span class="comment">// a == [&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]; add p&#x27;s properties to it</span></span><br></pre></td></tr></table></figure>
<p>Instead of using an if statement in the first line of this function, you can use the || operator in this idiomatic way:</p>
<blockquote>
<p>第一行代码中可以使用 || 运算符来代替一个 if 语句，这是一种习惯用法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a || [];</span><br></pre></td></tr></table></figure>
<p>Recall from §4.10.2 that the || operator returns its first argument if that argument is truthy and otherwise returns its second argument. In this case, if any object is passed as the second argument, the function will use that object. But if the second argument is omitted (or null or another falsy value is passed), a newly created empty array will be used instead.</p>
<blockquote>
<p>回忆一下，§4.10.2 介绍了“||”运算符，如果第一个实参是真值的话就返回第一个实参；否则返回第二个实参。在这个场景下，如果作为第二个实参传入任意对象，那么函数就会使用这个对象。如果省略掉第二个实参（或者传递 null 以及其他任何假值），那么就新创建一个空数组，并赋值给 a。</p>
</blockquote>
<p>Note that when designing functions with optional arguments, you should be sure to put the optional ones at the end of the argument list so that they can be omitted. The programmer who calls your function cannot omit the first argument and pass the second: they would have to explicitly pass undefined as the first argument.</p>
<blockquote>
<p>需要注意的是，当用这种可选实参来实现函数时，需要将可选实参放在实参列表的最后。那些调用你的函数的程序员是没办法省略第一个实参并传入第二个实参，他们必须显地的将 undefined 传入作为第一个实参 。</p>
</blockquote>
<p>In ES6 and later, you can define a default value for each of your function parameters directly in the parameter list of your function. Simply follow the parameter name with an equals sign and the default value to use when no argument is supplied for that parameter:</p>
<blockquote>
<p>在 ES6 之后，可以直接在函数的参数列表中为每个函数参数定义默认值。直接在参数名后面接一个等号再接一个默认值（用于没有实参提供给参数时参数的值）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Append the names of the enumerable properties of object o to the</span></span><br><span class="line"><span class="comment">// array a, and return a.  If a is omitted, create and return a new array.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPropertyNames</span>(<span class="params">o, a = []</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> property <span class="keyword">in</span> o) a.<span class="title function_">push</span>(property);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Parameter default expressions are evaluated when your function is called, not when it is defined, so each time this getPropertyNames() function is invoked with one argument, a new empty array is created and passed.2 It is probably easiest to reason about functions if the parameter defaults are constants (or literal expressions like [] and {}). But this is not required: you can use variables, or function invocations, for example, to compute the default value of a parameter. One interesting case is that, for functions with multiple parameters, you can use the value of a previous parameter to define the default value of the parameters that follow it:</p>
<blockquote>
<p>默认参数表达式只有在函数调用时进行计算，而不是在它定义时，所以每一次 getPropertyNames() 函数只传一个实参调用时，一个新的空数组被创建并传给参数。2 最容易理解的就是参数默认值是常量（或者字面量表达式 [] 和 {}）。但这并不是必须的：举个例子，你可以用变量或者函数调用，计算一个默认参数的值。一个很有趣的情况是，对于有多个参数的函数，可以用前面的参数值来定义后面的参数默认值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function returns an object representing a rectangle&#x27;s dimensions.</span></span><br><span class="line"><span class="comment">// If only width is supplied, make it twice as high as it is wide.</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">rectangle</span> = (<span class="params">width, height=width*<span class="number">2</span></span>) =&gt; (&#123;width, height&#125;);</span><br><span class="line"><span class="title function_">rectangle</span>(<span class="number">1</span>)  <span class="comment">// =&gt; &#123; width: 1, height: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>This code demonstrates that parameter defaults work with arrow functions. The same is true for method shorthand functions and all other forms of function definitions.</p>
<blockquote>
<p>这段代码描述了箭头函数中的参数默认值。方法函数和其他形式的函数定义也是如此。</p>
</blockquote>
<h3 id="8-3-2-Rest-Parameters-and-Variable-Length-Argument-Lists"><a href="#8-3-2-Rest-Parameters-and-Variable-Length-Argument-Lists" class="headerlink" title="8.3.2 Rest Parameters and Variable-Length Argument Lists"></a>8.3.2 Rest Parameters and Variable-Length Argument Lists</h3><p>Parameter defaults enable us to write functions that can be invoked with fewer arguments than parameters. Rest parameters enable the opposite case: they allow us to write functions that can be invoked with arbitrarily more arguments than parameters. Here is an example function that expects one or more numeric arguments and returns the largest one:</p>
<blockquote>
<p>调用函数时允许传入的实参比函数声明时指定的形参个数少。剩余参数允许相反的情况：它允许我们在调用函数时，传入比型参多任意个数的实参。下面是一个可以传入一个或多个数值型实参的例子，并且返回其中最大的数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">max</span>(<span class="params">first=-<span class="literal">Infinity</span>, ...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxValue = first; <span class="comment">// Start by assuming the first arg is biggest</span></span><br><span class="line">    <span class="comment">// Then loop through the rest of the arguments, looking for bigger</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> n <span class="keyword">of</span> rest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; maxValue) &#123;</span><br><span class="line">            maxValue = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return the biggest</span></span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">max</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)  <span class="comment">// =&gt; 1000</span></span><br></pre></td></tr></table></figure>
<p>A rest parameter is preceded by three periods, and it must be the last parameter in a function declaration. When you invoke a function with a rest parameter, the arguments you pass are first assigned to the non-rest parameters, and then any remaining arguments (i.e., the “rest” of the arguments) are stored in an array that becomes the value of the rest parameter. This last point is important: within the body of a function, the value of a rest parameter will always be an array. The array may be empty, but a rest parameter will never be undefined. (It follows from this that it is never useful—and not legal—to define a parameter default for a rest parameter.)</p>
<blockquote>
<p>剩余参数由三个 . 开始，必须是函数声明的最后一个参数。调用有剩余参数的函数时，传递的实参先赋值给非剩余参数，然后其余所有的实参（也就是“剩余”实参）存储在一个数组中变成剩余参数的值，最后一点非常重要：在一个函数体中，剩余参数的值总是一个数组。这个数组可能是空的，但是剩余参数永远不会是 undefined。（因此，从不会给剩余参数设置默认值，并且这也是不合法的。）</p>
</blockquote>
<p>Functions like the previous example that can accept any number of arguments are called variadic functions, variable arity functions, or vararg functions. This book uses the most colloquial term, varargs, which dates to the early days of the C programming language.</p>
<blockquote>
<p>类似这种函数可以接收任意个数的实参，这种函数也称为“不定实参函数”，这个术语源自古老的C语言。</p>
</blockquote>
<p>Don’t confuse the … that defines a rest parameter in a function definition with the … spread operator, described in §8.3.4, which can be used in function invocations.</p>
<blockquote>
<p>不要混淆 … 定义函数的剩余参数和 … 展开运算符，将在 §8.3.4 描述展开运算符在函数调用中的应用。</p>
</blockquote>
<h3 id="8-3-3-The-Arguments-Object"><a href="#8-3-3-The-Arguments-Object" class="headerlink" title="8.3.3 The Arguments Object"></a>8.3.3 The Arguments Object</h3><p>Rest parameters were introduced into JavaScript in ES6. Before that version of the language, varargs functions were written using the Arguments object: within the body of any function, the identifier arguments refers to the Arguments object for that invocation. The Arguments object is an array-like object (see §7.9) that allows the argument values passed to the function to be retrieved by number, rather than by name. Here is the max() function from earlier, rewritten to use the Arguments object instead of a rest parameter:</p>
<blockquote>
<p>剩余参数是在 ES6 中加入的概念。在这之前，不定实参函数是用 Arguments 对象实现的：在函数体中，标识符 Arguments 是指向实参对象的引用。Arguments 对象是一个类数组对象（参照 §7.9），这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。下面的 max() 函数就是以前用 Arguments 对象代替剩余参数的例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">max</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> maxValue = -<span class="title class_">Infinity</span>;</span><br><span class="line">    <span class="comment">// Loop through the arguments, looking for, and remembering, the biggest.</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">arguments</span>[i] &gt; maxValue) maxValue = <span class="variable language_">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Return the biggest</span></span><br><span class="line">    <span class="keyword">return</span> maxValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">max</span>(<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)  <span class="comment">// =&gt; 1000</span></span><br></pre></td></tr></table></figure>
<p>The Arguments object dates back to the earliest days of JavaScript and carries with it some strange historical baggage that makes it inefficient and hard to optimize, especially outside of strict mode. You may still encounter code that uses the Arguments object, but you should avoid using it in any new code you write. When refactoring old code, if you encounter a function that uses arguments, you can often replace it with a …args rest parameter. Part of the unfortunate legacy of the Arguments object is that, in strict mode, arguments is treated as a reserved word, and you cannot declare a function parameter or a local variable with that name.</p>
<blockquote>
<p>Arguments 对象可追溯到 JavaScript 的最早时代，并带有一些奇怪的历史包袱，这使得它效率低下且难以优化，尤其是不在严格模式下。可能还会遇到一些代码使用 Arguments 对象，但是在编写新代码时要避免使用，可以用 … 剩余函数来替代。Arguments 对象还有部分令人遗憾的遗产，在严格模式下，arguments 被视为保留字，不能声明具有该名称的局部变量来定义函数的参数。</p>
</blockquote>
<h3 id="8-3-4-The-Spread-Operator-for-Function-Calls"><a href="#8-3-4-The-Spread-Operator-for-Function-Calls" class="headerlink" title="8.3.4 The Spread Operator for Function Calls"></a>8.3.4 The Spread Operator for Function Calls</h3><p>The spread operator … is used to unpack, or “spread out,” the elements of an array (or any other iterable object, such as strings) in a context where individual values are expected. We’ve seen the spread operator used with array literals in §7.1.2. The operator can be used, in the same way, in function invocations:</p>
<blockquote>
<p>当需要单个值时，… 展开运算符用来拆包，或者说将元素从数组（或者其他的任何和迭代对象，例如字符串）中“展开”到上下文。我们已经在 §7.1.2 见到了展开运算符在数组字面量上的使用。展开运算符可以在函数调用中以同样方式使用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">10</span>, -<span class="number">1</span>, <span class="number">9</span>, <span class="number">100</span>, <span class="number">1</span>];</span><br><span class="line"><span class="title class_">Math</span>.<span class="title function_">min</span>(...numbers)  <span class="comment">// =&gt; -1</span></span><br></pre></td></tr></table></figure>
<p>Note that … is not a true operator in the sense that it cannot be evaluated to produce a value. Instead, it is a special JavaScript syntax that can be used in array literals and function invocations.</p>
<blockquote>
<p>注意 … 不是一个真正的运算符，因为它不能通过计算来提供一个值。它是一个可以用在数组字面量和函数调用中的特殊的 JavaScript 语法。</p>
</blockquote>
<p>When we use the same … syntax in a function definition rather than a function invocation, it has the opposite effect to the spread operator. As we saw in §8.3.2, using … in a function definition gathers multiple function arguments into an array. Rest parameters and the spread operator are often useful together, as in the following function, which takes a function argument and returns an instrumented version of the function for testing: </p>
<blockquote>
<p>在函数定义和函数调用中使用相同的 … 语法时，和展开运算符有着相仿的效果。在 §8.3.2 中我们看到函数定义使用 … 将复数个函数实参合并到一个数组中。剩余参数和展开运算符经常一同使用，就像下面这个函数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function takes a function and returns a wrapped version</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timed</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;  <span class="comment">// Collect args into a rest parameter array</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Entering function <span class="subst">$&#123;f.name&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">let</span> startTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Pass all of our arguments to the wrapped function</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">f</span>(...args);  <span class="comment">// Spread the args back out again</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Before we return the wrapped return value, print elapsed time.</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Exiting <span class="subst">$&#123;f.name&#125;</span> after <span class="subst">$&#123;<span class="built_in">Date</span>.now()-startTime&#125;</span>ms`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute the sum of the numbers between 1 and n by brute force</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">benchmark</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now invoke the timed version of that test function</span></span><br><span class="line"><span class="title function_">timed</span>(benchmark)(<span class="number">1000000</span>) <span class="comment">// =&gt; 500000500000; this is the sum of the numbers</span></span><br></pre></td></tr></table></figure>
<h3 id="8-3-5-Destructuring-Function-Arguments-into-Parameters"><a href="#8-3-5-Destructuring-Function-Arguments-into-Parameters" class="headerlink" title="8.3.5 Destructuring Function Arguments into Parameters"></a>8.3.5 Destructuring Function Arguments into Parameters</h3><p>When you invoke a function with a list of argument values, those values end up being assigned to the parameters declared in the function definition. This initial phase of function invocation is a lot like variable assignment. So it should not be surprising that we can use the techniques of destructuring assignment (see §3.10.3) with functions.</p>
<blockquote>
<p>用实参列表调用函数时，实参的值最终赋值给函数定义的参数。函数调用初始化阶段非常像变量赋值。所以我们不必惊讶于可以将解构赋值（见 §3.10.3）用于函数。</p>
</blockquote>
<p>If you define a function that has parameter names within square brackets, you are telling the function to expect an array value to be passed for each pair of square brackets. As part of the invocation process, the array arguments will be unpacked into the individually named parameters. As an example, suppose we are representing 2D vectors as arrays of two numbers, where the first element is the X coordinate and the second element is the Y coordinate. With this simple data structure, we could write the following function to add two vectors:</p>
<blockquote>
<p>如果一个函数的参数带有方括号，就说明函数要给每一个方括号传一个数组。在一个调用进程中，数组实参会被拆包传递给对应的参数。例如，假设我们将 2D 矢量表示为两个数字的数组，其中第一个元素是 X 坐标，第二个元素是 Y 坐标。用这个简单的数据结构，编写下面这个函数计算两个矢量的和：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vectorAdd</span>(<span class="params">v1, v2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [v1[<span class="number">0</span>] + v2[<span class="number">0</span>], v1[<span class="number">1</span>] + v2[<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorAdd</span>([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>])  <span class="comment">// =&gt; [4,6]</span></span><br></pre></td></tr></table></figure>
<p>The code would be easier to understand if we destructured the two vector arguments into more clearly named parameters:</p>
<blockquote>
<p>如果下面这种方式解构这两个矢量实参，这段代码将更容易理解：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vectorAdd</span>(<span class="params">[x1,y1], [x2,y2]</span>) &#123; <span class="comment">// Unpack 2 arguments into 4 parameters</span></span><br><span class="line">    <span class="keyword">return</span> [x1 + x2, y1 + y2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorAdd</span>([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>])  <span class="comment">// =&gt; [4,6]</span></span><br></pre></td></tr></table></figure>
<p>Similarly, if you are defining a function that expects an object argument, you can destructure parameters of that object. Let’s use a vector example again, except this time, let’s suppose that we represent vectors as objects with x and y parameters:</p>
<blockquote>
<p>同样，如果定义一个函数时需要对象实参，你能对这个对象进行参数解构。再次实用矢量的例子，这一次，我们用 x 和 y 参数包装成对象来描述矢量：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Multiply the vector &#123;x,y&#125; by a scalar value</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vectorMultiply</span>(<span class="params">&#123;x, y&#125;, scalar</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x*scalar, <span class="attr">y</span>: y*scalar &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorMultiply</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, <span class="number">2</span>)  <span class="comment">// =&gt; &#123;x: 2, y: 4&#125;</span></span><br></pre></td></tr></table></figure>
<p>This example of destructuring a single object argument into two parameters is a fairly clear one because the parameter names we use match the property names of the incoming object. The syntax is more verbose and more confusing when you need to destructure properties with one name into parameters with different names. Here’s the vector addition example, implemented for object-based vectors:</p>
<blockquote>
<p>这个例子将一个简单的对象实参解构成两个参数是很简单的，因为参数的名字和我们在对象中使用的属性名是匹配的。当您需要将同一个名称的属性解构为具有不同名称的参数时，语法更加冗长和难懂。下面是一个矢量加法的例子，基于对象矢量的实现：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">vectorAdd</span>(<span class="params"></span></span><br><span class="line"><span class="params">    &#123;x: x1, y: y1&#125;, <span class="comment">// Unpack 1st object into x1 and y1 params</span></span></span><br><span class="line"><span class="params">    &#123;x: x2, y: y2&#125;  <span class="comment">// Unpack 2nd object into x2 and y2 params</span></span></span><br><span class="line"><span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x1 + x2, <span class="attr">y</span>: y1 + y2 &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorAdd</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, &#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span>&#125;)  <span class="comment">// =&gt; &#123;x: 4, y: 6&#125;</span></span><br></pre></td></tr></table></figure>
<p>The tricky thing about destructuring syntax like {x:x1, y:y1} is remembering which are the property names and which are the parameter names. The rule to keep in mind for destructuring assignment and destructuring function calls is that the variables or parameters being declared go in the spots where you’d expect values to go in an object literal. So property names are always on the lefthand side of the colon, and the parameter (or variable) names are on the right.</p>
<blockquote>
<p>像 {x:x1, y:y1} 的解构语法棘手的是记住哪一个是属性名哪一个是参数名。牢记解构赋值和解构函数调用的规则，声明的变量或参数在对象字面量中的位置固定。属性名总是在冒号的左边，参数（或变量）名在右边。</p>
</blockquote>
<p>You can define parameter defaults with destructured parameters. Here’s vector multiplication that works with 2D or 3D vectors:</p>
<blockquote>
<p>可以使用解构参数定义参数默认值。下面是适用于 2D 或 3D 矢量的矢量乘法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Multiply the vector &#123;x,y&#125; or &#123;x,y,z&#125; by a scalar value</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vectorMultiply</span>(<span class="params">&#123;x, y, z=<span class="number">0</span>&#125;, scalar</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x*scalar, <span class="attr">y</span>: y*scalar, <span class="attr">z</span>: z*scalar &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorMultiply</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;, <span class="number">2</span>)  <span class="comment">// =&gt; &#123;x: 2, y: 4, z: 0&#125;</span></span><br></pre></td></tr></table></figure>
<p>Some languages (like Python) allow the caller of a function to invoke a function with arguments specified in name&#x3D;value form, which is convenient when there are many optional arguments or when the parameter list is long enough that it is hard to remember the correct order. JavaScript does not allow this directly, but you can approximate it by destructuring an object argument into your function parameters. Consider a function that copies a specified number of elements from one array into another array with optionally specified starting offsets for each array. Since there are five possible parameters, some of which have defaults, and it would be hard for a caller to remember which order to pass the arguments in, we can define and invoke the arraycopy() function like this:</p>
<blockquote>
<p>一些语言（像 Python）允许函数的调用者以 name&#x3D;value 型式指定实参，这在有很多可选实参或者参数列表长到难以记住正确的顺序时是非常方便的。JavaScript 不允许直接这样做，但可以通过解构对象实参到函数参数中。构思一个函数将指定数量的元素从一个数组复制到另一个数组中，可以随意地为每个数组指定起始偏移量。如下有五个可传入参数，其中一些有默认值，并且调用者很难记住参数的顺序来传递实参，可以像这样定义和调用 arraycopy() 方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraycopy</span>(<span class="params">&#123;<span class="keyword">from</span>, to=<span class="keyword">from</span>, n=<span class="keyword">from</span>.length, fromIndex=<span class="number">0</span>, toIndex=<span class="number">0</span>&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> valuesToCopy = <span class="keyword">from</span>.<span class="title function_">slice</span>(fromIndex, fromIndex + n);</span><br><span class="line">    to.<span class="title function_">splice</span>(toIndex, <span class="number">0</span>, ...valuesToCopy);</span><br><span class="line">    <span class="keyword">return</span> to;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>], b = [<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">arraycopy</span>(&#123;<span class="attr">from</span>: a, <span class="attr">n</span>: <span class="number">3</span>, <span class="attr">to</span>: b, <span class="attr">toIndex</span>: <span class="number">4</span>&#125;) <span class="comment">// =&gt; [9,8,7,6,1,2,3,5]</span></span><br></pre></td></tr></table></figure>
<p>When you destructure an array, you can define a rest parameter for extra values within the array that is being unpacked. That rest parameter within the square brackets is completely different than the true rest parameter for the function:</p>
<blockquote>
<p>当解构一个数组，在其被拆包时，可以定义一个剩余参数将其余值放在数组中。 在方括号中的剩余参数和真正的函数中的剩余参数是完全不同的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function expects an array argument. The first two elements of that</span></span><br><span class="line"><span class="comment">// array are unpacked into the x and y parameters. Any remaining elements</span></span><br><span class="line"><span class="comment">// are stored in the coords array. And any arguments after the first array</span></span><br><span class="line"><span class="comment">// are packed into the rest array.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">[x, y, ...coords], ...rest</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [x+y, ...rest, ...coords];  <span class="comment">// Note: spread operator here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>)   <span class="comment">// =&gt; [3, 5, 6, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>In ES2018, you can also use a rest parameter when you destructure an object. The value of that rest parameter will be an object that has any properties that did not get destructured. Object rest parameters are often useful with the object spread operator, which is also a new feature of ES2018:</p>
<blockquote>
<p>在 ES2018，也可以用剩余参数解构对象。剩余参数是一个没有解构的属性的对象。对象剩余参数经常与对象展开运算符连用，这是 ES2018 的新特性：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Multiply the vector &#123;x,y&#125; or &#123;x,y,z&#125; by a scalar value, retain other props</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">vectorMultiply</span>(<span class="params">&#123;x, y, z=<span class="number">0</span>, ...props&#125;, scalar</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">x</span>: x*scalar, <span class="attr">y</span>: y*scalar, <span class="attr">z</span>: z*scalar, ...props &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">vectorMultiply</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">w</span>: -<span class="number">1</span>&#125;, <span class="number">2</span>)  <span class="comment">// =&gt; &#123;x: 2, y: 4, z: 0, w: -1&#125;</span></span><br></pre></td></tr></table></figure>
<p>Finally, keep in mind that, in addition to destructuring argument objects and arrays, you can also destructure arrays of objects, objects that have array properties, and objects that have object properties, to essentially any depth. Consider graphics code that represents circles as objects with x, y, radius, and color properties, where the color property is an array of red, green, and blue color components. You might define a function that expects a single circle object to be passed to it but destructures that circle object into six separate parameters:</p>
<blockquote>
<p>最后，请记住，除了可以解构实参对象和数组，也可以解构数组对象，对象有数组属性，并且对象还有对象的属性。构思一个将圆表示为具有 x、y、半径和颜色属性的对象的图形代码，颜色属性是一个数组由 RGB 组成。你可以定义一个函数，该函数希望将单个圆对象传递给它，但其解构为六个单独的参数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">drawCircle</span>(<span class="params">&#123;x, y, radius, color: [r, g, b]&#125;</span>) &#123;</span><br><span class="line">    <span class="comment">// Not yet implemented</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If function argument destructuring is any more complicated than this, I find that the code becomes harder to read, rather than simpler. Sometimes, it is clearer to be explicit about your object property access and array indexing.</p>
<blockquote>
<p>如果函数实参解构比这更复杂，代码会变得更难读，而不是更简单。有时，显示地对对象属性访问和数组索引会让代码更清晰。</p>
</blockquote>
<h3 id="8-3-6-Argument-Types"><a href="#8-3-6-Argument-Types" class="headerlink" title="8.3.6 Argument Types"></a>8.3.6 Argument Types</h3><p>JavaScript method parameters have no declared types, and no type checking is performed on the values you pass to a function. You can help make your code self-documenting by choosing descriptive names for function arguments and by documenting them carefully in the comments for each function. (Alternatively, see §17.8 for a language extension that allows you to layer type checking on top of regular JavaScript.)</p>
<blockquote>
<p>JavaScript 方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名，并在函数注释给每一个实参详细描述，以此使代码自文本化。</p>
</blockquote>
<p>As described in §3.9, JavaScript performs liberal type conversion as needed. So if you write a function that expects a string argument and then call that function with a value of some other type, the value you passed will simply be converted to a string when the function tries to use it as a string. All primitive types can be converted to strings, and all objects have toString() methods (if not necessarily useful ones), so an error never occurs in this case.</p>
<blockquote>
<p>§3.9 已经提到，JavaScript 在必要时会进行类型转换。因此如果函数期 望接收一个字符串实参，而调用函数时传入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。所有的原始类型都可以转换为字符串，所有的对象都包含 toString() 方法（尽管不一定有用），所以这种场景下是不会有任何错误的。</p>
</blockquote>
<p>This is not always true, however. Consider again the arraycopy() method shown earlier. It expects one or two array arguments and will fail if these arguments are of the wrong type. Unless you are writing a private function that will only be called from nearby parts of your code, it may be worth adding code to check the types of arguments like this. It is better for a function to fail immediately and predictably when passed bad values than to begin executing and fail later with an error message that is likely to be unclear. Here is an example function that performs type-checking:</p>
<blockquote>
<p>然而事情不总是这样，回头看一下刚才提到的 arraycopy() 方法。这个方法期望获得一个或两个实参，并且这些实参的类型错误会导致函数执行失败。除非所写的私有函数只会被附近的代码调用，你应当添加类似的实参类型检查逻辑。因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错，相比而言，逻辑执行时的报错消息不甚清晰且更难处理。下面这个例子中的函数就做了这种类型检查：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the sum of the elements an iterable object a.</span></span><br><span class="line"><span class="comment">// The elements of a must all be numbers.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> a) &#123; <span class="comment">// Throws TypeError if a is not iterable</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> element !== <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;sum(): elements must be numbers&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        total += element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])    <span class="comment">// =&gt; 6</span></span><br><span class="line"><span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);   <span class="comment">// !TypeError: 1 is not iterable</span></span><br><span class="line"><span class="title function_">sum</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="string">&quot;3&quot;</span>]); <span class="comment">// !TypeError: element 2 is not a number</span></span><br></pre></td></tr></table></figure>
<h2 id="8-4-Functions-as-Values"><a href="#8-4-Functions-as-Values" class="headerlink" title="8.4 Functions as Values"></a>8.4 Functions as Values</h2><p>The most important features of functions are that they can be defined and invoked. Function definition and invocation are syntactic features of JavaScript and of most other programming languages. In JavaScript, however, functions are not only syntax but also values, which means they can be assigned to variables, stored in the properties of objects or the elements of arrays, passed as arguments to functions, and so on.3</p>
<blockquote>
<p>函数可以定义，也可以调用，这是函数最重要的特性。函数定义和调用是  JavaScript 的词法特性，对于其他大多数编程语言来说亦是如此。然而在 JavaScript 中，函数不仅是一种语法，也是值，也就是说，可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数等。3</p>
</blockquote>
<p>To understand how functions can be JavaScript data as well as JavaScript syntax, consider this function definition:</p>
<blockquote>
<p>为了便于理解 JavaScript 中的函数是如何用做 Javascript 数据以及 JavaScript 语法的，来看一下这样一个函数定义：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x*x; &#125;</span><br></pre></td></tr></table></figure>
<p>This definition creates a new function object and assigns it to the variable square. The name of a function is really immaterial; it is simply the name of a variable that refers to the function object. The function can be assigned to another variable and still work the same way:</p>
<blockquote>
<p>这个定义创建一个新的函数对象，并将其赋值给变量 square。函数的名字实际上是无形的，它（square）仅仅是变量的名称，这个变量是函数对象的引用。函数还可以赋值给其他的变量，并且仍可以正常工作：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = square;  <span class="comment">// Now s refers to the same function that square does</span></span><br><span class="line"><span class="title function_">square</span>(<span class="number">4</span>)        <span class="comment">// =&gt; 16</span></span><br><span class="line"><span class="title function_">s</span>(<span class="number">4</span>)             <span class="comment">// =&gt; 16</span></span><br></pre></td></tr></table></figure>
<p>Functions can also be assigned to object properties rather than variables. As we’ve already discussed, we call the functions “methods” when we do this:</p>
<blockquote>
<p>除了可以将函数赋值给变量，同样可以将函数赋值给对象的属性。当函数作为对象的属性调用时，函数就称为“方法”：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">square</span>: <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x*x; &#125;&#125;; <span class="comment">// An object literal</span></span><br><span class="line"><span class="keyword">let</span> y = o.<span class="title function_">square</span>(<span class="number">16</span>);                          <span class="comment">// y == 256</span></span><br></pre></td></tr></table></figure>
<p>Functions don’t even require names at all, as when they’re assigned to array elements:</p>
<blockquote>
<p>函数甚至不需要带名字，就像把它们赋值给数组元素：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="function"><span class="params">x</span> =&gt;</span> x*x, <span class="number">20</span>]; <span class="comment">// An array literal</span></span><br><span class="line">a[<span class="number">0</span>](a[<span class="number">1</span>])              <span class="comment">// =&gt; 400</span></span><br></pre></td></tr></table></figure>
<p>The syntax of this last example looks strange, but it is still a legal function invocation expression!</p>
<blockquote>
<p>上面的例子看起来很奇怪，但的确是合法的函数调用表达式！</p>
</blockquote>
<p>As an example of how useful it is to treat functions as values, consider the Array.sort() method. This method sorts the elements of an array. Because there are many possible orders to sort by (numerical order, alphabetical order, date order, ascending, descending, and so on), the sort() method optionally takes a function as an argument to tell it how to perform the sort. This function has a simple job: for any two values it is passed, it returns a value that specifies which element would come first in a sorted array. This function argument makes Array.sort() perfectly general and infinitely flexible; it can sort any type of data into any conceivable order. Examples are shown in §7.8.6.</p>
<blockquote>
<p>举一个例子来说明将函数当作值来对待的益处，考虑下 Array.sort() 方法。这个方法用来对数组元素进行排序。因为排序的规则有很多（基于数值大小、字母表顺序、日期大小、从小到大、从大到小等），sort() 方法可以接收一个函数作为参数，用来处理具体的排序操作。这个函数的作用非常简单：对于任意两个值都返回一个值，以指定它们在排序后的数组中的先后顺序。这个函数参数使得 Array.sort() 具有更完美的通用性和无限可扩展性，它可以对任何类型的数据进行任意排序。§7.8.6 有示例代码。</p>
</blockquote>
<p>Example 8-1 demonstrates the kinds of things that can be done when functions are used as values. This example may be a little tricky, but the comments explain what is going on.</p>
<blockquote>
<p>示例 8-1 展示了将函数用做值时的一些例子，这段代码可能会难读一些，但注释解释了代码的具体含义：</p>
</blockquote>
<p>Example 8-1. Using functions as data</p>
<blockquote>
<p>示例 8-1：用函数做值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We define some simple functions here</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y</span>) &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">subtract</span>(<span class="params">x,y</span>) &#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x,y</span>) &#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">divide</span>(<span class="params">x,y</span>) &#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here&#x27;s a function that takes one of the preceding functions</span></span><br><span class="line"><span class="comment">// as an argument and invokes it on two operands</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">operate</span>(<span class="params">operator, operand1, operand2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">operator</span>(operand1, operand2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We could invoke this function like this to compute the value (2+3) + (4*5):</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="title function_">operate</span>(add, <span class="title function_">operate</span>(add, <span class="number">2</span>, <span class="number">3</span>), <span class="title function_">operate</span>(multiply, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// For the sake of the example, we implement the simple functions again,</span></span><br><span class="line"><span class="comment">// this time within an object literal;</span></span><br><span class="line"><span class="keyword">const</span> operators = &#123;</span><br><span class="line">    <span class="attr">add</span>:      <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y,</span><br><span class="line">    <span class="attr">subtract</span>: <span class="function">(<span class="params">x,y</span>) =&gt;</span> x-y,</span><br><span class="line">    <span class="attr">multiply</span>: <span class="function">(<span class="params">x,y</span>) =&gt;</span> x*y,</span><br><span class="line">    <span class="attr">divide</span>:   <span class="function">(<span class="params">x,y</span>) =&gt;</span> x/y,</span><br><span class="line">    <span class="attr">pow</span>:      <span class="title class_">Math</span>.<span class="property">pow</span>  <span class="comment">// This works for predefined functions too</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes the name of an operator, looks up that operator</span></span><br><span class="line"><span class="comment">// in the object, and then invokes it on the supplied operands. Note</span></span><br><span class="line"><span class="comment">// the syntax used to invoke the operator function.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">operate2</span>(<span class="params">operation, operand1, operand2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> operators[operation] === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> operators[operation](operand1, operand2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="string">&quot;unknown operator&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">operate2</span>(<span class="string">&quot;add&quot;</span>, <span class="string">&quot;hello&quot;</span>, <span class="title function_">operate2</span>(<span class="string">&quot;add&quot;</span>, <span class="string">&quot; &quot;</span>, <span class="string">&quot;world&quot;</span>)) <span class="comment">// =&gt; &quot;hello world&quot;</span></span><br><span class="line"><span class="title function_">operate2</span>(<span class="string">&quot;pow&quot;</span>, <span class="number">10</span>, <span class="number">2</span>)  <span class="comment">// =&gt; 100</span></span><br></pre></td></tr></table></figure>
<h3 id="8-4-1-Defining-Your-Own-Function-Properties"><a href="#8-4-1-Defining-Your-Own-Function-Properties" class="headerlink" title="8.4.1 Defining Your Own Function Properties"></a>8.4.1 Defining Your Own Function Properties</h3><p>Functions are not primitive values in JavaScript, but a specialized kind of object, which means that functions can have properties. When a function needs a “static” variable whose value persists across invocations, it is often convenient to use a property of the function itself. For example, suppose you want to write a function that returns a unique integer whenever it is invoked. The function must never return the same value twice. In order to manage this, the function needs to keep track of the values it has already returned, and this information must persist across function invocations. You could store this information in a global variable, but that is unnecessary, because the information is used only by the function itself. It is better to store the information in a property of the Function object. Here is an example that returns a unique integer whenever it is called:</p>
<blockquote>
<p>JavaScript 中的函数并不是原始值，而是一种特殊的对象，也就是说，函数可以拥有属性。当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章。比如，假设你想写一个返回一个唯一整数的函数，不管在哪里调用函数都会返回这个整数。而函数不能两次返回同一个值，为了做到这一点，函数必须能够跟踪它每次返回的值，而且这些值的信息需要在不同的函数调过程中持久化。可以将这些信息存放到全局变量中，但这并不是必需的，因为这个信息仅仅是函数本身用到的。最好将这个信息保存到函数对象的一个属性中，下面这个例子就实现了这样一个函数，每次调用函数都会返回一个唯一的整数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the counter property of the function object.</span></span><br><span class="line"><span class="comment">// Function declarations are hoisted so we really can</span></span><br><span class="line"><span class="comment">// do this assignment before the function declaration.</span></span><br><span class="line">uniqueInteger.<span class="property">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function returns a different integer each time it is called.</span></span><br><span class="line"><span class="comment">// It uses a property of itself to remember the next value to be returned.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">uniqueInteger</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> uniqueInteger.<span class="property">counter</span>++;  <span class="comment">// Return and increment counter property</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">uniqueInteger</span>()  <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="title function_">uniqueInteger</span>()  <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>As another example, consider the following factorial() function that uses properties of itself (treating itself as an array) to cache previously computed results:</p>
<blockquote>
<p>来看另外一个例子，下面这个函数 factorial() 使用了自身的属性（将自身当做数组来对待）来缓存上一次的计算结果：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute factorials and cache results as properties of the function itself.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">factorial</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="title function_">isInteger</span>(n) &amp;&amp; n &gt; <span class="number">0</span>) &#123;           <span class="comment">// Positive integers only</span></span><br><span class="line">        <span class="keyword">if</span> (!(n <span class="keyword">in</span> factorial)) &#123;                  <span class="comment">// If no cached result</span></span><br><span class="line">            factorial[n] = n * <span class="title function_">factorial</span>(n-<span class="number">1</span>);    <span class="comment">// Compute and cache it</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factorial[n];                      <span class="comment">// Return the cached result</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">NaN</span>;                               <span class="comment">// If input was bad</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">factorial[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// Initialize the cache to hold this base case.</span></span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">6</span>)  <span class="comment">// =&gt; 720</span></span><br><span class="line">factorial[<span class="number">5</span>]  <span class="comment">// =&gt; 120; the call above caches this value</span></span><br></pre></td></tr></table></figure>
<h2 id="8-5-Functions-as-Namespaces"><a href="#8-5-Functions-as-Namespaces" class="headerlink" title="8.5 Functions as Namespaces"></a>8.5 Functions as Namespaces</h2><p>Variables declared within a function are not visible outside of the function. For this reason, it is sometimes useful to define a function simply to act as a temporary namespace in which you can define variables without cluttering the global namespace.</p>
<blockquote>
<p>变量声明在函数内对于函数体外是不可见的。因此，有时定义函数作为临时命名空间非常有用，您可以在其中定义变量而不弄乱全局命名空间。</p>
</blockquote>
<p>Suppose, for example, you have a chunk of JavaScript code that you want to use in a number of different JavaScript programs (or, for client-side JavaScript, on a number of different web pages). Assume that this code, like most code, defines variables to store the intermediate results of its computation. The problem is that since this chunk of code will be used in many different programs, you don’t know whether the variables it creates will conflict with variables created by the programs that use it. The solution is to put the chunk of code into a function and then invoke the function. This way, variables that would have been global become local to the function:</p>
<blockquote>
<p>比如，假设你写了一段 JavaScript 模块代码，这段代码将要用在不同的 JavaScript 程序中（对于客户端 JavaScript 来讲通常是用在各种各样的网页中）。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。解决办法当然是将代码放入一个函数内，然后调用这个函数。这样全局变量就变成了函数内的局部变量：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chunkNamespace</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// Chunk of code goes here</span></span><br><span class="line">    <span class="comment">// Any variables defined in the chunk are local to this function</span></span><br><span class="line">    <span class="comment">// instead of cluttering up the global namespace.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">chunkNamespace</span>();  <span class="comment">// But don&#x27;t forget to invoke the function!</span></span><br></pre></td></tr></table></figure>
<p>This code defines only a single global variable: the function name chunkNamespace. If defining even a single property is too much, you can define and invoke an anonymous function in a single expression:</p>
<blockquote>
<p>这段代码仅仅定义了一个单独的全局变量：名为 chunkNamespace 的函数。如果还是太麻烦，可以用一个单独的表达式定义一个匿名函数并调用它：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">// chunkNamespace() function rewritten as an unnamed expression.</span></span><br><span class="line">    <span class="comment">// Chunk of code goes here</span></span><br><span class="line">&#125;());          <span class="comment">// End the function literal and invoke it now.</span></span><br></pre></td></tr></table></figure>
<p>This technique of defining and invoking a function in a single expression is used frequently enough that it has become idiomatic and has been given the name “immediately invoked function expression.” Note the use of parentheses in the previous code example. The open parenthesis before function is required because without it, the JavaScript interpreter tries to parse the function keyword as a function declaration statement. With the parenthesis, the interpreter correctly recognizes this as a function definition expression. The leading parenthesis also helps human readers recognize when a function is being defined to be immediately invoked instead of defined for later use.</p>
<blockquote>
<p>这种定义匿名函数并立即在单个表达式中调用它的写法非常常见，并给它起了个名字“匿名调用函数表达式”。注意上面代码的圆括号的用法，function 之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript 解释器会试图将关键字 function 解析为函数声明语句。使用圆括号 JavaScript 解释器才会正确地将其解析为函数定义表达式。使用前导括号也有助于人类阅读时区分函数定义是立即执行还是供以后使用。</p>
</blockquote>
<p>This use of functions as namespaces becomes really useful when we define one or more functions inside the namespace function using variables within that namesapce, but then pass them back out as the return value of the namespace function. Functions like this are known as closures, and they’re the topic of the next section.</p>
<blockquote>
<p>函数用作命名空间很常用，在命名空间函数中定义一个或多个函数使用其中的变量，然后将他们作为函数命名空间的返回值。这样的函数称为闭包，它们是下一节的主题。</p>
</blockquote>
<h2 id="8-6-Closures"><a href="#8-6-Closures" class="headerlink" title="8.6 Closures"></a>8.6 Closures</h2><p>Like most modern programming languages, JavaScript uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked. In order to implement lexical scoping, the internal state of a JavaScript function object must include not only the code of the function but also a reference to the scope in which the function definition appears. This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.</p>
<blockquote>
<p>和其他大多数现代编程语言一样，JavaScript 也采用词法作用域。也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定的。为了实现这种词法作用域，JavaScript 函数对象的内部状态不仅包含函数的代码逻辑，还必须包括对函数定义出现的作用域的引用。将函数对象可和作用域相互关联起来（一对变量的绑定），函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。</p>
</blockquote>
<p>Technically, all JavaScript functions are closures, but because most functions are invoked from the same scope that they were defined in, it normally doesn’t really matter that there is a closure involved. Closures become interesting when they are invoked from a different scope than the one they were defined in. This happens most commonly when a nested function object is returned from the function within which it was defined. There are a number of powerful programming techniques that involve this kind of nested function closures, and their use has become relatively common in JavaScript programming. Closures may seem confusing when you first encounter them, but it is important that you understand them well enough to use them comfortably.</p>
<blockquote>
<p>从技术的角度讲，所有的 JavaScript 函数都是闭包，但是大多数函数调用和定义在同一个作用域内，通常不会注意这里有涉及到闭包。当调用函数不和其定义处于同一作用域内时，事情就变得非常微妙。当一个函数嵌套了另外一个函数，外部函数将嵌套的函数对象作为返回值返回的时候往往会发生这种事情。有很多强大的编程技术都利用到了这类嵌套的函数闭包，以至于这种编程模式在 JavaScript 中非常常见。当你第一次碰到闭包时可能会觉得非常让人费解，一旦你理解掌握了闭包之后，就能非常自如地使用它了，了解这一点至关重要。</p>
</blockquote>
<p>The first step to understanding closures is to review the lexical scoping rules for nested functions. Consider the following code:</p>
<blockquote>
<p>理解闭包首先要了解嵌套函数的词法作用域规则。看一下这段代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;global scope&quot;</span>;          <span class="comment">// A global variable</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> scope = <span class="string">&quot;local scope&quot;</span>;       <span class="comment">// A local variable</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> scope; &#125;   <span class="comment">// Return the value in scope here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">f</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">checkscope</span>()                         <span class="comment">// =&gt; &quot;local scope&quot;</span></span><br></pre></td></tr></table></figure>
<p>The checkscope() function declares a local variable and then defines and invokes a function that returns the value of that variable. It should be clear to you why the call to checkscope() returns “local scope”. Now, let’s change the code just slightly. Can you tell what this code will return?</p>
<blockquote>
<p>checkscope() 函数声明了一个局部变量，然后定义并执行了一个函数 f() ，函数 f() 返回了这个变量的值，最后将函数 f() 的执行结果返回。你应当非常清楚为什么调用 checkscope() 会返回 local scope。现在我们对这段代码做一点改动。你知道这段代码返回什么吗？</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;global scope&quot;</span>;          <span class="comment">// A global variable</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">checkscope</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> scope = <span class="string">&quot;local scope&quot;</span>;       <span class="comment">// A local variable</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> scope; &#125;   <span class="comment">// Return the value in scope here</span></span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="title function_">checkscope</span>()();              <span class="comment">// What does this return?</span></span><br></pre></td></tr></table></figure>
<p>In this code, a pair of parentheses has moved from inside checkscope() to outside of it. Instead of invoking the nested function and returning its result, checkscope() now just returns the nested function object itself. What happens when we invoke that nested function (with the second pair of parentheses in the last line of code) outside of the function in which it was defined?</p>
<blockquote>
<p>在这段代码中，我们将函数内的一对圆括号移动到了 checkscope() 之后。checkscope() 现在仅仅返回函数内嵌套的一个函数对象，而不是直接返回结果。在定义函数的作用域外面，调用这个嵌套的函数（包含最后一行代码的最后一对圆括号）会发生什么事情呢？</p>
</blockquote>
<p>Remember the fundamental rule of lexical scoping: JavaScript functions are executed using the scope they were defined in. The nested function f() was defined in a scope where the variable scope was bound to the value “local scope”. That binding is still in effect when f is executed, no matter where it is executed from. So the last line of the preceding code example returns “local scope”, not “global scope”. This, in a nutshell, is the surprising and powerful nature of closures: they capture the local variable (and parameter) bindings of the outer function within which they are defined.</p>
<blockquote>
<p>回想一下词法作用域的基本规则：JavaScript 函数的执行用到了作用域，这个作用域是函数定义的时候创建的。嵌套的函数 f() 定义在变量 scope 绑定的值是“local scope”的作用域里，这个绑定无论 f 函数在何处调用都依然有效。因此最后一行代码返回“local scope”，而不是“global scope”。简言之，闭包的这个特性强大到让人吃惊：它们可以捕捉到它们的外部函数所绑定的局部变量（和参数）。</p>
</blockquote>
<p>In §8.4.1, we defined a uniqueInteger() function that used a property of the function itself to keep track of the next value to be returned. A shortcoming of that approach is that buggy or malicious code could reset the counter or set it to a noninteger, causing the uniqueInteger() function to violate the “unique” or the “integer” part of its contract. Closures capture the local variables of a single function invocation and can use those variables as private state. Here is how we could rewrite the uniqueInteger() using an immediately invoked function expression to define a namespace and a closure that uses that namespace to keep its state private:</p>
<blockquote>
<p>在 §8.4.1 中定义了 uniqueInteger() 函数，这个函数使用自身的一个属性来保存每次返回的值，以便每次调用都能跟踪上次的返回值。但这种做法有一个问题，就是恶意代码可能将计数器重置或者把一个非整数赋值给它，导致 uniquenterger() 函数不一定能产生“唯一”的“整数”。而闭包可以捕捉到单个函数调用的局部变量，并将这些局部变量用做私有状态。下面是如何用立即调用函数表达式重写 uniqueInteger() 来定义命名空间和闭包来保持其状态私有化：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqueInteger = (<span class="keyword">function</span>(<span class="params"></span>) &#123;  <span class="comment">// Define and invoke</span></span><br><span class="line">    <span class="keyword">let</span> counter = <span class="number">0</span>;               <span class="comment">// Private state of function below</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> counter++; &#125;;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="title function_">uniqueInteger</span>()  <span class="comment">// =&gt; 0</span></span><br><span class="line"><span class="title function_">uniqueInteger</span>()  <span class="comment">// =&gt; 1</span></span><br></pre></td></tr></table></figure>
<p>In order to understand this code, you have to read it carefully. At first glance, the first line of code looks like it is assigning a function to the variable uniqueInteger. In fact, the code is defining and invoking (as hinted by the open parenthesis on the first line) a function, so it is the return value of the function that is being assigned to uniqueInteger. Now, if we study the body of the function, we see that its return value is another function. It is this nested function object that gets assigned to uniqueInteger. The nested function has access to the variables in its scope and can use the counter variable defined in the outer function. Once that outer function returns, no other code can see the counter variable: the inner function has exclusive access to it.</p>
<blockquote>
<p>你需要仔细阅读这段代码才能理解其含义。粗略来看，第一行代码看起来像将函数赋值给一个变量 uniqueInteger，实际上，这段代码定义了一个立即调用的函数（函数的开始带有左圆括号），因此是这个函数的返回值赋值给变量 uniqueInteger。现在，我们来看函数体，这个函数的返回值是另外一个函数。这是一个嵌套的函数，我们将它赋值给变量 uniqueInteger。嵌套的函数是可以访问作用域内的变量的，而且可以访问外部函数中定义的 counter 变量。当外部函数返回之后，其他任何代码都无法访问 counter 变量：只有内部的函数才能访问到它。</p>
</blockquote>
<p>Private variables like counter need not be exclusive to a single closure: it is perfectly possible for two or more nested functions to be defined within the same outer function and share the same scope. Consider the following code:</p>
<blockquote>
<p>像 counter 一样的私有变量不是只能用在一个单独的闭包内，在同一个外部函数内定义的多个嵌套函数也可以访问它，这多个嵌套函数都共享一个作用域，看一下这段代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">count</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">        <span class="attr">reset</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; n = <span class="number">0</span>; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">counter</span>(), d = <span class="title function_">counter</span>();   <span class="comment">// Create two counters</span></span><br><span class="line">c.<span class="title function_">count</span>()                           <span class="comment">// =&gt; 0</span></span><br><span class="line">d.<span class="title function_">count</span>()                           <span class="comment">// =&gt; 0: they count independently</span></span><br><span class="line">c.<span class="title function_">reset</span>();                          <span class="comment">// reset() and count() methods share state</span></span><br><span class="line">c.<span class="title function_">count</span>()                           <span class="comment">// =&gt; 0: because we reset c</span></span><br><span class="line">d.<span class="title function_">count</span>()                           <span class="comment">// =&gt; 1: d was not reset</span></span><br></pre></td></tr></table></figure>
<p>The counter() function returns a “counter” object. This object has two methods: count() returns the next integer, and reset() resets the internal state. The first thing to understand is that the two methods share access to the private variable n. The second thing to understand is that each invocation of counter() creates a new scope—independent of the scopes used by previous invocations—and a new private variable within that scope. So if you call counter() twice, you get two counter objects with different private variables. Calling count() or reset() on one counter object has no effect on the other.</p>
<blockquote>
<p>counter() 函数返回了一个“计数器”对象，这个对象包含两个方法：count() 返回下一个整数，reset() 重置内部状态。首先要理解，这两个方法都可以访问私有变量n。再者，每次调用 counter() 都会创建一个新的作用域链和一个新的私有变量。因此，如果调用 counter() 两次，则会得到两个计数器对象，而且彼此包含不同的私有变量，调用其中一个计数器对象的 count() 或 reset() 不会影响到另外一个对象。</p>
</blockquote>
<p>It is worth noting here that you can combine this closure technique with property getters and setters. The following version of the counter() function is a variation on code that appeared in §6.10.6, but it uses closures for private state rather than relying on a regular object property:</p>
<blockquote>
<p>从技术角度看，其实可以将这个闭包合并为属性存取器方法 getter 和 setter。下面这段代码所示的 counter() 函数的版本是 §6.10.6 中代码的变种，所不同的是，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">counter</span>(<span class="params">n</span>) &#123;  <span class="comment">// Function argument n is the private variable</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">// Property getter method returns and increments private counter var.</span></span><br><span class="line">        <span class="keyword">get</span> <span class="title function_">count</span>() &#123; <span class="keyword">return</span> n++; &#125;,</span><br><span class="line">        <span class="comment">// Property setter doesn&#x27;t allow the value of n to decrease</span></span><br><span class="line">        <span class="keyword">set</span> <span class="title function_">count</span>(<span class="params">m</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &gt; n) n = m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="title class_">Error</span>(<span class="string">&quot;count can only be set to a larger value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="title function_">counter</span>(<span class="number">1000</span>);</span><br><span class="line">c.<span class="property">count</span>            <span class="comment">// =&gt; 1000</span></span><br><span class="line">c.<span class="property">count</span>            <span class="comment">// =&gt; 1001</span></span><br><span class="line">c.<span class="property">count</span> = <span class="number">2000</span>;</span><br><span class="line">c.<span class="property">count</span>            <span class="comment">// =&gt; 2000</span></span><br><span class="line">c.<span class="property">count</span> = <span class="number">2000</span>;    <span class="comment">// !Error: count can only be set to a larger value</span></span><br></pre></td></tr></table></figure>
<p>Note that this version of the counter() function does not declare a local variable but just uses its parameter n to hold the private state shared by the property accessor methods. This allows the caller of counter() to specify the initial value of the private variable.</p>
<blockquote>
<p>需要注意的是，这个版本的 counter() 函数并未声明局部变量，而只是使用参数 n 来保存私有状态并与属性存取器方法共享。这样的话，调用 counter() 的函数就可以指定私有变量的初始值了。</p>
</blockquote>
<p>Example 8-2 is a generalization of the shared private state through the closures technique we’ve been demonstrating here. This example defines an addPrivateProperty() function that defines a private variable and two nested functions to get and set the value of that variable. It adds these nested functions as methods of the object you specify.</p>
<blockquote>
<p>示例 8-2是这种使用闭包技术来共享的私有状态的通用做法。这个例子定义了 addPrivateProperty() 函数，这个函数定义了一个私有变量，以及两个嵌套的函数用来获取和设置这个私有变量的值。它将这些嵌套函数添加为所指定对象的方法：</p>
</blockquote>
<p>Example 8-2. Private property accessor methods using closures</p>
<blockquote>
<p>示例 8-2：利用闭包实现的私有属性存取器方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function adds property accessor methods for a property with</span></span><br><span class="line"><span class="comment">// the specified name to the object o. The methods are named get&lt;name&gt;</span></span><br><span class="line"><span class="comment">// and set&lt;name&gt;. If a predicate function is supplied, the setter</span></span><br><span class="line"><span class="comment">// method uses it to test its argument for validity before storing it.</span></span><br><span class="line"><span class="comment">// If the predicate returns false, the setter method throws an exception.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The unusual thing about this function is that the property value</span></span><br><span class="line"><span class="comment">// that is manipulated by the getter and setter methods is not stored in</span></span><br><span class="line"><span class="comment">// the object o. Instead, the value is stored only in a local variable</span></span><br><span class="line"><span class="comment">// in this function. The getter and setter methods are also defined</span></span><br><span class="line"><span class="comment">// locally to this function and therefore have access to this local variable.</span></span><br><span class="line"><span class="comment">// This means that the value is private to the two accessor methods, and it</span></span><br><span class="line"><span class="comment">// cannot be set or modified except through the setter method.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addPrivateProperty</span>(<span class="params">o, name, predicate</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> value;  <span class="comment">// This is the property value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The getter method simply returns the value.</span></span><br><span class="line">    o[<span class="string">`get<span class="subst">$&#123;name&#125;</span>`</span>] = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> value; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The setter method stores the value or throws an exception if</span></span><br><span class="line">    <span class="comment">// the predicate rejects the value.</span></span><br><span class="line">    o[<span class="string">`set<span class="subst">$&#123;name&#125;</span>`</span>] = <span class="keyword">function</span>(<span class="params">v</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate &amp;&amp; !<span class="title function_">predicate</span>(v)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`set<span class="subst">$&#123;name&#125;</span>: invalid value <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The following code demonstrates the addPrivateProperty() method.</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;&#125;;  <span class="comment">// Here is an empty object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Add property accessor methods getName and setName()</span></span><br><span class="line"><span class="comment">// Ensure that only string values are allowed</span></span><br><span class="line"><span class="title function_">addPrivateProperty</span>(o, <span class="string">&quot;Name&quot;</span>, <span class="function"><span class="params">x</span> =&gt;</span> <span class="keyword">typeof</span> x === <span class="string">&quot;string&quot;</span>);</span><br><span class="line"></span><br><span class="line">o.<span class="title function_">setName</span>(<span class="string">&quot;Frank&quot;</span>);       <span class="comment">// Set the property value</span></span><br><span class="line">o.<span class="title function_">getName</span>()               <span class="comment">// =&gt; &quot;Frank&quot;</span></span><br><span class="line">o.<span class="title function_">setName</span>(<span class="number">0</span>);             <span class="comment">// !TypeError: try to set a value of the wrong type</span></span><br></pre></td></tr></table></figure>
<p>We’ve now seen a number of examples in which two closures are defined in the same scope and share access to the same private variable or variables. This is an important technique, but it is just as important to recognize when closures inadvertently share access to a variable that they should not share. Consider the following code:</p>
<blockquote>
<p>我们已经看到了很多例子，在同一个作用域中定义两个闭包，这两个闭包共享同样的私有变量或变量。这是一种非常重要的技术，但还是要特别小心那些不希望共享的变量往往不经意间共享给了其他的闭包，了解这一点也很重要。看一下下面这段代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function returns a function that always returns v</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">constfunc</span>(<span class="params">v</span>) &#123; <span class="keyword">return</span> <span class="function">() =&gt;</span> v; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an array of constant functions:</span></span><br><span class="line"><span class="keyword">let</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) funcs[i] = <span class="title function_">constfunc</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// The function at array element 5 returns the value 5.</span></span><br><span class="line">funcs[<span class="number">5</span>]()    <span class="comment">// =&gt; 5</span></span><br></pre></td></tr></table></figure>
<p>When working with code like this that creates multiple closures using a loop, it is a common error to try to move the loop within the function that defines the closures. Think about the following code, for example:</p>
<blockquote>
<p>这段代码利用循环创建了很多个闭包，当写类似这种代码的时候往往会犯一个错误：那就是试图将循环代码移入定义这个闭包的函数之内，看一下这段代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return an array of functions that return the values 0-9</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">constfuncs</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> funcs = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        funcs[i] = <span class="function">() =&gt;</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> funcs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> funcs = <span class="title function_">constfuncs</span>();</span><br><span class="line">funcs[<span class="number">5</span>]()    <span class="comment">// =&gt; 10; Why doesn&#x27;t this return 5?</span></span><br></pre></td></tr></table></figure>
<p>This code creates 10 closures and stores them in an array. The closures are all defined within the same invocation of the function, so they share access to the variable i. When constfuncs() returns, the value of the variable i is 10, and all 10 closures share this value. Therefore, all the functions in the returned array of functions return the same value, which is not what we wanted at all. It is important to remember that the scope associated with a closure is “live.” Nested functions do not make private copies of the scope or make static snapshots of the variable bindings. Fundamentally, the problem here is that variables declared with var are defined throughout the function. Our for loop declares the loop variable with var i, so the variable i is defined throughout the function rather than being more narrowly scoped to the body of the loop. The code demonstrates a common category of bugs in ES5 and before, but the introduction of block-scoped variables in ES6 addresses the issue. If we just replace the var with a let or a const, then the problem goes away. Because let and const are block scoped, each iteration of the loop defines a scope that is independent of the scopes for all other iterations, and each of these scopes has its own independent binding of i.</p>
<blockquote>
<p>上面这段代码创建了10个闭包，并将它们存储到一个数组中。这些闭包都是在同一个函数调用中定义的，因此它们可以共享变量 i。当 constfuncs() 返回时，变量 i 的值是10，所有的闭包都共享这一个值，因此，数组中的函数的返回值都是同一个值，这不是我们想要的结果。关联到闭包的作用域都是“活动的”，记住这一点非常重要。嵌套的函数不会将作用域内的私有成员复制一份，也不会对所绑定的变量生成静态快照。从根本上讲，这里的问题是，使用 var 声明的变量，它的定义贯穿整个函数。我们的 for 循环使用 var i 声明循环变量，因此变量 i 在整个函数中都有定义，而不是更狭义地作用于循环的主体。该代码演示了 ES6 之前的常见 Bug 类别，但在 ES6 中引入块级变量作用域解决了这个问题。如果我们只是用 let 或 const 替换 var， 那么问题就消失了。由于 let 和 const 是块级作用域，因此循环的每个迭代都定义了一个独立于所有其他迭代的作用域，并且每个作用域都有其自己的独立绑定 i。</p>
</blockquote>
<p>Another thing to remember when writing closures is that this is a JavaScript keyword, not a variable. As discussed earlier, arrow functions inherit the this value of the function that contains them, but functions defined with the function keyword do not. So if you’re writing a closure that needs to use the this value of its containing function, you should use an arrow function, or call bind(), on the closure before returning it, or assign the outer this value to a variable that your closure will inherit:</p>
<blockquote>
<p>书写闭包的时候还需注意一件事情，this 是 JavaScript 的关键字，而不是变量。正如之前讨论的，箭头函数从包含它们的函数中继承 this 值，但是用 function 关键字定义的函数不是。所以如果写一个闭包需要使用包含它的函数的 this 值，要在闭包返回之前使用箭头函数或者用调用 bind()，或者将 this 值赋值给一个变量，这样你的闭包会继承它：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> self = <span class="variable language_">this</span>;  <span class="comment">// Make the this value available to nested functions</span></span><br></pre></td></tr></table></figure>
<h2 id="8-7-Function-Properties-Methods-and-Constructor"><a href="#8-7-Function-Properties-Methods-and-Constructor" class="headerlink" title="8.7 Function Properties, Methods, and Constructor"></a>8.7 Function Properties, Methods, and Constructor</h2><p>We’ve seen that functions are values in JavaScript programs. The typeof operator returns the string “function” when applied to a function, but functions are really a specialized kind of JavaScript object. Since functions are objects, they can have properties and methods, just like any other object. There is even a Function() constructor to create new function objects. The subsections that follow document the length, name, and prototype properties; the call(), apply(), bind(), and toString() methods; and the Function() constructor.</p>
<blockquote>
<p>我们看到在 JavaScript 程序中，函数是值。对函数执行 typeof 运算会返回字符串“function”，但是函数是 JavaScript 中特殊的对象。因为函数也是对象，它们也可以拥有属性和方法，就像普通的对象可以拥有属性和方法一样。甚至可以用 Function() 构造函数来创建新的函数对象。接下来几节就会着重介绍函数 length、name 和 prototype 属性；call()、 apply()、 bind() 和 toString() 方法；以及 Function() 构造函数。</p>
</blockquote>
<h3 id="8-7-1-The-length-Property"><a href="#8-7-1-The-length-Property" class="headerlink" title="8.7.1 The length Property"></a>8.7.1 The length Property</h3><p>The read-only length property of a function specifies the arity of the function—the number of parameters it declares in its parameter list, which is usually the number of arguments that the function expects. If a function has a rest parameter, that parameter is not counted for the purposes of this length property.</p>
<blockquote>
<p>函数的只读属性 length 指定函数参数个数–声明在其参数列表中的参数个数，大多数函数期望的实参个数。如果一个函数有一个剩余函数，它的参数个数不被计算入 length 属性。（经测试，可选参数也不计算 length。）</p>
</blockquote>
<h3 id="8-7-2-The-name-Property"><a href="#8-7-2-The-name-Property" class="headerlink" title="8.7.2 The name Property"></a>8.7.2 The name Property</h3><p>The read-only name property of a function specifies the name that was used when the function was defined, if it was defined with a name, or the name of the variable or property that an unnamed function expression was assigned to when it was first created. This property is primarily useful when writing debugging or error messages.</p>
<blockquote>
<p>如果使用名称定义函数，只读属性 name 指定函数定义时用的名称，或未命名函数表达式在首次创建时分配给的变量或属性的名称。此属性在编写调试或错误消息时很有用。</p>
</blockquote>
<h3 id="8-7-3-The-prototype-Property"><a href="#8-7-3-The-prototype-Property" class="headerlink" title="8.7.3 The prototype Property"></a>8.7.3 The prototype Property</h3><p>All functions, except arrow functions, have a prototype property that refers to an object known as the prototype object. Every function has a different prototype object. When a function is used as a constructor, the newly created object inherits properties from the prototype object. Prototypes and the prototype property were discussed in §6.2.3 and will be covered again in Chapter 9.</p>
<blockquote>
<p>所有函数都包含一个 prototype 属性，这个属性是指向一个对象的引用，这个对象称做原型对象。每一个函数都包含不同的原型对象。当将函数用作构造函数的时候，新创建的对象会从原型对象上继承属性。§6.2.3 讨论了原型和 prototype 属性，在第 9 章里会有进一步讨论。</p>
</blockquote>
<h3 id="8-7-4-The-call-and-apply-Methods"><a href="#8-7-4-The-call-and-apply-Methods" class="headerlink" title="8.7.4 The call() and apply() Methods"></a>8.7.4 The call() and apply() Methods</h3><p>call() and apply() allow you to indirectly invoke (§8.2.4) a function as if it were a method of some other object. The first argument to both call() and apply() is the object on which the function is to be invoked; this argument is the invocation context and becomes the value of the this keyword within the body of the function. To invoke the function f() as a method of the object o (passing no arguments), you could use either call() or apply():</p>
<blockquote>
<p>我们可以将 call() 和 apply () 看做是某个对象的方法，通过调用方法的形式来间接调用（见 §8.2.4）函数。call() 和 apply() 的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内变成 this 关键字的值。要想以对象 o 的方法来调用函数 f()（没有实参传递），可以这样使用 call() 和 apply()：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="title function_">call</span>(o);</span><br><span class="line">f.<span class="title function_">apply</span>(o);</span><br></pre></td></tr></table></figure>
<p>Either of these lines of code are similar to the following (which assume that o does not already have a property named m):</p>
<blockquote>
<p>每行代码和下面代码的功能类似（假设对象 o 中预先不存在名为 m 的属性）:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">o.<span class="property">m</span> = f;     <span class="comment">// Make f a temporary method of o.</span></span><br><span class="line">o.<span class="title function_">m</span>();       <span class="comment">// Invoke it, passing no arguments.</span></span><br><span class="line"><span class="keyword">delete</span> o.<span class="property">m</span>;  <span class="comment">// Remove the temporary method.</span></span><br></pre></td></tr></table></figure>
<p>Remember that arrow functions inherit the this value of the context where they are defined. This cannot be overridden with the call() and apply() methods. If you call either of those methods on an arrow function, the first argument is effectively ignored.</p>
<blockquote>
<p>不要忘了，箭头函数从它定义的位置的上下文继承 this 值。这不能被 call() 和 apply() 方法重写。如果通过箭头函数调用它俩任何一个方法，第一个实参实际上都被忽略。</p>
</blockquote>
<p>Any arguments to call() after the first invocation context argument are the values that are passed to the function that is invoked (and these arguments are not ignored for arrow functions). For example, to pass two numbers to the function f() and invoke it as if it were a method of the object o, you could use code like this:</p>
<blockquote>
<p>对于 call() 来说，除了第一个作为调用上下文实参，之后的所有实参就是要传入待调用函数的值（并且，这部分实参对于箭头函数来说不被忽略）。比如，以对象 o 的方法的形式调用函数 f()，并传入两个数，可以使用这样的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="title function_">call</span>(o, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>The apply() method is like the call() method, except that the arguments to be passed to the function are specified as an array:</p>
<blockquote>
<p>apply() 方法和 call() 类似，但传入实参的形式和 call() 有所不同，它的实参都放入一个数组中：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="title function_">apply</span>(o, [<span class="number">1</span>,<span class="number">2</span>]);</span><br></pre></td></tr></table></figure>
<p>If a function is defined to accept an arbitrary number of arguments, the apply() method allows you to invoke that function on the contents of an array of arbitrary length. In ES6 and later, we can just use the spread operator, but you may see ES5 code that uses apply() instead. For example, to find the largest number in an array of numbers without using the spread operator, you could use the apply() method to pass the elements of the array to the Math.max() function:</p>
<blockquote>
<p>如果一个函数的实参可以是任意数量，用 apply() 方法允许你传入的参数数组可以是任意长度的。在 ES6 之后，我们可以用展开运算符，但是在 ES5 的代码中你可以看到这种情况是用 apply() 来替代。比如，不用展开运算符找出数组中最大的数值元素，调用 Math.max() 方法的时候可以给  apply() 传入一个包含任意个元素的数组：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> biggest = <span class="title class_">Math</span>.<span class="property">max</span>.<span class="title function_">apply</span>(<span class="title class_">Math</span>, arrayOfNumbers);</span><br></pre></td></tr></table></figure>
<p>The trace() function defined in the following is similar to the timed() function defined in §8.3.4, but it works for methods instead of functions. It uses the apply() method instead of a spread operator, and by doing that, it is able to invoke the wrapped method with the same arguments and the same this value as the wrapper method:</p>
<blockquote>
<p>下面定义的 trace() 与 §8.3.4 中定义的 timed() 函数类似，但是它对方法有效而不是函数。它使用 apply() 方法而不是展开运算符，通过这样做，它能够调用具有相同参数和与被包装方法相同的 this 值的包装方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace the method named m of the object o with a version that logs</span></span><br><span class="line"><span class="comment">// messages before and after invoking the original method.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">trace</span>(<span class="params">o, m</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> original = o[m];         <span class="comment">// Remember original method in the closure.</span></span><br><span class="line">    o[m] = <span class="keyword">function</span>(<span class="params">...args</span>) &#123;   <span class="comment">// Now define the new method.</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;Entering:&quot;</span>, m);      <span class="comment">// Log message.</span></span><br><span class="line">        <span class="keyword">let</span> result = original.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);      <span class="comment">// Invoke original.</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;Exiting:&quot;</span>, m);       <span class="comment">// Log message.</span></span><br><span class="line">        <span class="keyword">return</span> result;                                <span class="comment">// Return result.</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-7-5-The-bind-Method"><a href="#8-7-5-The-bind-Method" class="headerlink" title="8.7.5 The bind() Method"></a>8.7.5 The bind() Method</h3><p>The primary purpose of bind() is to bind a function to an object. When you invoke the bind() method on a function f and pass an object o, the method returns a new function. Invoking the new function (as a function) invokes the original function f as a method of o. Any arguments you pass to the new function are passed to the original function. For example:</p>
<blockquote>
<p>bind() 方法的主要作用就是将函数绑定至某个对象。当在函数 f() 上调用 bind() 方法并传入一个对象 o 作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数 f() 当做 o 的方法来调用。传入新函数的任何实参都将传入原始函数，比如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + y; &#125; <span class="comment">// This function needs to be bound</span></span><br><span class="line"><span class="keyword">let</span> o = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;                    <span class="comment">// An object we&#x27;ll bind to</span></span><br><span class="line"><span class="keyword">let</span> g = f.<span class="title function_">bind</span>(o);                   <span class="comment">// Calling g(x) invokes f() on o</span></span><br><span class="line"><span class="title function_">g</span>(<span class="number">2</span>)                                 <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="keyword">let</span> p = &#123; <span class="attr">x</span>: <span class="number">10</span>, g &#125;;                <span class="comment">// Invoke g() as a method of this object</span></span><br><span class="line">p.<span class="title function_">g</span>(<span class="number">2</span>)                               <span class="comment">// =&gt; 3: g is still bound to o, not p.</span></span><br></pre></td></tr></table></figure>
<p>Arrow functions inherit their this value from the environment in which they are defined, and that value cannot be overridden with bind(), so if the function f() in the preceding code was defined as an arrow function, the binding would not work. The most common use case for calling bind() is to make non-arrow functions behave like arrow functions, however, so this limitation on binding arrow functions is not a problem in practice.</p>
<blockquote>
<p>箭头函数从它们定义的上下文中继承 this 值，并且其不可被 bind() 方法重写，所以如果上面的代码用箭头函数定义函数 f()，这个绑定不会生效。调用 bind() 方法的最常用场景是让不带箭头的函数的行为像箭头函数一样，所以实际上绑定箭头函数的 this 局限性并不是一个问题。</p>
</blockquote>
<p>The bind() method does more than just bind a function to an object, however. It can also perform partial application: any arguments you pass to bind() after the first are bound along with the this value. This partial application feature of bind() does work with arrow functions. Partial application is a common technique in functional programming and is sometimes called currying. Here are some examples of the bind() method used for partial application:</p>
<blockquote>
<p>但是 bind() 方法不仅仅是将函数绑定至一个对象。它还附带一些其他应用：除了第一个实参之外，传入 bind() 的实参也会绑定至 this 值。这个附带的应用在箭头函数上也同样生效。是一种常见的函数式编程技术，有时也被称为“柯里化”。参照下面这个例子中的 bind() 方法的实现：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>) =&gt; x + y;      <span class="comment">// Return the sum of 2 args</span></span><br><span class="line"><span class="keyword">let</span> succ = sum.<span class="title function_">bind</span>(<span class="literal">null</span>, <span class="number">1</span>);  <span class="comment">// Bind the first argument to 1</span></span><br><span class="line"><span class="title function_">succ</span>(<span class="number">2</span>)  <span class="comment">// =&gt; 3: x is bound to 1, and we pass 2 for the y argument</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">y,z</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">x</span> + y + z; &#125;</span><br><span class="line"><span class="keyword">let</span> g = f.<span class="title function_">bind</span>(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;, <span class="number">2</span>);     <span class="comment">// Bind this and y</span></span><br><span class="line"><span class="title function_">g</span>(<span class="number">3</span>)     <span class="comment">// =&gt; 6: this.x is bound to 1, y is bound to 2 and z is 3</span></span><br></pre></td></tr></table></figure>
<p>The name property of the function returned by bind() is the name property of the function that bind() was called on, prefixed with the word “bound”.</p>
<blockquote>
<p>bind() 返回函数的名称属性是调用 bind() 的函数的名称属性前面加上前缀为单词”bound”。</p>
</blockquote>
<h3 id="8-7-6-The-toString-Method"><a href="#8-7-6-The-toString-Method" class="headerlink" title="8.7.6 The toString() Method"></a>8.7.6 The toString() Method</h3><p>Like all JavaScript objects, functions have a toString() method. The ECMAScript spec requires this method to return a string that follows the syntax of the function declaration statement. In practice, most (but not all) implementations of this toString() method return the complete source code for the function. Built-in functions typically return a string that includes something like “[native code]” as the function body.</p>
<blockquote>
<p>和所有的 JavaScript 对象一样，函数也有 toString() 方法，ECMAScript 规范规定这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的 toString() 方法的实现都返回函数的完整源码。内置函数往往返回一个类似”[native code]”的字符串作为函数体。</p>
</blockquote>
<h3 id="8-7-7-The-Function-Constructor"><a href="#8-7-7-The-Function-Constructor" class="headerlink" title="8.7.7 The Function() Constructor"></a>8.7.7 The Function() Constructor</h3><p>Because functions are objects, there is a Function() constructor that can be used to create new functions:</p>
<blockquote>
<p>因为函数是对象，有一个 Function() 构造函数可以用来创建新的函数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>, <span class="string">&quot;return x*y;&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>This line of code creates a new function that is more or less equivalent to a function defined with the familiar syntax:</p>
<blockquote>
<p>这一行代码创建一个新的函数，这个函数和通过下面代码定义的函数几乎等价：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = <span class="keyword">function</span>(<span class="params">x, y</span>) &#123; <span class="keyword">return</span> x*y; &#125;;</span><br></pre></td></tr></table></figure>
<p>The Function() constructor expects any number of string arguments. The last argument is the text of the function body; it can contain arbitrary JavaScript statements, separated from each other by semicolons. All other arguments to the constructor are strings that specify the parameter names for the function. If you are defining a function that takes no arguments, you would simply pass a single string—the function body—to the constructor.</p>
<blockquote>
<p>Function() 构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的 JavaScript 语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体——即可。</p>
</blockquote>
<p>Notice that the Function() constructor is not passed any argument that specifies a name for the function it creates. Like function literals, the Function() constructor creates anonymous functions.</p>
<blockquote>
<p>注意，Function() 构造函数并不需要通过传入实参以指定函数名。就像函数字面量一样，Function() 构造函数创建一个匿名函数。</p>
</blockquote>
<p>There are a few points that are important to understand about the Function() constructor:</p>
<blockquote>
<p>关于 Function() 构造函数有几点需要特别注意：</p>
</blockquote>
<p>The Function() constructor allows JavaScript functions to be dynamically created and compiled at runtime.</p>
<blockquote>
<p>Function() 构造函数允许 JavaScript 在运行时动态地创建并编译函数。</p>
</blockquote>
<p>The Function() constructor parses the function body and creates a new function object each time it is called. If the call to the constructor appears within a loop or within a frequently called function, this process can be inefficient. By contrast, nested functions and function expressions that appear within loops are not recompiled each time they are encountered.</p>
<blockquote>
<p>每次调用 Function() 构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译。</p>
</blockquote>
<p>A last, very important point about the Function() constructor is that the functions it creates do not use lexical scoping; instead, they are always compiled as if they were top-level functions, as the following code demonstrates:</p>
<blockquote>
<p>最后一点，也是关于 Function() 构造函数非常重要的一点，就是它所创建的函数并不是使用词法作用域，相反，函数体代码的编译类似顶层函数，如下面代码所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> scope = <span class="string">&quot;global&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">constructFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> scope = <span class="string">&quot;local&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&quot;return scope&quot;</span>);  <span class="comment">// Doesn&#x27;t capture local scope!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This line returns &quot;global&quot; because the function returned by the</span></span><br><span class="line"><span class="comment">// Function() constructor does not use the local scope.</span></span><br><span class="line"><span class="title function_">constructFunction</span>()()  <span class="comment">// =&gt; &quot;global&quot;</span></span><br></pre></td></tr></table></figure>
<p>The Function() constructor is best thought of as a globally scoped version of eval() (see §4.12.2) that defines new variables and functions in its own private scope. You will probably never need to use this constructor in your code.</p>
<blockquote>
<p>我们可以将 Function() 构造函数认为是在全局作用域中执行的 eval()（见  §4.12.2），eval() 可以在自己的私有作用域内定义新变量和函数，Function() 构造函数在实际编程过程中很少会用到。</p>
</blockquote>
<h2 id="8-8-Functional-Programming"><a href="#8-8-Functional-Programming" class="headerlink" title="8.8 Functional Programming"></a>8.8 Functional Programming</h2><p>JavaScript is not a functional programming language like Lisp or Haskell, but the fact that JavaScript can manipulate functions as objects means that we can use functional programming techniques in JavaScript. Array methods such as map() and reduce() lend themselves particularly well to a functional programming style. The sections that follow demonstrate techniques for functional programming in JavaScript. They are intended as a mind-expanding exploration of the power of JavaScript’s functions, not as a prescription for good programming style.</p>
<blockquote>
<p>和 Lisp、Haskell 不同，JavaScript 并非函数式编程语言，但在 JavaScript 中可以像操控对象一样操控函数，也就是说可以在 JavaScript 中应用函数式编程技术。数组方法诸如 map() 和 reduce() 就可以非常适合用于函数式编程风格。接下来的几节将会着重介绍 JavaScript 中的函数式编程技术。函数式编程旨在扩展对 JavaScript 函数功能功能的探索，而不是为了良好的编程风格。</p>
</blockquote>
<h3 id="8-8-1-Processing-Arrays-with-Functions"><a href="#8-8-1-Processing-Arrays-with-Functions" class="headerlink" title="8.8.1 Processing Arrays with Functions"></a>8.8.1 Processing Arrays with Functions</h3><p>Suppose we have an array of numbers and we want to compute the mean and standard deviation of those values. We might do that in nonfunctional style like this:</p>
<blockquote>
<p>假设有一个数组，数组元素都是数字，我们想要计算这些元素的平均值和标准差。若使用非函数式编程风格的话，代码会是这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];  <span class="comment">// This is our array of numbers</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The mean is the sum of the elements divided by the number of elements</span></span><br><span class="line"><span class="keyword">let</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) total += data[i];</span><br><span class="line"><span class="keyword">let</span> mean = total/data.<span class="property">length</span>;  <span class="comment">// mean == 3; The mean of our data is 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// To compute the standard deviation, we first sum the squares of</span></span><br><span class="line"><span class="comment">// the deviation of each element from the mean.</span></span><br><span class="line">total = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> deviation = data[i] - mean;</span><br><span class="line">    total += deviation * deviation;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(total/(data.<span class="property">length</span>-<span class="number">1</span>));  <span class="comment">// stddev == 2</span></span><br></pre></td></tr></table></figure>
<p>We can perform these same computations in concise functional style using the array methods map() and reduce() like this (see §7.8.1 to review these methods):</p>
<blockquote>
<p>可以使用数组方法 map() 和 reduce() 来实现同样的计算，这种实现极其简洁（参照 §7.8.1 来查看这些方法）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// First, define two simple functions</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>) =&gt; x+y;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = x =&gt; x*x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Then use those functions with Array methods to compute mean and stddev</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> mean = data.<span class="title function_">reduce</span>(sum)/data.<span class="property">length</span>;  <span class="comment">// mean == 3</span></span><br><span class="line"><span class="keyword">let</span> deviations = data.<span class="title function_">map</span>(<span class="function"><span class="params">x</span> =&gt;</span> x-mean);</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(deviations.<span class="title function_">map</span>(square).<span class="title function_">reduce</span>(sum)/(data.<span class="property">length</span>-<span class="number">1</span>));</span><br><span class="line">stddev  <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>
<p>This new version of the code looks quite different than the first one, but it is still invoking methods on objects, so it has some object-oriented conventions remaining. Let’s write functional versions of the map() and reduce() methods:</p>
<blockquote>
<p>这个新版本的代码看起来跟第一版有很大不同，但是它仍然调用对象的方法，所以它还是面向对象编程。接下来用函数版本的 map() 和 reduce() 方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">function</span>(<span class="params">a, ...args</span>) &#123; <span class="keyword">return</span> a.<span class="title function_">map</span>(...args); &#125;;</span><br><span class="line"><span class="keyword">const</span> reduce = <span class="keyword">function</span>(<span class="params">a, ...args</span>) &#123; <span class="keyword">return</span> a.<span class="title function_">reduce</span>(...args); &#125;;</span><br></pre></td></tr></table></figure>
<p>With these map() and reduce() functions defined, our code to compute the mean and standard deviation now looks like this:</p>
<blockquote>
<p>用这两个函数定义了 map() 和 reduce()，我们计算平均值和标准差变成这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>) =&gt; x+y;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = x =&gt; x*x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> mean = <span class="title function_">reduce</span>(data, sum)/data.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">let</span> deviations = <span class="title function_">map</span>(data, <span class="function"><span class="params">x</span> =&gt;</span> x-mean);</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="title class_">Math</span>.<span class="title function_">sqrt</span>(<span class="title function_">reduce</span>(<span class="title function_">map</span>(deviations, square), sum)/(data.<span class="property">length</span>-<span class="number">1</span>));</span><br><span class="line">stddev  <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>
<h3 id="8-8-2-Higher-Order-Functions"><a href="#8-8-2-Higher-Order-Functions" class="headerlink" title="8.8.2 Higher-Order Functions"></a>8.8.2 Higher-Order Functions</h3><p>A higher-order function is a function that operates on functions, taking one or more functions as arguments and returning a new function. Here is an example:</p>
<blockquote>
<p>所谓高阶函数就是操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数。来看这个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This higher-order function returns a new function that passes its</span></span><br><span class="line"><span class="comment">// arguments to f and returns the logical negation of f&#x27;s return value;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">not</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;             <span class="comment">// Return a new function</span></span><br><span class="line">        <span class="keyword">let</span> result = f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);  <span class="comment">// that calls f</span></span><br><span class="line">        <span class="keyword">return</span> !result;                    <span class="comment">// and negates its result.</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">even</span> = x =&gt; x % <span class="number">2</span> === <span class="number">0</span>; <span class="comment">// A function to determine if a number is even</span></span><br><span class="line"><span class="keyword">const</span> odd = <span class="title function_">not</span>(even);         <span class="comment">// A new function that does the opposite</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>].<span class="title function_">every</span>(odd)         <span class="comment">// =&gt; true: every element of the array is odd</span></span><br></pre></td></tr></table></figure>
<p>This not() function is a higher-order function because it takes a function argument and returns a new function. As another example, consider the mapper() function that follows. It takes a function argument and returns a new function that maps one array to another using that function. This function uses the map() function defined earlier, and it is important that you understand how the two functions are different:</p>
<blockquote>
<p>上面的 not() 函数就是一个高阶函数，因为它接收一个函数作为参数，并返回一个新函数。另外一个例子，来看下面的 mapper() 函数，它也是接收一个函数作为实参，并返回一个新函数，这个新函数将一个数组映射到另一个使用这个函数的数组上。这个函数使用了之前定义的 map() 函数，但要首先理解这两个函数有哪里不 同，理解这一点至关重要：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a function that expects an array argument and applies f to</span></span><br><span class="line"><span class="comment">// each element, returning the array of return values.</span></span><br><span class="line"><span class="comment">// Contrast this with the map() function from earlier.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapper</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">a</span> =&gt;</span> <span class="title function_">map</span>(a, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">increment</span> = x =&gt; x+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> incrementAll = <span class="title function_">mapper</span>(increment);</span><br><span class="line"><span class="title function_">incrementAll</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment">// =&gt; [2,3,4]</span></span><br></pre></td></tr></table></figure>
<p>Here is another, more general, example that takes two functions, f and g, and returns a new function that computes f(g()):</p>
<blockquote>
<p>这里是一个更常见的例子，它接收两个函数 f() 和 g()，并返回一个新的函数用以计算 f(g())：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a new function that computes f(g(...)).</span></span><br><span class="line"><span class="comment">// The returned function h passes all of its arguments to g, then passes</span></span><br><span class="line"><span class="comment">// the return value of g to f, then returns the return value of f.</span></span><br><span class="line"><span class="comment">// Both f and g are invoked with the same this value as h was invoked with.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">f, g</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// We use call for f because we&#x27;re passing a single value and</span></span><br><span class="line">        <span class="comment">// apply for g because we&#x27;re passing an array of values.</span></span><br><span class="line">        <span class="keyword">return</span> f.<span class="title function_">call</span>(<span class="variable language_">this</span>, g.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sum</span> = (<span class="params">x,y</span>) =&gt; x+y;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">square</span> = x =&gt; x*x;</span><br><span class="line"><span class="title function_">compose</span>(square, sum)(<span class="number">2</span>,<span class="number">3</span>)  <span class="comment">// =&gt; 25; the square of the sum</span></span><br></pre></td></tr></table></figure>
<p>The partial() and memoize() functions defined in the sections that follow are two more important higher-order functions.</p>
<blockquote>
<p>本章后续几节中定义了 partial() 和 memoize() 函数，这两个函数是非常重要的高阶函数。</p>
</blockquote>
<h3 id="8-8-3-Partial-Application-of-Functions"><a href="#8-8-3-Partial-Application-of-Functions" class="headerlink" title="8.8.3 Partial Application of Functions"></a>8.8.3 Partial Application of Functions</h3><p>The bind() method of a function f (see §8.7.5) returns a new function that invokes f in a specified context and with a specified set of arguments. We say that it binds the function to an object and partially applies the arguments. The bind() method partially applies arguments on the left—that is, the arguments you pass to bind() are placed at the start of the argument list that is passed to the original function. But it is also possible to partially apply arguments on the right:</p>
<blockquote>
<p>函数 f()（见 §8.7.5）的 bind() 方法返回一个新函数，给新函数传入特定的上下文和一组指定的参数，然后调用函数 f()。我们说它把函数“绑定至”对象并传入一部分参数。bind() 方法只是将实参放在（完整实参列表的）左侧，也就是说传入 bind() 的实参都是放在传入原始函数的实参列表开始的位置，但有时我们期望将传入 bind() 的实参放在（完整实参列表的）右侧：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The arguments to this function are passed on the left</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partialLeft</span>(<span class="params">f, ...outerArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...innerArgs</span>) &#123; <span class="comment">// Return this function</span></span><br><span class="line">        <span class="keyword">let</span> args = [...outerArgs, ...innerArgs]; <span class="comment">// Build the argument list</span></span><br><span class="line">        <span class="keyword">return</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);              <span class="comment">// Then invoke f with it</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The arguments to this function are passed on the right</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partialRight</span>(<span class="params">f, ...outerArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...innerArgs</span>) &#123;  <span class="comment">// Return this function</span></span><br><span class="line">        <span class="keyword">let</span> args = [...innerArgs, ...outerArgs]; <span class="comment">// Build the argument list</span></span><br><span class="line">        <span class="keyword">return</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);              <span class="comment">// Then invoke f with it</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The arguments to this function serve as a template. Undefined values</span></span><br><span class="line"><span class="comment">// in the argument list are filled in with values from the inner set.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partial</span>(<span class="params">f, ...outerArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...innerArgs</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> args = [...outerArgs]; <span class="comment">// local copy of outer args template</span></span><br><span class="line">        <span class="keyword">let</span> innerIndex=<span class="number">0</span>;          <span class="comment">// which inner arg is next</span></span><br><span class="line">        <span class="comment">// Loop through the args, filling in undefined values from inner args</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args[i] === <span class="literal">undefined</span>) args[i] = innerArgs[innerIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Now append any remaining inner arguments</span></span><br><span class="line">        args.<span class="title function_">push</span>(...innerArgs.<span class="title function_">slice</span>(innerIndex));</span><br><span class="line">        <span class="keyword">return</span> f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here is a function with three arguments</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">function</span>(<span class="params">x,y,z</span>) &#123; <span class="keyword">return</span> x * (y - z); &#125;;</span><br><span class="line"><span class="comment">// Notice how these three partial applications differ</span></span><br><span class="line"><span class="title function_">partialLeft</span>(f, <span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)         <span class="comment">// =&gt; -2: Bind first argument: 2 * (3 - 4)</span></span><br><span class="line"><span class="title function_">partialRight</span>(f, <span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)        <span class="comment">// =&gt;  6: Bind last argument: 3 * (4 - 2)</span></span><br><span class="line"><span class="title function_">partial</span>(f, <span class="literal">undefined</span>, <span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">// =&gt; -6: Bind middle argument: 3 * (2 - 4)</span></span><br></pre></td></tr></table></figure>
<p>These partial application functions allow us to easily define interesting functions out of functions we already have defined. Here are some examples:</p>
<blockquote>
<p>利用这种不完全函数的编程技巧，可以编写一些有意思的代码，利用已有的函数来定义新的函数，参照下面这个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> increment = <span class="title function_">partialLeft</span>(sum, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> cuberoot = <span class="title function_">partialRight</span>(<span class="title class_">Math</span>.<span class="property">pow</span>, <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line"><span class="title function_">cuberoot</span>(<span class="title function_">increment</span>(<span class="number">26</span>))  <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>
<p>Partial application becomes even more interesting when we combine it with other higher-order functions. Here, for example, is a way to define the preceding not() function just shown using composition and partial application:</p>
<blockquote>
<p>当将不完全调用和其他高阶函数整合在一起的时候，事情就变得格外有趣了。比如，这里的例子定义了 not() 函数，它用到了刚才提到的不完全调用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> not = <span class="title function_">partialLeft</span>(compose, <span class="function"><span class="params">x</span> =&gt;</span> !x);</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">even</span> = x =&gt; x % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> odd = <span class="title function_">not</span>(even);</span><br><span class="line"><span class="keyword">const</span> isNumber = <span class="title function_">not</span>(<span class="built_in">isNaN</span>);</span><br><span class="line"><span class="title function_">odd</span>(<span class="number">3</span>) &amp;&amp; <span class="title function_">isNumber</span>(<span class="number">2</span>)  <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>We can also use composition and partial application to redo our mean and standard deviation calculations in extreme functional style:</p>
<blockquote>
<p>我们也可以使用不完全调用的组合来重新组织求平均数和标准差的代码，这种编码风格是非常纯粹的函数式编程：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum() and square() functions are defined above. Here are some more:</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">product</span> = (<span class="params">x,y</span>) =&gt; x*y;</span><br><span class="line"><span class="keyword">const</span> neg = <span class="title function_">partial</span>(product, -<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> sqrt = <span class="title function_">partial</span>(<span class="title class_">Math</span>.<span class="property">pow</span>, <span class="literal">undefined</span>, <span class="number">.5</span>);</span><br><span class="line"><span class="keyword">const</span> reciprocal = <span class="title function_">partial</span>(<span class="title class_">Math</span>.<span class="property">pow</span>, <span class="literal">undefined</span>, <span class="title function_">neg</span>(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now compute the mean and standard deviation.</span></span><br><span class="line"><span class="keyword">let</span> data = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>];   <span class="comment">// Our data</span></span><br><span class="line"><span class="keyword">let</span> mean = <span class="title function_">product</span>(<span class="title function_">reduce</span>(data, sum), <span class="title function_">reciprocal</span>(data.<span class="property">length</span>));</span><br><span class="line"><span class="keyword">let</span> stddev = <span class="title function_">sqrt</span>(<span class="title function_">product</span>(<span class="title function_">reduce</span>(<span class="title function_">map</span>(data,</span><br><span class="line">                                     <span class="title function_">compose</span>(square,</span><br><span class="line">                                             <span class="title function_">partial</span>(sum, <span class="title function_">neg</span>(mean)))),</span><br><span class="line">                                 sum),</span><br><span class="line">                          <span class="title function_">reciprocal</span>(<span class="title function_">sum</span>(data.<span class="property">length</span>,<span class="title function_">neg</span>(<span class="number">1</span>)))));</span><br><span class="line">[mean, stddev]  <span class="comment">// =&gt; [3, 2]</span></span><br></pre></td></tr></table></figure>
<p>Notice that this code to compute mean and standard deviation is entirely function invocations; there are no operators involved, and the number of parentheses has grown so large that this JavaScript is beginning to look like Lisp code. Again, this is not a style that I advocate for JavaScript programming, but it is an interesting exercise to see how deeply functional JavaScript code can be.</p>
<blockquote>
<p>注意，这段代码计算平均值和标准差完全是函数调用;没有涉及运算符，并且括号的数量增长如此之大让 JavaScript 开始看起来像 Lisp 代码。同样，这不是我提倡的 JavaScript 编程风格，但它是一个有趣的练习，看看 JavaScript 代码的功能有多深。</p>
</blockquote>
<h3 id="8-8-4-Memoization"><a href="#8-8-4-Memoization" class="headerlink" title="8.8.4 Memoization"></a>8.8.4 Memoization</h3><p>In §8.4.1, we defined a factorial function that cached its previously computed results. In functional programming, this kind of caching is called memoization. The code that follows shows a higher-order function, memoize(), that accepts a function as its argument and returns a memoized version of the function:</p>
<blockquote>
<p>在 §8.4.1 中定义了一个阶乘函数，它可以将上次的计算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”（memorization）。下面的代码展示了一个高阶函数，memorize() 接收一个函数作为实参，并返回带有记忆能力的函数:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a memoized version of f.</span></span><br><span class="line"><span class="comment">// It only works if arguments to f all have distinct string representations.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">memoize</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">Map</span>();  <span class="comment">// Value cache stored in the closure.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">        <span class="comment">// Create a string version of the arguments to use as a cache key.</span></span><br><span class="line">        <span class="keyword">let</span> key = args.<span class="property">length</span> + args.<span class="title function_">join</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cache.<span class="title function_">get</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> result = f.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">            cache.<span class="title function_">set</span>(key, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The memoize() function creates a new object to use as the cache and assigns this object to a local variable so that it is private to (in the closure of) the returned function. The returned function converts its arguments array to a string and uses that string as a property name for the cache object. If a value exists in the cache, it returns it directly. Otherwise, it calls the specified function to compute the value for these arguments, caches that value, and returns it. Here is how we might use memoize():</p>
<blockquote>
<p>memorize() 函数创建一个新的对象，这个对象被当做缓存（的宿主）并赋值给一个局部变量，因此对于返回的函数来说它是私有的（在闭包中）。所返回的函数将它的实参数组转换成字符串，并将字符串用做缓存对象的属性名。如果在缓存中存在这个值，则直接返回它。否则，就调用既定的函数对实参进行计算，将计算结果缓存起来并返回，下面的代码展示了如何使用 memorize()：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return the Greatest Common Divisor of two integers using the Euclidian</span></span><br><span class="line"><span class="comment">// algorithm: http://en.wikipedia.org/wiki/Euclidean_algorithm</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>) &#123;  <span class="comment">// Type checking for a and b has been omitted</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) &#123;           <span class="comment">// Ensure that a &gt;= b when we start</span></span><br><span class="line">        [a, b] = [b, a];   <span class="comment">// Destructuring assignment to swap variables</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b !== <span class="number">0</span>) &#123;       <span class="comment">// This is Euclid&#x27;s algorithm for GCD</span></span><br><span class="line">        [a, b] = [b, a%b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gcdmemo = <span class="title function_">memoize</span>(gcd);</span><br><span class="line"><span class="title function_">gcdmemo</span>(<span class="number">85</span>, <span class="number">187</span>)  <span class="comment">// =&gt; 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that when we write a recursive function that we will be memoizing,</span></span><br><span class="line"><span class="comment">// we typically want to recurse to the memoized version, not the original.</span></span><br><span class="line"><span class="keyword">const</span> factorial = <span class="title function_">memoize</span>(<span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">1</span> : n * <span class="title function_">factorial</span>(n-<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">factorial</span>(<span class="number">5</span>)      <span class="comment">// =&gt; 120: also caches values for 4, 3, 2 and 1.</span></span><br></pre></td></tr></table></figure>
<h2 id="8-9-Summary"><a href="#8-9-Summary" class="headerlink" title="8.9 Summary"></a>8.9 Summary</h2><p>Some key points to remember about this chapter are as follows:</p>
<p>You can define functions with the function keyword and with the ES6 &#x3D;&gt; arrow syntax.</p>
<p>You can invoke functions, which can be used as methods and constructors.</p>
<p>Some ES6 features allow you to define default values for optional function parameters, to gather multiple arguments into an array using a rest parameter, and to destructure object and array arguments into function parameters.</p>
<p>You can use the … spread operator to pass the elements of an array or other iterable object as arguments in a function invocation.</p>
<p>A function defined inside of and returned by an enclosing function retains access to its lexical scope and can therefore read and write the variables defined inside the outer function. Functions used in this way are called closures, and this is a technique that is worth understanding.</p>
<p>Functions are objects that can be manipulated by JavaScript, and this enables a functional style of programming.</p>
<blockquote>
<p>本章关键点总结如下：</p>
<p>可以用函数关键字和 ES6 &#x3D;&gt; 箭头函数来定义函数。</p>
<p>可以以方法和构造函数的方式调用函数。</p>
<p>一些 ES6 特性，允许参数设定默认值，可以用剩余参数将多个参数搜集到一个数组中，可以解构对象和数组实参到函数参数中。</p>
<p>可以用 … 展开运算符传递数组元素或者其他可迭代对象到函数调用。</p>
<p>封闭函数内部定义并返回的函数保留对其词法作用域的访问，因此可以读取和写入外部函数内定义的变量。用这种方式使用的函数称为闭包，这是一种值得理解的技术。</p>
<p>函数是可由 JavaScript 操作的对象，这使 JavaScript 支持函数式编程。</p>
</blockquote>
<hr>
<ol>
<li>The term was coined by Martin Fowler. See <a target="_blank" rel="noopener" href="http://martinfowler.com/dslCatalog/methodChaining.html">http://martinfowler.com/dslCatalog/methodChaining.html</a>.</li>
<li>If you are familiar with Python, note that this is different than Python, in which every invocation shares the same default value.</li>
<li>This may not seem like a particularly interesting point unless you are familiar with more static languages, in which functions are part of a program but cannot be manipulated by the program.</li>
</ol>
<blockquote>
<ol>
<li>这个术语最初是由 Martin Fowler 提出的，参见<a target="_blank" rel="noopener" href="http://martinfowler.com/dslwip/MethodChaining.html%E3%80%82">http://martinfowler.com/dslwip/MethodChaining.html。</a></li>
<li>这看起来不足为奇，但如果你对 Python 很熟悉，你会发现 Python 中的函数是程序的一 部分，但无法被程序操作。</li>
<li>这似乎并不是一个特别有趣的点，除非你熟悉更多的静态语言，其中函数是程序的一部分，但不能由程序操作。</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Jack hou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/')">第8章 函数</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wechat/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=第8章 函数&amp;url=http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/&amp;pic=https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.houyanbin.com" target="_blank">Jackhou Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>《JavaScript权威指南》<span class="tagsPageCount">17</span></a><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">17</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第9章 类</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch7/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第7章 数组</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch1/" title="第1章 JavaScript 概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第1章 JavaScript 概述</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch10/" title="第10章 模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第10章 模块</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch13/" title="第13章 异步 JavaScript"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第13章 异步 JavaScript</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch11/" title="第11章 JavaScript 标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第11章 JavaScript 标准库</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch14/" title="第14章 元编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第14章 元编程</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch12/" title="第12章 迭代器和生成器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第12章 迭代器和生成器</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">Hi，这是我的博客网站，欢迎你能到访~</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">我会在这里分享我的<b style="color:#fff">技术知识</b>、<b style="color:#fff">日常生活</b>和<b style="color:#fff">人生经验。</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Jack hou</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/YingxueSec" target="_blank" title="Github"><i class="fab fa-github faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/478589474" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=jackhou921@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wxgzh1.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Defining-Functions"><span class="toc-text">8.1 Defining Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-Function-Declarations"><span class="toc-text">8.1.1 Function Declarations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-Function-Expressions"><span class="toc-text">8.1.2 Function Expressions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-3-Arrow-Functions"><span class="toc-text">8.1.3 Arrow Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-4-Nested-Functions"><span class="toc-text">8.1.4 Nested Functions</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Invoking-Functions"><span class="toc-text">8.2 Invoking Functions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-Function-Invocation"><span class="toc-text">8.2.1 Function Invocation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CONDITIONAL-INVOCATION"><span class="toc-text">CONDITIONAL INVOCATION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RECURSIVE-FUNCTIONS-AND-THE-STACK"><span class="toc-text">RECURSIVE FUNCTIONS AND THE STACK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-Method-Invocation"><span class="toc-text">8.2.2 Method Invocation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#METHOD-CHAINING"><span class="toc-text">METHOD CHAINING</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-Constructor-Invocation"><span class="toc-text">8.2.3 Constructor Invocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-Indirect-Invocation"><span class="toc-text">8.2.4 Indirect Invocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-Implicit-Function-Invocation"><span class="toc-text">8.2.5 Implicit Function Invocation</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-Function-Arguments-and-Parameters"><span class="toc-text">8.3 Function Arguments and Parameters</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-1-Optional-Parameters-and-Defaults"><span class="toc-text">8.3.1 Optional Parameters and Defaults</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-2-Rest-Parameters-and-Variable-Length-Argument-Lists"><span class="toc-text">8.3.2 Rest Parameters and Variable-Length Argument Lists</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-3-The-Arguments-Object"><span class="toc-text">8.3.3 The Arguments Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-4-The-Spread-Operator-for-Function-Calls"><span class="toc-text">8.3.4 The Spread Operator for Function Calls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-5-Destructuring-Function-Arguments-into-Parameters"><span class="toc-text">8.3.5 Destructuring Function Arguments into Parameters</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-6-Argument-Types"><span class="toc-text">8.3.6 Argument Types</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Functions-as-Values"><span class="toc-text">8.4 Functions as Values</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-1-Defining-Your-Own-Function-Properties"><span class="toc-text">8.4.1 Defining Your Own Function Properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-Functions-as-Namespaces"><span class="toc-text">8.5 Functions as Namespaces</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-Closures"><span class="toc-text">8.6 Closures</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-7-Function-Properties-Methods-and-Constructor"><span class="toc-text">8.7 Function Properties, Methods, and Constructor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-1-The-length-Property"><span class="toc-text">8.7.1 The length Property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-2-The-name-Property"><span class="toc-text">8.7.2 The name Property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-3-The-prototype-Property"><span class="toc-text">8.7.3 The prototype Property</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-4-The-call-and-apply-Methods"><span class="toc-text">8.7.4 The call() and apply() Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-5-The-bind-Method"><span class="toc-text">8.7.5 The bind() Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-6-The-toString-Method"><span class="toc-text">8.7.6 The toString() Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-7-7-The-Function-Constructor"><span class="toc-text">8.7.7 The Function() Constructor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-8-Functional-Programming"><span class="toc-text">8.8 Functional Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-1-Processing-Arrays-with-Functions"><span class="toc-text">8.8.1 Processing Arrays with Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-2-Higher-Order-Functions"><span class="toc-text">8.8.2 Higher-Order Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-3-Partial-Application-of-Functions"><span class="toc-text">8.8.3 Partial Application of Functions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-8-4-Memoization"><span class="toc-text">8.8.4 Memoization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-9-Summary"><span class="toc-text">8.9 Summary</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="做情人真的没有好下场吗？"/></a><div class="content"><a class="title" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？">做情人真的没有好下场吗？</a><time datetime="2023-08-14T16:00:00.000Z" title="发表于 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不爱前行"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行">不爱前行</a><time datetime="2023-07-29T16:00:00.000Z" title="发表于 2023-07-30 00:00:00">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="租房时光"/></a><div class="content"><a class="title" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光">租房时光</a><time datetime="2023-07-21T16:00:00.000Z" title="发表于 2023-07-22 00:00:00">2023-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="故宫记"/></a><div class="content"><a class="title" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记">故宫记</a><time datetime="2023-06-10T16:00:00.000Z" title="发表于 2023-06-11 00:00:00">2023-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息收集道道之外网信息收集"/></a><div class="content"><a class="title" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集">信息收集道道之外网信息收集</a><time datetime="2023-05-28T16:00:00.000Z" title="发表于 2023-05-29 00:00:00">2023-05-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 By <a class="footer-bar-link" href="/" title="Jack hou" target="_blank">Jack hou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 0.88rem; color: rgb(64, 178, 160);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem; color: rgb(124, 98, 59);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem; color: rgb(151, 166, 74);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem; color: rgb(59, 56, 12);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; color: rgb(34, 91, 88);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem; color: rgb(83, 144, 91);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 0.88rem; color: rgb(0, 62, 123);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem; color: rgb(191, 0, 191);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 0.88rem; color: rgb(86, 90, 92);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem; color: rgb(64, 152, 176);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 0.88rem; color: rgb(12, 112, 106);">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 0.88rem; color: rgb(132, 35, 3);">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem; color: rgb(199, 150, 134);">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem; color: rgb(48, 161, 199);">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 0.88rem; color: rgb(184, 176, 112);">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 0.88rem; color: rgb(87, 174, 70);">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 0.88rem; color: rgb(57, 104, 67);">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem; color: rgb(199, 66, 132);">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 0.88rem; color: rgb(190, 65, 48);">越权<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8868465080" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8868465080&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("4/15/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Jack hou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("4/15/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.houyanbin.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>