<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>第9章 类 | Jackhou Blog</title><meta name="keywords" content="《JavaScript权威指南》,JavaScript"><meta name="author" content="Jack hou"><meta name="copyright" content="Jack hou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="第9章 类"><meta name="application-name" content="第9章 类"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="第9章 类"><meta property="og:url" content="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/index.html"><meta property="og:site_name" content="Jackhou Blog"><meta property="og:description" content="JavaScript objects were covered in Chapter 6. That chapter treated each object as a unique set of properties, different from every other object. I"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg"><meta property="article:author" content="Jack hou"><meta property="article:tag" content="Jackhou, blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg"><meta name="description" content="JavaScript objects were covered in Chapter 6. That chapter treated each object as a unique set of properties, different from every other object. I"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/assets/font-awesome-animation.min.css"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: 'https://twikoo.houyanbin.com/',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Jack hou","link":"链接: ","source":"来源: Jackhou Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#3b70fc","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Jackhou Blog',
  title: '第9章 类',
  postAI: '',
  pageFillDescription: '9.1 Classes and Prototypes, 9.2 Classes and Constructors, 9.2.1 Constructors Class Identity and instanceof, 9.2.2 The constructor Property, 9.3 Classes with the class Keyword, 9.3.1 Static Methods, 9.3.2 Getters Setters and other Method Forms, 9.3.3 Public Private and Static Fields, 9.3.4 Example A Complex Number Class, 9.4 Adding Methods to Existing Classes, 9.5 Subclasses, 9.5.1 Subclasses and Prototypes, 9.5.2 Subclasses with extends and super, 9.5.3 Delegation Instead of Inheritance, 9.5.4 Class Hierarchies and Abstract Classes, 9.6 Summary第章详细介绍了对象每个对象都是一个属性集合相互之间没有任何联系在中也可以定义对象的类让每个对象都共享某些属性这种共享的特性是非常有用的类的成员或实例都包含一些属性用以存放或定义它们的状态其中有些属性定义了它们的行为通常称为方法这些行为通常是由类定义的而且为所有实例所共享例如假设有一个名为的类用来表示复数同时还定义了一些复数运算一个实例应当包含复数的实部和虚部状态同样类还会定义复数的加法和乘法操作行为在中类的实现是基于其原型继承机制的如果两个实例都从同一个原型对象上继承了属性我们说它们是同一个类的实例原型和继承在和节中有详细讨论为了更好地理解本章的内容请务必首先阅读这两个章节本章将会在中对原型做进一步讨论如果两个对象继承自同一个原型往往意味着但不是绝对它们是由同一个构造函数创建并初始化的我们已经在和节中详细讲解了构造函数会有进一步讨论一直允许定义类引入了全新的语法包括关键字使创建类更加容易这些新的类的工作方式与旧式类相同本章首先解释创建类的旧方法因为这更清楚地展示了类是如何工作的一旦我们解释了这些基本原理我们将改变并开始使用新的简化的类定义语法如果你对诸如和这种强类型的面向对象编程比较熟悉你会发现中的类和以及中的类有很大不同尽管在写法上类似而且在中也能模拟出很多经典的类的特性但是最好要理解的类和基于原型的继承机制以及和传统的当然还有类似的语言的类和基于类的继承机制的不同之处在中类的所有实例对象都从同一个原型对象上继承属性因此原型对象是类的核心在示例中定义了函数这个函数返回一个新创建的对象后者继承自某个原型对象如果定义一个原型对象然后通过函数创建一个继承自它的对象这样就定义了一个类通常类的实例还需要进一步的初始化通常是通过定义一个函数来创建并初始化这个新对象参照示例示例给一个表示值的范围的类定义了原型对象还定义了一个工厂函数用以创建并初始化类的实例示例一个简单的类在示例的代码中有一下几点值得注意这段代码定义了一个工厂函数用来创建一个新的对象用函数的属性来存放定义类的原型对象只是将原型对象随意的放在一个地方并不是一个规约或者习惯函数在每个对象中都定义和属性它们是非共享非继承属性是每个独立的对象的独特自有状态对象应用了的速记语法来定义方法这是为什么没有看到关键字的原因参照来复习对象字面量速记方法语法原型中的一个方法使用了计算属性名表明它是为对象定义一个迭代器方法名称带有一个前缀标识它是一个生成器函数而不是普通的函数迭代器和生成器在第章会详细描述现在只需要知道类的实例可以用循环和可以用展开运算符定义在中的共享继承方法都使用在工厂函数初始化的和属性在这些方法被调用时为了引用和属性都使用关键字来获取对象的引用这种用法是任何类中方法的基本特征示例展示了一个简单方式来定义一个类但是这种方法并不常用因为它没有定义一个构造函数构造函数是用来初始化新建对象的如中所述构造函数用关键字来调用使用调用构造函数会自动创建一个新对象因此构造函数本身只需初始化这个新对象的状态即可介绍并强调了虽然所有对象都有原型但是只有一部分对象有一个属性最后我们可以澄清这一点是函数对象具有属性这意味着所有用同一构造函数创建的对象继承同一个对象因此它们是同一类的成员示例说明了如何使用一个构造函数来替代示例中的工厂函数来修改类示例演示了在不支持关键字版本的中创建一个类的通用方法即使是已经很好支持的今天仍然有很多旧代码用这种方式定义类并且你必须熟悉这种习惯用法以便于阅读旧代码也能够在使用关键字时明白在底层中发生了什么示例使用构造函数的类将示例和示例中的代码做一个仔细的对比可以发现两种类定义技术的差别首先注意当工厂函数转化为构造函数时被重命名为这里遵循了一个常见的编程约定从某种意义上讲定义构造函数即是定义类并且类名首字母要大写而普通的函数和方法都是首字母小写再者注意构造函数是通过关键字调用的在示例代码的末尾而工厂函数则不必使用示例通过调用普通函数来创建新对象示例则使用构造函数调用来创建新对象由于构造函数是通过关键字调用的因此不必调用或其他什么逻辑来创建新对象在调用构造函数之前就已经创建了新对象并且通过关键字可以获取这个新对象构造函数只不过是初始化而已构造函数甚至不必返回这个新创建的对象构造函数会自动创建对象然后将构造函数作为这个对象的方法来调用一次最后返回这个新对象构造函数调用与常规函数调用如此不同实际上这是我们为构造函数命名以大写字母为名的另一个原因构造函数就是用来构造新对象的它必须通过关键字调用如果将构造函数用做普通函数的话往往不会正常工作开发者可以通过命名规约来构造函数首字母大写普通方法首字母小写判断是否应当在函数之前冠以关键字在函数正文中可以使用特殊的表达式来判断函数是否以构造函数的方式调用如果定义了该表达式的值那么这个函数是通过关键字调用的构造函数当我们在中讨论子类时我们会看到不总是其所在的构造函数的引用它可能还引用子类的构造函数如果是那么包含它的函数是作为函数调用的没有使用关键字很多异常构造函数可以不使用来调用如果想模仿这个特性可以这样写这个老式技巧只在构造函数定义时生效类使用关键字创建不允许不使用调用它的构造函数示例和之间的另一个关键区别是原型对象的命名方式在第一个示例中原型是这是一个方便和描述性的名称但随意在第二个示例中原型为此名称是规定的构造函数的调用自动使用作为新对象的原型最后还要注意示例和之间不变的部分对两个类来说方法以相同的方式定义和调用由于示例演示了在之前在版本中创建类的惯用方法因此它没原型对象中使用速记方法语法并且使用关键字显式拼出方法名但是可以看到在这两个示例中方法的实现是相同的请注意在定义构造函数或方法时两个示例都没使用箭头函数回想一下从中用这种方式定义的函数没有原型属性因此不能用作构造函数此外箭头函数从定义它们的上下文中继承关键字而不是基于调用它们的对象设置值这使得箭头函数对方法毫无用处因为方法的定义特征是方法使用关键字来引用调用方法的实例幸运的是新的类语法不允许使用函数定义方法因此这不是使用该语法时可能会意外犯的错误我们将很快介绍类关键字但首先有更多关于构造函数的详细信息正如我们所看到的原型对象是类的基本标识只有两个对象继承同一原型对象时这两个对象是同一类实例构造函数的关键点不是初始化新创建对象的状态两个构造函数可能具有指向同一原型对象的原型属性那么两个构造函数都可用于创建同一类的实例尽管构造函数不像原型那样重要但是构造函数充当的大众脸最明显的是构造函数的名称通常用作类的名称例如我们说构造函数创建对象然而更重要的是测试类中对象的成员关系构造函数在右边被用作运算符的操作数如果有一个对象并且想知道它是不是一个对象可以这样写运算符在中有描述左边的操作数是想要测试的对象右边的操作数是命名类的构造函数表达式计算结果为时继承自不需要直接继承如果继承于一个继承了的对象表达式的计算结果也仍会是从技术上讲在上一个代码示例中运算符的实例没有检查是否实际由构造函数初始化相反它是检查是否继承如果我们定义一个函数并将其原型设置与相同则使用新创建的对象用运算符将算作对象但是它们实际上不会作为对象工作因为它们的和属性尚未初始化实际上即使不能验证使用了构造函数它仍然使用构造函数作为其右侧因为构造函数是类的公共标识如果要为特定原型测试对象的原型链并且不想将构造函数用作媒介可以使用方法例如在示例中我们定义了一个没有构造函数的类因此无法将与该类一起使用但是我们可以测试对象是否是具有此代码的无构造函数类的成员在示例中将定义为一个新对象这个对象包含类所需要的方法其实没有必要新创建一个对象用单个对象字面量的属性就可以方便地定义原型上的方法任何普通函数除箭头函数生成器函数和异步函数之外都可以用做构造函数并且调用构造函数是需要一个属性的因此每个函数都自动拥有一个属性这个属性的值是一个对象这个对象包含唯一一个不可枚举属性属性的值是一个函数对象可以看到构造函数的原型中存在预先定义好的属性这意味着对象通常继承的是它们的构造函数的引用由于构造函数是类的公共标识因此这个属性为对象提供了类如图所示图展示了构造函数和原型对象之间的关系包括原型到构造函数的反向引用以及构造函数创建的实例需要注意的是图用构造函数作为示例但实际上示例中定义的类使用它自身的一个新对象重写了预定义的对象这个新定义的原型对象不含有属性因此类的实例也不含有属性我们可以通过补救措施来修正这个问题显式给原型添加一个构造函数另一种常见的解决办法是使用预定义的原型对象预定义的原型对象包含属性然后依次给原型对象添加方法类自第一个版本以来一直是的一部分但在中它们最终引入关键字得到了自己的语法示例显示了使用此新语法编写类的实现示例使用编写类重要的是要了解在示例和中定义的类的工作方式完全相同将关键字引入语言并不会改变基于原型的类的基本性质尽管示例使用关键字但生成的对象是一个构造函数就像示例中定义的版本一样新的语法更清洁方便但是最好将其看作示例所示的基本类定义机制的语法糖注意在示例中关于语法的一下几点用关键字声明类后面接一个类名最后是花括号包含类的正文类正文包括使用对象字面量方法速记定义的方法我们在示例中也使用了其中省略了函数关键字但是与对象字面量不同没有用逗号将方法彼此分开虽然类正文表面上与对象字面量相似但它们不是一回事与对象不同类不支持具有名值对的属性的定义关键字用于定义类的构造函数但是定义的函数实际上并不命名为类声明语句定义一个新的变量并将此特殊构造函数的值分配给该变量如果类不需要执行任何初始化可以省略构造函数关键字及其正文并将隐式创建一个空构造函数如果要定义子类或继承来自另一个类的类可以使用关键字与关键字创建子类是完整的一节我们将在重新讲到它并解释这里的和关键字与函数声明一样类声明同时具有语句和表达式形式正如我们可以写与函数定义表达式一样类定义表达式可以包含可选类名如果提供这样的名称则该名称仅在类正文本身中有定义尽管函数表达式很常见尤其是使用箭头函数但编程中类定义表达式可能并不是经常使用除非正在编写一个以类为实参并返回子类的函数结束对关键字的介绍前最后提几个重要但是不易注意的类语法类声明正文中的所有代码都隐式采用严格模式即使未出现指令例如这意味着不能在类正文中使用八进制整数字面量或语句并且如果在使用变量之前忘记声明变量则更有可能出现语法错误与函数声明不同类声明不是声明提前的回想一下中函数定义的行为就像它们被移动到封闭文件的顶部或封闭函数的顶部一样这意味着可以在函数实际定义之前的代码中调用函数尽管类声明在某些方面与函数声明一样但它们不共享这种提前行为在声明类之前不能实例化类可以通过使用关键字作为方法声明前缀来定义类正文中的静态方法静态方法定义为构造函数的属性而不是原型对象的属性例如假设我们将以下代码添加到示例中此代码定义的方法是而不是必须通过构造函数而不是通过实例调用它有时会看到静态方法称为类方法因为它们是使用类构造函数的名称调用的使用此术语时将类方法与在类实例上调用的常规实例方法进行对比由于静态方法在构造函数上调用而不是在任何特定实例上调用因此在静态方法中使用关键字几乎从来就没有意义我们将在示例中看到静态方法的示例在类正文中可以定义和方法就像在对象字面量中一样唯一的区别是在类正文中不会将逗号放在或之后示例包括类中方法的实际示例通常对象字面量中允许的所有速记方法定义语法也允许在类正文中使用这包括生成器方法用标记和名称为方括号中表达式值的方法事实上已经看到了在示例中具有计算名称的生成器方法该方法使类可重复在此处对使用关键字定义的类的讨论中我们只描述了类正文中方法的定义标准只允许创建方法包括和生成器和静态方法它不包括用于定义字段的语法如果要在类实例上定义字段这只是面向对象中属性的同义词则必须在构造函数函数或其中一个方法中这样做必须在类正文之外类定义后才能为类定义静态字段示例包括这各种字段的示例但是对于允许以公有和私有形式定义实例和静态字段的扩展类语法正在进行标准化本节其余部分中显示的代码在年初还不是标准但在中已经支持并且中已部分支持仅使公有实例字段使用框架和编译器的程序员常用公有实例字段的语法假设你正在编写一个这样的类其中一个构造函数初始化了三个字段使用可能标准化的新实例字段语法可以这样编写字段初始化代码已移出构造函数现在直接显示在类正文中当然该代码仍作为构造函数的一部分运行如果不定义构造函数则字段初始化为隐式创建的构造函数的一部分赋值左侧的前缀消失但请注意即使是在初始化赋值的右侧仍必须使用前缀引用这些字段这种方式初始化实例字段的优点是此语法允许但不需要将初始化放在类定义的顶部使读者清楚地了解字段在每个实例将保存的状态可以通过字段名后面跟一个分号来只声明不初始化一个字段如果这样做字段的初始值将是显式设定初始化字段的值是比较好的风格在添加字段语法之前类正文看起来很像使用快捷方法语法的对象字面量只不过逗号被删除字段语法使用等号和分号代替冒号和逗号清楚地表明类正文与对象字面量不完全相同标准化中的实例字段同时也定义了私有实例字段如果使用上例中所示的实例字段初始化语法来定义其名称以开头的字段在标识符中通常不是合法字符则该字段在类正文中可用使用前缀但对类正文之外的任何代码不可见且不可访问因此不可变如果对于前面的类要确保类的用户不会无意中修改实例的字段可以改为使用私有字段然后定义函数以提供对值的只读访问请注意必须先使用新字段语法声明私有字段然后才能使用它们你不能只在类的构造函数中写除非直接在类正文中包含字段的声明最后在标准化过程中相关建议字段使用关键字如果在公有或私有字段声明之前添加静态字段这些字段将创建为构造函数的属性而不是实例的属性思考我们定义的静态方法它包括一个相当复杂的正则表达式将其拆分到它自有的静态字段中可能会更好使用建议的新静态字段语法我们可以这编写如果我们希望此静态字段只能在类中访问我们可以使用像这样的名称将其私有化示例定义了一个表示复数的类该类相对简单但它包括实例方法包括静态方法实例字段和静态字段它包括一些注释掉的代码演示如何使用尚未加入标准的语法定义类正文中的实例字段和静态字段示例一个复数类定义了示例的类后我们可以将构造函数实例字段实例方法类字段和类方法如下使用基于原型的继承机制是动态的对象从其原型继承属性即使原型的属性在创建对象后发生更改这意味着我们只需向原型对象添加新方法即可扩展类例如下面是将计算共轭复数的方法添加到示例的类的代码类内置的原型对象也是这样展现的这意味着我们可以向数字字符串数组函数等添加方法这对于在旧版本的语言中实现新特性非常有用这是另外一个例子向这样在内置类型的原型添加方法通常被认为是一个坏主意因为如果新版本的定义具有相同名称的方法将来就会造成混淆和兼容性问题甚至可以向添加方法使它们可作用于所有对象但这从来就不是一件好事因为添加到的属性对循环可见尽管可以使用来使新属性不可枚举来避免这种情况在面向对象的编程中类可以扩展类或成为类子类我们称是父类是子类的实例继承的方法类可以定义自有方法使用相同名称可以重写类中的方法如果的方法重写方法则中的重写方法通常需要调用中的重写方法同样子类构造函数通常必须调用父类构造函数以确保实例完全初始化本节首先演示之前如何定义子类然后演示使用和关键字的子类和使用关键字调用父类构造函数再接下来一节是关于避免使用子类而依靠对象组合代替继承本章最后结束于一个扩展的示例定义类的层次结构和演示如何使用抽象类将接口与实现分离假设我们想要给示例中类定义子类此子类的工作方式与一样但我们初始化改为指定开始和范围而不是制定开始和结束类的实例也是父类的实例实例从继承自定义的方法但为了成为的子类它还必须从继承方法如实例一个简单的子类为了使成为的子类我们需要使从继承前面示例中的关键代码行是此代码行如果能理解子类使如何工作的它是非常有意义的使用构造函数创建的对象将从对象继承但是我们创建了该对象并继承因此对象将同时从和继承可能会注意到我们的构造函数设置与构造函数相同的和属性因此不需要调用构造函数来初始化新对象同样的方法完全重新实现字符串转换而无需调用版本的这使得成为特例我们必须摆脱这种子类因为这种情况是我们知道父类的实现细节一个健壮的子类机制需要允许类调用其父类的方法和构造函数但在之前没有一个简单的方法来执行这些操作幸运的是用关键字作为类语法一部分解决了这些问题下一节演示它是如何工作的在之后可以简单的在类声明时接一个从句添加一个父类即使对于内置类也可以这样做子类定义了两个简单的方法实例的行为类似于普通数组我们可以使用继承的方法和属性如和但是我们也可以使用子类中定义的和方法不仅继承实例方法如也继承等静态方法这是类语法启用的新特性是一个函数但它从继承子类太简单了没有教育意义示例是一个更充实的示例它定义了内置类的子类该子类添加类型检查以确保映射的键和值是指定的类型根据重要的是此示例演示了使用关键字来调用父类的构造函数和方法示例一个检测和类型的子类构造函数的前两个实参是所需的键和值类型这些实参应该是字符串如和这些字符串应该是运算符的返回值还可以指定第三个实参指定中初始条目的数组或任何可迭代对象如果指定任何初始条目则构造函数要做的第一件事是验证其类型是否正确接下来构造函数调用父类构造函数使用关键字就像它是一个函数名称一样构造函数采用一个可选实参可迭代对象的数组因此构造函数的第三个可选实参是构造函数的第一个可选实参我们用将它传递给父类的构造函数调用父类构造函数初始化父类状态后接下来构造函数初始化其自己的子类状态和它需要设置这些属性以便它可以在方法中再次使用它们在构造函数中使用需要了解一些重要规则如果使用关键字定义类则类的构造函数必须使用调用父类构造函数如果未在子类中定义构造函数将自动为你定义一个构造函数此隐式定义的构造函数只将传递给它值传递给在使用调用父类构造函数之前不能在构造函数中使用关键字这个强制规则确保父类先于子类初始化在未使用关键字调用的函数中表达式是但是在构造函数中是引用调用的构造函数当调用子类构造函数并使用调用父类构造函数时该父类构造函数将看到子类构造函数作为的值虽然设计良好的父类不需要知道它是否有子类但在日志记录消息的场景中使用会很有用在构造函数之后示例的下一部分是名为的方法父类定义了名为的方法以向添加新条目中的方法将重写其父类的方法这个简单的子类对向添加新条目一无所知但它知道如何检查类型因此它首先会这样做验证要添加到地图中的键和值的类型是否正确如果它们不正确则抛出异常此方法无法将键和值添加到本身但这就是父类方法的用途因此我们再次使用关键字来调用父类版本的方法在此上下文中的工作方式与关键字的工作方式非常相似它引用当前对象但允许访问在父级类中定义的被重写方法在构造函数中需要先调用父类构造函数然后才能访问和初始化新对象但重写方法时没有此类规则调用重写父类方法时不需要调用父类方法如果它确实使用来调用父类中的重写方法或任何方法它可以在重写方法的开头中间或末尾调用最后在将示例抛在脑后之前值得注意的是此类是使用私有字段的理想场景现在编写类时用户可以更改或属性以破坏类型检查一旦支持私有字段我们可以将这些属性改为和以便它们不能从外部更改关键字便于创建子类但这并不意味着应该创建大量的子类如果要编写某些其他类共享的行为的类可以尝试通过创建子类来继承该行为但是通常将期望的行为编写在类中比用类创建其他类的实例并根据需要委托给该实例更简单也更灵活创建新类不将其作为子类而是通过包装或组合其他类这种委托方法通常称为组合它是一种面向对象编程经常被引用的座右铭倾向于组合而不是继承例如假设我们想要一个行为类似于的类的类只不过它不只是跟踪是否给集合添加了值还维护该值添加次数的计数由于类的与类似因此我们可以考虑子类并添加方法另一方面一旦我们开始考虑如何实现方法我们可能会意识到类更像是一个而不是一个因为它需要维护值与添加它们次数之间的映射因此我们可以创建一个类该类定义一个类似的但委托内部对象来实现这些方法而不是创建的子类示例显示了我们如何做到这一点示例使用委托实现一个类似的类在示例中构造函数创建一个对象大多数方法都是单行它们只是委托给的方法使得实现变得非常简单因为我们使用委托而不是继承所以对象不是或的实例但是实现了许多常用的方法并没有过多的使用额外的这通常足够好有条理的继承关系有时是不错但通常是可选的示例演示了如创建的子类示例演示了如何在不创建子类的情况下将委托给对象使用类封装数据和模块化代码通常是一种很好的技术你可能会发现自己经常使用类关键字但是你可能会发现你更喜欢组合而不是继承而且很少需要使用除非使用需要扩展的库或框架但是在某些情况下多个级别的子类是合适的我们将举一个扩展示例来结束本章通过描述不同种类的集合来演示类的层次结构示例中定义的类跟中的内置类很相似但不完全兼容示例定义了大量子类但它也演示了如何定义抽象类不包括完整实现的类作为一组相关子类的通用父类抽象父类可以定义所有子类继承和共享的部分实现因此子类只需要通过实现父类定义的抽象方法没有实现来定义它们自己的独特行为请注意对抽象方法或抽象类没有任何正式定义我只是将这个名字用于未实现的方法和不完全实现的类示例评论良好并且独立我鼓励你把它作为本章关于类的顶级示例示例用和运算符执行大量位操作可以在中查看这些运算符示例抽象类和实体类的层次本章说明了类的主要功能同一类的成员对象从同一原型对象继承属性原型对象是类的关键特性只有方法可以定义类在之前典型的类定义先定义构造函数使用关键字创建的函数具有原型属性属性的值是使用将函数用作构造函数调用时创建的对象的原型对象通过初始化此原型对象可以定义类的共享方法虽然原型对象是类的关键特性但构造函数是类的公共标识引入了一个关键字它使定义类更加容易但它只是个语法糖构造函数和原型机制保持不变子类使用类声明中的关键字定义子类可以使用关键字调用其父类的构造函数或父类的重写方法除了方法返回的函数绑定函数没有自己的原型属性但如果它们作为构造函数调用则它们使用基础函数的原型例如见作者等或者作者',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-26 21:44:46',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Jackhou Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" alt="wechat" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="alipay" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 1.05rem;">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 1.05rem;">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 1.05rem;">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 1.05rem;">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem;">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 1.05rem;">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 1.05rem;">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 1.05rem;">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 1.05rem;">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.05rem;">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 1.05rem;">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 1.05rem;">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 1.05rem;">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 1.05rem;">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 1.05rem;">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 1.05rem;">越权<sup>2</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">37</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">12</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>《JavaScript权威指南》</span></a><a class="article-meta__tags" href="/tags/JavaScript/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>JavaScript</span></a></span></div></div><h1 class="post-title" itemprop="name headline">第9章 类</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:52.000Z" title="发表于 2023-04-26 00:00:52">2023-04-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:46.000Z" title="更新于 2023-04-26 21:44:46">2023-04-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="第9章 类"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/" itemprop="url">技术</a><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF/JavaScript/" itemprop="url">JavaScript</a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" tabindex="-1" itemprop="url">《JavaScript权威指南》</a><a href="/tags/JavaScript/" tabindex="-1" itemprop="url">JavaScript</a><h1 id="CrawlerTitle" itemprop="name headline">第9章 类</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Jack hou</span><time itemprop="dateCreated datePublished" datetime="2023-04-25T16:00:52.000Z" title="发表于 2023-04-26 00:00:52">2023-04-26</time><time itemprop="dateCreated datePublished" datetime="2023-04-26T13:44:46.000Z" title="更新于 2023-04-26 21:44:46">2023-04-26</time></header><meta name="referrer" content="no-referrer"/>



<p>JavaScript objects were covered in Chapter 6. That chapter treated each object as a unique set of properties, different from every other object. It is often useful, however, to define a class of objects that share certain properties. Members, or instances, of the class have their own properties to hold or define their state, but they also have methods that define their behavior. These methods are defined by the class and shared by all instances. Imagine a class named Complex that represents and performs arithmetic on complex numbers, for example. A Complex instance would have properties to hold the real and imaginary parts (the state) of the complex number. And the Complex class would define methods to perform addition and multiplication (the behavior) of those numbers.</p>
<blockquote>
<p>第 6 章详细介绍了 JavaScript 对象，每个 JavaScript 对象都是一个属性集合，相互之间没有任何联系。在 JavaScript 中也可以定义对象的类，让每个对象都共享某些属性，这种“共享”的特性是非常有用的。类的成员或实例都包含一些属性，用以存放或定义它们的状态，其中有些属性定义了它们的行为（通常称为方法）。这些行为通常是由类定义的，而且为所有实例所共享。例如，假设有一个名为 Complex 的类用来表示复数，同时还定义了一些复数运算。一个 Complex 实例应当包含复数的实部和虚部（状态），同样 Complex 类还会定义复数的加法和乘法操作（行为）。</p>
</blockquote>
<p>In JavaScript, classes use prototype-based inheritance: if two objects inherit properties (generally function-valued properties, or methods) from the same prototype, then we say that those objects are instances of the same class. That, in a nutshell, is how JavaScript classes work. JavaScript prototypes and inheritance were covered in §6.2.3 and §6.3.2, and you will need to be familiar with the material in those sections to understand this chapter. This chapter covers prototypes in §9.1.</p>
<blockquote>
<p>在 JavaScript 中，类的实现是基于其原型继承机制的。如果两个实例都从同一个原型对象上继承了属性，我们说它们是同一个类的实例。JavaScript 原型和继承在 §6.2.3 和 §6.3.2 节中有详细讨论，为了更好地理解本章的内容，请务必首先阅读这两个章节。本章将会在 §9.1 中对原型做进一步讨论。</p>
</blockquote>
<p>If two objects inherit from the same prototype, this typically (but not necessarily) means that they were created and initialized by the same constructor function or factory function. Constructors have been covered in §4.6, §6.2.2, and §8.2.3, and this chapter has more in §9.2.</p>
<blockquote>
<p>如果两个对象继承自同一个原型，往往意味着（但不是绝对）它们是由同一个构造函数创建并初始化的。我们已经在 §4.6、§6.2.2 和 §8.2.3 节中详细讲解了构造函数，§9.2 会有进一步讨论。</p>
</blockquote>
<p>JavaScript has always allowed the definition of classes. ES6 introduced a brand-new syntax (including a class keyword) that makes it even easier to create classes. These new JavaScript classes work in the same way that old-style classes do, and this chapter starts by explaining the old way of creating classes because that demonstrates more clearly what is going on behind the scenes to make classes work. Once we’ve explained those fundamentals, we’ll shift and start using the new, simplified class definition syntax.</p>
<blockquote>
<p>JavaScript 一直允许定义类。ES6 引入了全新的语法（包括 class 关键字），使创建类更加容易。这些新的 JavaScript 类的工作方式与旧式类相同，本章首先解释创建类的旧方法，因为这更清楚地展示了类是如何工作的。一旦我们解释了这些基本原理，我们将改变并开始使用新的、简化的类定义语法。</p>
</blockquote>
<p>If you’re familiar with strongly typed object-oriented programming languages like Java or C++, you’ll notice that JavaScript classes are quite different from classes in those languages. There are some syntactic similarities, and you can emulate many features of “classical” classes in JavaScript, but it is best to understand up front that JavaScript’s classes and prototype-based inheritance mechanism are substantially different from the classes and class-based inheritance mechanism of Java and similar languages.</p>
<blockquote>
<p>如果你对诸如 Java 和 C++ 这种强类型的面向对象编程比较熟悉，你会发现 JavaScript 中的类和 Java 以及 C++ 中的类有很大不同。尽管在写法上类似，而且在 JavaScript 中也能“模拟”出很多经典的类的特性，但是最好要理解 JavaScript 的类和基于原型的继承机制，以及和传统的 Java（当然还有类似 Java 的语言）的类和基于类的继承机制的不同之处。</p>
</blockquote>
<h2 id="9-1-Classes-and-Prototypes"><a href="#9-1-Classes-and-Prototypes" class="headerlink" title="9.1 Classes and Prototypes"></a>9.1 Classes and Prototypes</h2><p>In JavaScript, a class is a set of objects that inherit properties from the same prototype object. The prototype object, therefore, is the central feature of a class. Chapter 6 covered the Object.create() function that returns a newly created object that inherits from a specified prototype object. If we define a prototype object and then use Object.create() to create objects that inherit from it, we have defined a JavaScript class. Usually, the instances of a class require further initialization, and it is common to define a function that creates and initializes the new object. Example 9-1 demonstrates this: it defines a prototype object for a class that represents a range of values and also defines a factory function that creates and initializes a new instance of the class.</p>
<blockquote>
<p>在 JavaScript 中，类的所有实例对象都从同一个原型对象上继承属性。因此，原型对象是类的核心。在示例 6-1 中定义了 inherit() 函数，这个函数返回一个新创建的对象，后者继承自某个原型对象。如果定义一个原型对象，然后通过 inherit() 函数创建一个继承自它的对象，这样就定义了一个 JavaScript 类。通常，类的实例还需要进一步的初始化，通常是通过定义一个函数来创建并初始化这个新对象，参照示例 9-1。示例 9-1 给一个表示“值的范围”的类定义了原型对象，还定义了一个“工厂”函数用以创建并初始化类的实例。</p>
</blockquote>
<p>Example 9-1. A simple JavaScript class</p>
<blockquote>
<p>示例 9-1：一个简单的 JavaScript 类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a factory function that returns a new range object.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">range</span>(<span class="params"><span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">    <span class="comment">// Use Object.create() to create an object that inherits from the</span></span><br><span class="line">    <span class="comment">// prototype object defined below.  The prototype object is stored as</span></span><br><span class="line">    <span class="comment">// a property of this function, and defines the shared methods (behavior)</span></span><br><span class="line">    <span class="comment">// for all range objects.</span></span><br><span class="line">    <span class="keyword">let</span> r = <span class="title class_">Object</span>.<span class="title function_">create</span>(range.<span class="property">methods</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Store the start and end points (state) of this new range object.</span></span><br><span class="line">    <span class="comment">// These are noninherited properties that are unique to this object.</span></span><br><span class="line">    r.<span class="property">from</span> = <span class="keyword">from</span>;</span><br><span class="line">    r.<span class="property">to</span> = to;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally return the new object</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This prototype object defines methods inherited by all range objects.</span></span><br><span class="line">range.<span class="property">methods</span> = &#123;</span><br><span class="line">    <span class="comment">// Return true if x is in the range, false otherwise</span></span><br><span class="line">    <span class="comment">// This method works for textual and Date ranges as well as numeric.</span></span><br><span class="line">    <span class="title function_">includes</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">from</span> &lt;= x &amp;&amp; x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A generator function that makes instances of the class iterable.</span></span><br><span class="line">    <span class="comment">// Note that it only works for numeric ranges.</span></span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="variable language_">this</span>.<span class="property">from</span>); x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; x++) <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a string representation of the range</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">from</span> + <span class="string">&quot;...&quot;</span> + <span class="variable language_">this</span>.<span class="property">to</span> + <span class="string">&quot;)&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here are example uses of a range object.</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="title function_">range</span>(<span class="number">1</span>,<span class="number">3</span>);      <span class="comment">// Create a range object</span></span><br><span class="line">r.<span class="title function_">includes</span>(<span class="number">2</span>)            <span class="comment">// =&gt; true: 2 is in the range</span></span><br><span class="line">r.<span class="title function_">toString</span>()             <span class="comment">// =&gt; &quot;(1...3)&quot;</span></span><br><span class="line">[...r]                   <span class="comment">// =&gt; [1, 2, 3]; convert to an array via iterator</span></span><br></pre></td></tr></table></figure>
<p>There are a few things worth noting in the code of Example 9-1:</p>
<blockquote>
<p>在示例 9-1 的代码中有一下几点值得注意：</p>
</blockquote>
<p>This code defines a factory function range() for creating new Range objects.</p>
<blockquote>
<p>这段代码定义了一个工厂函数 range() 用来创建一个新的 Range 对象。</p>
</blockquote>
<p>It uses the methods property of this range() function as a convenient place to store the prototype object that defines the class. There is nothing special or idiomatic about putting the prototype object here.</p>
<blockquote>
<p>用 range() 函数的 methods 属性来存放定义类的原型对象。只是将原型对象随意的放在一个地方，并不是一个规约或者习惯。</p>
</blockquote>
<p>The range() function defines from and to properties on each Range object. These are the unshared, noninherited properties that define the unique state of each individual Range object.</p>
<blockquote>
<p>range() 函数在每个 Range 对象中都定义 from 和 to 属性。它们是非共享、非继承属性，是每个独立的 Range 对象的独特自有状态。</p>
</blockquote>
<p>The range.methods object uses the ES6 shorthand syntax for defining methods, which is why you don’t see the function keyword anywhere. (See §6.10.5 to review object literal shorthand method syntax.)</p>
<blockquote>
<p>range.methods 对象应用了 ES6 的速记语法来定义方法，这是为什么没有看到 function 关键字的原因。（参照 §6.10.5 来复习对象字面量速记方法语法。）</p>
</blockquote>
<p>One of the methods in the prototype has the computed name (§6.10.2) Symbol.iterator, which means that it is defining an iterator for Range objects. The name of this method is prefixed with *, which indicates that it is a generator function instead of a regular function. Iterators and generators are covered in detail in Chapter 12. For now, the upshot is that instances of this Range class can be used with the for&#x2F;of loop and with the … spread operator.</p>
<blockquote>
<p>原型中的一个方法 Symbol.iterator 使用了计算属性名（§6.10.2），表明它是为 Range 对象定义一个迭代器。方法名称带有一个前缀 *，标识它是一个生成器函数而不是普通的函数。迭代器和生成器在第 12 章会详细描述。现在，只需要知道 Range 类的实例可以用 for&#x2F;of 循环和可以用 … 展开运算符。</p>
</blockquote>
<p>The shared, inherited methods defined in range.methods all use the from and to properties that were initialized in the range() factory function. In order to refer to them, they use the this keyword to refer to the object through which they were invoked. This use of this is a fundamental characteristic of the methods of any class.</p>
<blockquote>
<p>定义在 range.methods 中的共享继承方法都使用在 range() 工厂函数初始化的 from 和 to 属性。在这些方法被调用时，为了引用 from 和 to 属性，都使用 this 关键字来获取对象的引用。this 这种用法是任何类中方法的基本特征。</p>
</blockquote>
<h2 id="9-2-Classes-and-Constructors"><a href="#9-2-Classes-and-Constructors" class="headerlink" title="9.2 Classes and Constructors"></a>9.2 Classes and Constructors</h2><p>Example 9-1 demonstrates a simple way to define a JavaScript class. It is not the idiomatic way to do so, however, because it did not define a constructor. A constructor is a function designed for the initialization of newly created objects. Constructors are invoked using the new keyword as described in §8.2.3. Constructor invocations using new automatically create the new object, so the constructor itself only needs to initialize the state of that new object. The critical feature of constructor invocations is that the prototype property of the constructor is used as the prototype of the new object. §6.2.3 introduced prototypes and emphasized that while almost all objects have a prototype, only a few objects have a prototype property. Finally, we can clarify this: it is function objects that have a prototype property. This means that all objects created with the same constructor function inherit from the same object and are therefore members of the same class. Example 9-2 shows how we could alter the Range class of Example 9-1 to use a constructor function instead of a factory function. Example 9-2 demonstrates the idiomatic way to create a class in versions of JavaScript that do not support the ES6 class keyword. Even though class is well supported now, there is still lots of older JavaScript code around that defines classes like this, and you should be familiar with the idiom so that you can read old code and so that you understand what is going on “under the hood” when you use the class keyword.</p>
<blockquote>
<p>示例 9-1 展示了一个简单方式来定义一个 JavaScript 类。但是这种方法并不常用，因为它没有定义一个构造函数。构造函数是用来初始化新建对象的。如 §8.2.3 中所述构造函数用 new 关键字来调用。使用 new 调用构造函数会自动创建一个新对象，因此构造函数本身只需初始化这个新对象的状态即可。§6.2.3 介绍并强调了虽然所有对象都有原型，但是只有一部分对象有一个 prototype 属性。最后，我们可以澄清这一点：是函数对象具有 prototype 属性。这意味着所有用同一构造函数创建的对象继承同一个对象，因此它们是同一类的成员。示例 9-2 说明了如何使用一个构造函数来替代示例 9-1 中的工厂函数来修改 Range 类。示例 9-2 演示了在不支持 ES6 class 关键字版本的 JavaScript 中创建一个类的通用方法。即使是 class 已经很好支持的今天，仍然有很多旧 JavaScript 代码用这种方式定义类，并且你必须熟悉这种习惯用法，以便于阅读旧代码，也能够在使用 class 关键字时明白在底层中发生了什么。</p>
</blockquote>
<p>Example 9-2. A Range class using a constructor</p>
<blockquote>
<p>示例 9-2：使用构造函数的 Range 类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is a constructor function that initializes new Range objects.</span></span><br><span class="line"><span class="comment">// Note that it does not create or return the object. It just initializes this.</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Range</span>(<span class="params"><span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">    <span class="comment">// Store the start and end points (state) of this new range object.</span></span><br><span class="line">    <span class="comment">// These are noninherited properties that are unique to this object.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">from</span> = <span class="keyword">from</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">to</span> = to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All Range objects inherit from this object.</span></span><br><span class="line"><span class="comment">// Note that the property name must be &quot;prototype&quot; for this to work.</span></span><br><span class="line"><span class="title class_">Range</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="comment">// Return true if x is in the range, false otherwise</span></span><br><span class="line">    <span class="comment">// This method works for textual and Date ranges as well as numeric.</span></span><br><span class="line">    <span class="attr">includes</span>: <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">from</span> &lt;= x &amp;&amp; x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A generator function that makes instances of the class iterable.</span></span><br><span class="line">    <span class="comment">// Note that it only works for numeric ranges.</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]: <span class="keyword">function</span>*() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="variable language_">this</span>.<span class="property">from</span>); x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; x++) <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a string representation of the range</span></span><br><span class="line">    <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">from</span> + <span class="string">&quot;...&quot;</span> + <span class="variable language_">this</span>.<span class="property">to</span> + <span class="string">&quot;)&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here are example uses of this new Range class</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Range</span>(<span class="number">1</span>,<span class="number">3</span>);   <span class="comment">// Create a Range object; note the use of new</span></span><br><span class="line">r.<span class="title function_">includes</span>(<span class="number">2</span>)             <span class="comment">// =&gt; true: 2 is in the range</span></span><br><span class="line">r.<span class="title function_">toString</span>()              <span class="comment">// =&gt; &quot;(1...3)&quot;</span></span><br><span class="line">[...r]                    <span class="comment">// =&gt; [1, 2, 3]; convert to an array via iterator</span></span><br></pre></td></tr></table></figure>
<p>It is worth comparing Examples 9-1 and 9-2 fairly carefully and noting the differences between these two techniques for defining classes. First, notice that we renamed the range() factory function to Range() when we converted it to a constructor. This is a very common coding convention: constructor functions define, in a sense, classes, and classes have names that (by convention) begin with capital letters. Regular functions and methods have names that begin with lowercase letters.</p>
<blockquote>
<p>将示例 9-1 和示例 9-2 中的代码做一个仔细的对比，可以发现两种类定义技术的差别。首先，注意当工厂函数 range() 转化为构造函数时被重命名为 Range()。这里遵循了一个常见的编程约定：从某种意义上讲，定义构造函数即是定义类，并且类名首字母要大写。而普通的函数和方法都是首字母小写。</p>
</blockquote>
<p>Next, notice that the Range() constructor is invoked (at the end of the example) with the new keyword while the range() factory function was invoked without it. Example 9-1 uses regular function invocation (§8.2.1) to create the new object, and Example 9-2 uses constructor invocation (§8.2.3). Because the Range() constructor is invoked with new, it does not have to call Object.create() or take any action to create a new object. The new object is automatically created before the constructor is called, and it is accessible as the this value. The Range() constructor merely has to initialize this. Constructors do not even have to return the newly created object. Constructor invocation automatically creates a new object, invokes the constructor as a method of that object, and returns the new object. The fact that constructor invocation is so different from regular function invocation is another reason that we give constructors names that start with capital letters. Constructors are written to be invoked as constructors, with the new keyword, and they usually won’t work properly if they are invoked as regular functions. A naming convention that keeps constructor functions distinct from regular functions helps programmers know when to use new.</p>
<blockquote>
<p>再者，注意 Range() 构造函数是通过 new 关键字调用的（在示例代码的末尾）， 而 range() 工厂函数则不必使用 new。示例 9-1 通过调用普通函数（§8.2.1）来创建新对象，示例 9-2 则使用构造函数调用（§8.2.3）来创建新对象。由于 Range() 构造函数是通过 new 关键字调用的，因此不必调用 Object.create() 或其他什么逻辑来创建新对象。在调用构造函数之前就已经创建了新对象，并且通过 this 关键字可以获取这个新对象。Range() 构造函数只不过是初始化 this 而已。构造函数甚至不必返回这个新创建的对象，构造函数会自动创建对象，然后将构造函数作为这个对象的方法来调用一次，最后返回这个新对象。构造函数调用与常规函数调用如此不同，实际上，这是我们为构造函数命名以大写字母为名的另一个原因。构造函数就是用来“构造新对象”的，它必须通过关键字 new 调用，如果将构造函数用做普通函数的话，往往不会正常工作。开发者可以通过命名规约来（构造函数首字母大写，普通方法首字母小写）判断是否应当在函数之前冠以关键字 new。</p>
</blockquote>
<p><strong>CONSTRUCTORS AND NEW.TARGET</strong><br>Within a function body, you can tell whether the function has been invoked as a constructor with the special expression new.target. If the value of that expression is defined, then you know that the function was invoked as a constructor, with the new keyword. When we discuss subclasses in §9.5, we’ll see that new.target is not always a reference to the constructor it is used in: it might also refer to the constructor function of a subclass.</p>
<blockquote>
<p>在函数正文中，可以使用特殊的表达式 new.target 来判断函数是否以构造函数的方式调用。如果定义了该表达式的值，那么这个函数是通过 new 关键字调用的构造函数。当我们在 §9.5 中讨论子类时，我们会看到 new.target 不总是其所在的构造函数的引用：它可能还引用子类的构造函数。</p>
</blockquote>
<p>If new.target is undefined, then the containing function was invoked as a function, without the new keyword. JavaScript’s various error constructors can be invoked without new, and if you want to emulate this feature in your own constructors, you can write them like this:</p>
<blockquote>
<p>如果 new.target 是 undefined，那么包含它的函数是作为函数调用的，没有使用 new 关键字。JavaScript 很多异常构造函数可以不使用 new 来调用，如果想模仿这个特性可以这样写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">    <span class="comment">// initialization code goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This technique only works for constructors defined in this old-fashioned way. Classes created with the class keyword do not allow their constructors to be invoked without new.</p>
<blockquote>
<p>这个老式技巧只在构造函数定义时生效。类使用 class 关键字创建，不允许不使用 new 调用它的构造函数。</p>
</blockquote>
<p>Another critical difference between Examples 9-1 and 9-2 is the way the prototype object is named. In the first example, the prototype was range.methods. This was a convenient and descriptive name, but arbitrary. In the second example, the prototype is Range.prototype, and this name is mandatory. An invocation of the Range() constructor automatically uses Range.prototype as the prototype of the new Range object.</p>
<blockquote>
<p>示例 9-1 和 9-2 之间的另一个关键区别是原型对象的命名方式。在第一个示例中，原型是 range.methods。这是一个方便和描述性的名称，但随意。在第二个示例中，原型为 Range.prototype，此名称是规定的。Range() 构造函数的调用自动使用 Range.prototype 作为新 Range 对象的原型。</p>
</blockquote>
<p>Finally, also note the things that do not change between Examples 9-1 and 9-2 : the range methods are defined and invoked in the same way for both classes. Because Example 9-2 demonstrates the idiomatic way to create classes in versions of JavaScript before ES6, it does not use the ES6 shorthand method syntax in the prototype object and explicitly spells out the methods with the function keyword. But you can see that the implementation of the methods is the same in both examples.</p>
<blockquote>
<p>最后，还要注意示例 9-1 和 9-2 之间不变的部分：对两个类来说，range 方法以相同的方式定义和调用。由于示例 9-2 演示了在 ES6 之前在 JavaScript 版本中创建类的惯用方法，因此它没原型对象中使用 ES6 速记方法语法，并且使用 function 关键字显式拼出方法名。但是，可以看到，在这两个示例中，方法的实现是相同的。</p>
</blockquote>
<p>Importantly, note that neither of the two range examples uses arrow functions when defining constructors or methods. Recall from §8.1.3 that functions defined in this way do not have a prototype property and so cannot be used as constructors. Also, arrow functions inherit the this keyword from the context in which they are defined rather than setting it based on the object through which they are invoked, and this makes them useless for methods because the defining characteristic of methods is that they use this to refer to the instance on which they were invoked.</p>
<blockquote>
<p>请注意，在定义构造函数或方法时，两个 range 示例都没使用箭头函数。回想一下，从 §8.1.3 中，用这种方式定义的函数没有原型属性，因此不能用作构造函数。此外，箭头函数从定义它们的上下文中继承 this 关键字，而不是基于调用它们的对象设置 this 值，这使得箭头函数对方法毫无用处，因为方法的定义特征是方法使用 this 关键字来引用调用方法的实例。</p>
</blockquote>
<p>Fortunately, the new ES6 class syntax doesn’t allow the option of defining methods with arrow functions, so this is not a mistake that you can accidentally make when using that syntax. We will cover the ES6 class keyword soon, but first, there are more details to cover about constructors.</p>
<blockquote>
<p>幸运的是，新的 ES6 类语法不允许使用 arrow 函数定义方法，因此这不是使用该语法时可能会意外犯的错误。我们将很快介绍 ES6 类关键字，但首先，有更多关于构造函数的详细信息。</p>
</blockquote>
<h3 id="9-2-1-Constructors-Class-Identity-and-instanceof"><a href="#9-2-1-Constructors-Class-Identity-and-instanceof" class="headerlink" title="9.2.1 Constructors, Class Identity, and instanceof"></a>9.2.1 Constructors, Class Identity, and instanceof</h3><p>As we’ve seen, the prototype object is fundamental to the identity of a class: two objects are instances of the same class if and only if they inherit from the same prototype object. The constructor function that initializes the state of a new object is not fundamental: two constructor functions may have prototype properties that point to the same prototype object. Then, both constructors can be used to create instances of the same class.</p>
<blockquote>
<p>正如我们所看到的，原型对象是类的基本标识：只有两个对象继承同一原型对象时，这两个对象是同一类实例。构造函数的关键点不是初始化新创建对象的状态：两个构造函数可能具有指向同一原型对象的原型属性。那么，两个构造函数都可用于创建同一类的实例。</p>
</blockquote>
<p>Even though constructors are not as fundamental as prototypes, the constructor serves as the public face of a class. Most obviously, the name of the constructor function is usually adopted as the name of the class. We say, for example, that the Range() constructor creates Range objects. More fundamentally, however, constructors are used as the righthand operand of the instanceof operator when testing objects for membership in a class. If we have an object r and want to know if it is a Range object, we can write:</p>
<blockquote>
<p>尽管构造函数不像原型那样重要，但是构造函数充当 class 的大众脸。最明显的是，构造函数的名称通常用作类的名称。例如，我们说 Range() 构造函数创建 Range 对象。然而，更重要的是测试类中对象的成员关系，构造函数在右边被用作 instanceof 运算符的操作数。如果有一个对象 r，并且想知道它是不是一个 Range 对象，可以这样写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">r <span class="keyword">instanceof</span> <span class="title class_">Range</span>   <span class="comment">// =&gt; true: r inherits from Range.prototype</span></span><br></pre></td></tr></table></figure>
<p>The instanceof operator was described in §4.9.4. The lefthand operand should be the object that is being tested, and the righthand operand should be a constructor function that names a class. The expression o instanceof C evaluates to true if o inherits from C.prototype. The inheritance need not be direct: if o inherits from an object that inherits from an object that inherits from C.prototype, the expression will still evaluate to true.</p>
<blockquote>
<p>instanceof 运算符在 §4.9.4 中有描述。左边的操作数是想要测试的对象，右边的操作数是命名类的构造函数。表达式 <code>o instanceof C</code> 计算结果为 true 时，o 继承自 C.prototype。不需要直接继承：如果 o 继承于一个继承了 C.prototype 的对象，表达式的计算结果也仍会是 true。</p>
</blockquote>
<p>Technically speaking, in the previous code example, the instanceof operator is not checking whether r was actually initialized by the Range constructor. Instead, it is checking whether r inherits from Range.prototype. If we define a function Strange() and set its prototype to be the same as Range.prototype, then objects created with new Strange() will count as Range objects as far as instanceof is concerned (they won’t actually work as Range objects, however, because their from and to properties have not been initialized):</p>
<blockquote>
<p>从技术上讲，在上一个代码示例中，instanceof 运算符的实例没有检查 r 是否实际由 Range 构造函数初始化。相反，它是检查 r 是否继承 Range.prototype。如果我们定义一个函数 Strange() 并将其原型设置与 Range.prototype 相同，则使用新 Strange() 创建的对象用 instanceof 运算符将算作 Range 对象（但是，它们实际上不会作为 Range 对象工作，因为它们的 from 和 to 属性尚未初始化）：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Strange</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Strange</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Range</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Strange</span>() <span class="keyword">instanceof</span> <span class="title class_">Range</span>   <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>Even though instanceof cannot actually verify the use of a constructor, it still uses a constructor function as its righthand side because constructors are the public identity of a class.</p>
<blockquote>
<p>实际上即使 instanceof 不能验证使用了构造函数，它仍然使用构造函数作为其右侧，因为构造函数是类的公共标识。</p>
</blockquote>
<p>If you want to test the prototype chain of an object for a specific prototype and do not want to use the constructor function as an intermediary, you can use the isPrototypeOf() method. In Example 9-1, for example, we defined a class without a constructor function, so there is no way to use instanceof with that class. Instead, however, we could test whether an object r was a member of that constructor-less class with this code:</p>
<blockquote>
<p>如果要为特定原型测试对象的原型链，并且不想将构造函数用作媒介，可以使用 isPrototypeOf() 方法。例如，在示例 9-1 中，我们定义了一个没有构造函数的类，因此无法将 instanceof 与该类一起使用。但是，我们可以测试对象 r 是否是具有此代码的无构造函数类的成员：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range.<span class="property">methods</span>.<span class="title function_">isPrototypeOf</span>(r);  <span class="comment">// range.methods is the prototype object.</span></span><br></pre></td></tr></table></figure>
<h3 id="9-2-2-The-constructor-Property"><a href="#9-2-2-The-constructor-Property" class="headerlink" title="9.2.2 The constructor Property"></a>9.2.2 The constructor Property</h3><p>In Example 9-2, we set Range.prototype to a new object that contained the methods for our class. Although it was convenient to express those methods as properties of a single object literal, it was not actually necessary to create a new object. Any regular JavaScript function (excluding arrow functions, generator functions, and async functions) can be used as a constructor, and constructor invocations need a prototype property. Therefore, every regular JavaScript function1 automatically has a prototype property. The value of this property is an object that has a single, non-enumerable constructor property. The value of the constructor property is the function object:</p>
<blockquote>
<p>在示例 9-2 中，将 Range.prototype 定义为一个新对象，这个对象包含类所需要的方法。其实没有必要新创建一个对象，用单个对象字面量的属性就可以方便地定义原型上的方法。任何普通 JavaScript 函数（除箭头函数、生成器函数和异步函数之外）都可以用做构造函数，并且调用构造函数是需要一个 prototype 属性的。因此，每个 JavaScript 函数都自动拥有一个 prototype 属性。这个属性的值是一个对象，这个对象包含唯一一个不可枚举属性 constructor。constructor 属性的值是一个函数对象：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; <span class="comment">// This is a function object.</span></span><br><span class="line"><span class="keyword">let</span> p = F.<span class="property"><span class="keyword">prototype</span></span>;   <span class="comment">// This is the prototype object associated with F.</span></span><br><span class="line"><span class="keyword">let</span> c = p.<span class="property">constructor</span>; <span class="comment">// This is the function associated with the prototype.</span></span><br><span class="line">c === F                <span class="comment">// =&gt; true: F.prototype.constructor === F for any F</span></span><br></pre></td></tr></table></figure>
<p>The existence of this predefined prototype object with its constructor property means that objects typically inherit a constructor property that refers to their constructor. Since constructors serve as the public identity of a class, this constructor property gives the class of an object:</p>
<blockquote>
<p>可以看到构造函数的原型中存在预先定义好的 constructor 属性，这意味着对象通常继承的 constructor 是它们的构造函数的引用。由于构造函数是类的“公共标识”， 因此这个 constructor 属性为对象提供了类。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title function_">F</span>();      <span class="comment">// Create an object o of class F</span></span><br><span class="line">o.<span class="property">constructor</span> === F   <span class="comment">// =&gt; true: the constructor property specifies the class</span></span><br></pre></td></tr></table></figure>
<p>Figure 9-1 illustrates this relationship between the constructor function, its prototype object, the back reference from the prototype to the constructor, and the instances created with the constructor.</p>
<blockquote>
<p>如图 9-1 所示，图 9-1 展示了构造函数和原型对象之间的关系，包括原型到构造函数的反向引用以及构造函数创建的实例。</p>
</blockquote>
<p><Figures figure="9-1">A constructor function, its prototype, and instances</Figures></p>
<p>Notice that Figure 9-1 uses our Range() constructor as an example. In fact, however, the Range class defined in Example 9-2 overwrites the predefined Range.prototype object with an object of its own. And the new prototype object it defines does not have a constructor property. So instances of the Range class, as defined, do not have a constructor property. We can remedy this problem by explicitly adding a constructor to the prototype:</p>
<blockquote>
<p>需要注意的是，图 9-1 用 Range() 构造函数作为示例。但实际上，示例 9-2 中定义的 Range 类使用它自身的一个新对象重写了预定义的 Range.prototype 对象。这个新定义的原型对象不含有 constructor 属性。因此 Range 类的实例也不含有 constructor 属性。我们可以通过补救措施来修正这个问题，显式给原型添加一个构造函数：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Range</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">    <span class="attr">constructor</span>: <span class="title class_">Range</span>,  <span class="comment">// Explicitly set the constructor back-reference</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* method definitions go here */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Another common technique that you are likely to see in older JavaScript code is to use the predefined prototype object with its constructor property and add methods to it one at a time with code like this:</p>
<blockquote>
<p>另一种常见的解决办法是使用预定义的原型对象，预定义的原型对象包含 constructor 属性，然后依次给原型对象添加方法：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Extend the predefined Range.prototype object so we don&#x27;t overwrite</span></span><br><span class="line"><span class="comment">// the automatically created Range.prototype.constructor property.</span></span><br><span class="line"><span class="title class_">Range</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">includes</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">from</span> &lt;= x &amp;&amp; x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Range</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + <span class="variable language_">this</span>.<span class="property">from</span> + <span class="string">&quot;...&quot;</span> + <span class="variable language_">this</span>.<span class="property">to</span> + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="9-3-Classes-with-the-class-Keyword"><a href="#9-3-Classes-with-the-class-Keyword" class="headerlink" title="9.3 Classes with the class Keyword"></a>9.3 Classes with the class Keyword</h2><p>Classes have been part of JavaScript since the very first version of the language, but in ES6, they finally got their own syntax with the introduction of the class keyword. Example 9-3 shows what our Range class looks like when written with this new syntax.</p>
<blockquote>
<p>类自第一个版本以来一直是 JavaScript 的一部分，但在 ES6 中，它们最终引入 class 关键字得到了自己的语法。示例 9-3 显示了使用此新语法编写 Range 类的实现。</p>
</blockquote>
<p>Example 9-3. The Range class rewritten using class</p>
<blockquote>
<p>示例 9-3：使用 class 编写 Range 类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Range</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">        <span class="comment">// Store the start and end points (state) of this new range object.</span></span><br><span class="line">        <span class="comment">// These are noninherited properties that are unique to this object.</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">from</span> = <span class="keyword">from</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">to</span> = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return true if x is in the range, false otherwise</span></span><br><span class="line">    <span class="comment">// This method works for textual and Date ranges as well as numeric.</span></span><br><span class="line">    <span class="title function_">includes</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">from</span> &lt;= x &amp;&amp; x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A generator function that makes instances of the class iterable.</span></span><br><span class="line">    <span class="comment">// Note that it only works for numeric ranges.</span></span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="variable language_">this</span>.<span class="property">from</span>); x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; x++) <span class="keyword">yield</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return a string representation of the range</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="variable language_">this</span>.<span class="keyword">from</span>&#125;</span>...<span class="subst">$&#123;<span class="variable language_">this</span>.to&#125;</span>)`</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here are example uses of this new Range class</span></span><br><span class="line"><span class="keyword">let</span> r = <span class="keyword">new</span> <span class="title class_">Range</span>(<span class="number">1</span>,<span class="number">3</span>);   <span class="comment">// Create a Range object</span></span><br><span class="line">r.<span class="title function_">includes</span>(<span class="number">2</span>)             <span class="comment">// =&gt; true: 2 is in the range</span></span><br><span class="line">r.<span class="title function_">toString</span>()              <span class="comment">// =&gt; &quot;(1...3)&quot;</span></span><br><span class="line">[...r]                    <span class="comment">// =&gt; [1, 2, 3]; convert to an array via iterator</span></span><br></pre></td></tr></table></figure>
<p>It is important to understand that the classes defined in Examples 9-2 and 9-3 work in exactly the same way. The introduction of the class keyword to the language does not alter the fundamental nature of JavaScript’s prototype-based classes. And although Example 9-3 uses the class keyword, the resulting Range object is a constructor function, just like the version defined in Example 9-2. The new class syntax is clean and convenient but is best thought of as “syntactic sugar” for the more fundamental class definition mechanism shown in Example 9-2.</p>
<blockquote>
<p>重要的是要了解，在示例 9-2 和 9-3 中定义的类的工作方式完全相同。将 class 关键字引入语言并不会改变 JavaScript 基于原型的类的基本性质。尽管示例 9-3 使用 class 关键字，但生成的 Range 对象是一个构造函数，就像示例 9-2 中定义的版本一样。新的 class 语法更清洁方便，但是最好将其看作示例 9-2 所示的基本类定义机制的语法糖。</p>
</blockquote>
<p>Note the following things about the class syntax in Example 9-3:</p>
<blockquote>
<p>注意在示例 9-3 中关于 class 语法的一下几点：</p>
</blockquote>
<p>The class is declared with the class keyword, which is followed by the name of class and a class body in curly braces.</p>
<blockquote>
<p>用 class 关键字声明类，后面接一个类名，最后是花括号包含类的正文。</p>
</blockquote>
<p>The class body includes method definitions that use object literal method shorthand (which we also used in Example 9-1), where the function keyword is omitted. Unlike object literals, however, no commas are used to separate the methods from each other. (Although class bodies are superficially similar to object literals, they are not the same thing. In particular, they do not support the definition of properties with name&#x2F;value pairs.)</p>
<blockquote>
<p>类正文包括使用对象字面量方法速记定义的方法（我们在示例 9-1 中也使用了），其中省略了函数关键字。但是，与对象字面量不同，没有用逗号将方法彼此分开。（虽然类正文表面上与对象字面量相似，但它们不是一回事。与对象不同，类不支持具有名&#x2F;值对的属性的定义。</p>
</blockquote>
<p>The keyword constructor is used to define the constructor function for the class. The function defined is not actually named “constructor”, however. The class declaration statement defines a new variable Range and assigns the value of this special constructor function to that variable.</p>
<blockquote>
<p>关键字 constructor 用于定义类的构造函数。但是，定义的函数实际上并不命名为 constructor。类声明语句定义一个新的变量 Range，并将此特殊构造函数的值分配给该变量。</p>
</blockquote>
<p>If your class does not need to do any initialization, you can omit the constructor keyword and its body, and an empty constructor function will be implicitly created for you.</p>
<blockquote>
<p>如果类不需要执行任何初始化，可以省略构造函数关键字及其正文，并将隐式创建一个空构造函数。</p>
</blockquote>
<p>If you want to define a class that subclasses—or inherits from—another class, you can use the extends keyword with the class keyword:</p>
<blockquote>
<p>如果要定义子类（或继承来自另一个类的类），可以使用 extends 关键字与 class 关键字：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Span is like a Range, but instead of initializing it with</span></span><br><span class="line"><span class="comment">// a start and an end, we initialize it with a start and a length</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Span</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Range</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">start, length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (length &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable language_">super</span>(start, start + length);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">super</span>(start + length, start);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Creating subclasses is a whole topic of its own. We’ll return to it, and explain the extends and super keywords shown here, in §9.5.</p>
<blockquote>
<p>创建子类是完整的一节。我们将在 §9.5 重新讲到它，并解释这里的 extends 和 super 关键字。</p>
</blockquote>
<p>Like function declarations, class declarations have both statement and expression forms. Just as we can write:</p>
<blockquote>
<p>与函数声明一样，类声明同时具有语句和表达式形式。正如我们可以写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> square = <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x * x; &#125;;</span><br><span class="line"><span class="title function_">square</span>(<span class="number">3</span>)  <span class="comment">// =&gt; 9</span></span><br><span class="line">we can also <span class="attr">write</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Square</span> = <span class="keyword">class</span> &#123; <span class="title function_">constructor</span>(<span class="params">x</span>) &#123; <span class="variable language_">this</span>.<span class="property">area</span> = x * x; &#125; &#125;;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">3</span>).<span class="property">area</span>  <span class="comment">// =&gt; 9</span></span><br></pre></td></tr></table></figure>
<p>As with function definition expressions, class definition expressions can include an optional class name. If you provide such a name, that name is only defined within the class body itself.</p>
<blockquote>
<p>与函数定义表达式一样，类定义表达式可以包含可选类名。如果提供这样的名称，则该名称仅在类正文本身中有定义。</p>
</blockquote>
<p>Although function expressions are quite common (particularly with the arrow function shorthand), in JavaScript programming, class definition expressions are not something that you are likely to use much unless you find yourself writing a function that takes a class as its argument and returns a subclass.</p>
<blockquote>
<p>尽管函数表达式很常见（尤其是使用箭头函数），但 JavaScript 编程中，类定义表达式可能并不是经常使用，除非正在编写一个以类为实参并返回子类的函数。</p>
</blockquote>
<p>We’ll conclude this introduction to the class keyword by mentioning a couple of important things you should know that are not apparent from class syntax:</p>
<blockquote>
<p>结束对 class 关键字的介绍前，最后提几个重要但是不易注意的类语法：</p>
</blockquote>
<p>All code within the body of a class declaration is implicitly in strict mode (§5.6.3), even if no “use strict” directive appears. This means, for example, that you can’t use octal integer literals or the with statement within class bodies and that you are more likely to get syntax errors if you forget to declare a variable before using it.</p>
<blockquote>
<p>类声明正文中的所有代码都隐式采用严格模式（§5.6.3），即使未出现”use strict”指令。例如，这意味着不能在类正文中使用八进制整数字面量或 with 语句，并且如果在使用变量之前忘记声明变量，则更有可能出现语法错误。</p>
</blockquote>
<p>Unlike function declarations, class declarations are not “hoisted.” Recall from §8.1.1 that function definitions behave as if they had been moved to the top of the enclosing file or enclosing function, meaning that you can invoke a function in code that comes before the actual definition of the function. Although class declarations are like function declarations in some ways, they do not share this hoisting behavior: you cannot instantiate a class before you declare it.</p>
<blockquote>
<p>与函数声明不同，类声明不是”声明提前”的。回想一下 §8.1.1 中，函数定义的行为就像它们被移动到封闭文件的顶部或封闭函数的顶部一样，这意味着可以在函数实际定义之前的代码中调用函数。尽管类声明在某些方面与函数声明一样，但它们不共享这种提前行为：在声明类之前，不能实例化类。</p>
</blockquote>
<h3 id="9-3-1-Static-Methods"><a href="#9-3-1-Static-Methods" class="headerlink" title="9.3.1 Static Methods"></a>9.3.1 Static Methods</h3><p>You can define a static method within a class body by prefixing the method declaration with the static keyword. Static methods are defined as properties of the constructor function rather than properties of the prototype object.</p>
<blockquote>
<p>可以通过使用 static 关键字作为方法声明前缀来定义类正文中的静态方法。静态方法定义为构造函数的属性，而不是原型对象的属性。</p>
</blockquote>
<p>For example, suppose we added the following code to Example 9-3:</p>
<blockquote>
<p>例如，假设我们将以下代码添加到示例 9-3 中：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">parse</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> matches = s.<span class="title function_">match</span>(<span class="regexp">/^\((\d+)\.\.\.(\d+)\)$/</span>);</span><br><span class="line">    <span class="keyword">if</span> (!matches) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`Cannot parse Range from &quot;<span class="subst">$&#123;s&#125;</span>&quot;.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Range</span>(<span class="built_in">parseInt</span>(matches[<span class="number">1</span>]), <span class="built_in">parseInt</span>(matches[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The method defined by this code is Range.parse(), not Range.prototype.parse(), and you must invoke it through the constructor, not through an instance:</p>
<blockquote>
<p>此代码定义的方法是 Range.parse()， 而不是 Range.prototype.parse()， 必须通过构造函数而不是通过实例调用它：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="title class_">Range</span>.<span class="title function_">parse</span>(<span class="string">&#x27;(1...10)&#x27;</span>); <span class="comment">// Returns a new Range object</span></span><br><span class="line">r.<span class="title function_">parse</span>(<span class="string">&#x27;(1...10)&#x27;</span>);             <span class="comment">// TypeError: r.parse is not a function</span></span><br></pre></td></tr></table></figure>
<p>You’ll sometimes see static methods called class methods because they are invoked using the name of the class&#x2F;constructor. When this term is used, it is to contrast class methods with the regular instance methods that are invoked on instances of the class. Because static methods are invoked on the constructor rather than on any particular instance, it almost never makes sense to use the this keyword in a static method.</p>
<blockquote>
<p>有时会看到静态方法称为类方法，因为它们是使用类&#x2F;构造函数的名称调用的。使用此术语时，将类方法与在类实例上调用的常规实例方法进行对比，由于静态方法在构造函数上调用，而不是在任何特定实例上调用，因此在静态方法中使用 this 关键字几乎从来就没有意义。</p>
</blockquote>
<p>We’ll see examples of static methods in Example 9-4.</p>
<blockquote>
<p>我们将在示例 9-4 中看到静态方法的示例。</p>
</blockquote>
<h3 id="9-3-2-Getters-Setters-and-other-Method-Forms"><a href="#9-3-2-Getters-Setters-and-other-Method-Forms" class="headerlink" title="9.3.2 Getters, Setters, and other Method Forms"></a>9.3.2 Getters, Setters, and other Method Forms</h3><p>Within a class body, you can define getter and setter methods (§6.10.6) just as you can in object literals. The only difference is that in class bodies, you don’t put a comma after the getter or setter. Example 9-4 includes a practical example of a getter method in a class.</p>
<blockquote>
<p>在类正文中，可以定义 getter 和 setter 方法（§6.10.6），就像在对象字面量中一样。唯一的区别是，在类正文中，不会将逗号放在 getter 或 setter 之后。示例 9-4 包括类中 getter 方法的实际示例。</p>
</blockquote>
<p>In general, all of the shorthand method definition syntaxes allowed in object literals are also allowed in class bodies. This includes generator methods (marked with *) and methods whose names are the value of an expression in square brackets. In fact, you’ve already seen (in Example 9-3) a generator method with a computed name that makes the Range class iterable:</p>
<blockquote>
<p>通常，对象字面量中允许的所有速记方法定义语法也允许在类正文中使用。这包括生成器方法（用 * 标记）和名称为方括号中表达式值的方法。事实上，已经看到了（在示例 9-3 中）具有计算名称的生成器方法，该方法使 Range 类可重复：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> x = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(<span class="variable language_">this</span>.<span class="property">from</span>); x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; x++) <span class="keyword">yield</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-3-3-Public-Private-and-Static-Fields"><a href="#9-3-3-Public-Private-and-Static-Fields" class="headerlink" title="9.3.3 Public, Private, and Static Fields"></a>9.3.3 Public, Private, and Static Fields</h3><p>In the discussion here of classes defined with the class keyword, we have only described the definition of methods within the class body. The ES6 standard only allows the creation of methods (including getters, setters, and generators) and static methods; it does not include syntax for defining fields. If you want to define a field (which is just an object-oriented synonym for “property”) on a class instance, you must do that in the constructor function or in one of the methods. And if you want to define a static field for a class, you must do that outside the class body, after the class has been defined. Example 9-4 includes examples of both kinds of fields.</p>
<blockquote>
<p>在此处对使用 class 关键字定义的类的讨论中，我们只描述了类正文中方法的定义。ES6 标准只允许创建方法（包括 getter、setter 和生成器）和静态方法；它不包括用于定义字段的语法。如果要在类实例上定义字段（这只是面向对象中”属性”的同义词），则必须在构造函数函数或其中一个方法中这样做。必须在类正文之外类定义后，才能为类定义静态字段。示例 9-4 包括这各种字段的示例。</p>
</blockquote>
<p>Standardization is underway, however, for extended class syntax that allows the definition of instance and static fields, in both public and private forms. The code shown in the rest of this section is not yet standard JavaScript as of early 2020 but is already supported in Chrome and partially supported (public instance fields only) in Firefox. The syntax for public instance fields is in common use by JavaScript programmers using the React framework and the Babel transpiler.</p>
<blockquote>
<p>但是，对于允许以公有和私有形式定义实例和静态字段的扩展类语法正在进行标准化。本节其余部分中显示的代码在 2020 年初还不是标准 JavaScript，但在 Chrome 中已经支持，并且 Firefox 中已部分支持（仅使公有实例字段）。使用 React 框架和 Babel 编译器的 JavaScript 程序员常用公有实例字段的语法。</p>
</blockquote>
<p>Suppose you’re writing a class like this one, with a constructor that initializes three fields:</p>
<blockquote>
<p>假设你正在编写一个这样的类，其中一个构造函数初始化了三个字段：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">size</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">capacity</span> = <span class="number">4096</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">buffer</span> = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="variable language_">this</span>.<span class="property">capacity</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>With the new instance field syntax that is likely to be standardized, you could instead write:</p>
<blockquote>
<p>使用可能标准化的新实例字段语法，可以这样编写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    capacity = <span class="number">4096</span>;</span><br><span class="line">    buffer = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="variable language_">this</span>.<span class="property">capacity</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The field initialization code has moved out of the constructor and now appears directly in the class body. (That code is still run as part of the constructor, of course. If you do not define a constructor, the fields are initialized as part of the implicitly created constructor.) The this. prefixes that appeared on the lefthand side of the assignments are gone, but note that you still must use this. to refer to these fields, even on the righthand side of the initializer assignments. The advantage of initializing your instance fields in this way is that this syntax allows (but does not require) you to put the initializers up at the top of the class definition, making it clear to readers exactly what fields will hold the state of each instance. You can declare fields without an initializer by just writing the name of the field followed by a semicolon. If you do that, the initial value of the field will be undefined. It is better style to always make the initial value explicit for all of your class fields.</p>
<blockquote>
<p>字段初始化代码已移出构造函数，现在直接显示在类正文中。（当然，该代码仍作为构造函数的一部分运行。如果不定义构造函数，则字段初始化为隐式创建的构造函数的一部分。赋值左侧的 this. 前缀消失，但请注意即使是在初始化赋值的右侧，仍必须使用 this. 前缀引用这些字段。这种方式初始化实例字段的优点是，此语法允许（但不需要）将初始化放在类定义的顶部，使读者清楚地了解字段在每个实例将保存的状态。可以通过字段名后面跟一个分号来只声明不初始化一个字段。如果这样做，字段的初始值将是 undefined。显式设定初始化字段的值是比较好的风格。</p>
</blockquote>
<p>Before the addition of this field syntax, class bodies looked a lot like object literals using shortcut method syntax, except that the commas had been removed. This field syntax—with equals signs and semicolons instead of colons and commas—makes it clear that class bodies are not at all the same as object literals.</p>
<blockquote>
<p>在添加字段语法之前，类正文看起来很像使用快捷方法语法的对象字面量，只不过逗号被删除。字段语法（使用等号和分号代替冒号和逗号）清楚地表明类正文与对象字面量不完全相同。</p>
</blockquote>
<p>The same proposal that seeks to standardize these instance fields also defines private instance fields. If you use the instance field initialization syntax shown in the previous example to define a field whose name begins with # (which is not normally a legal character in JavaScript identifiers), that field will be usable (with the # prefix) within the class body but will be invisible and inaccessible (and therefore immutable) to any code outside of the class body. If, for the preceding hypothetical Buffer class, you wanted to ensure that users of the class could not inadvertently modify the size field of an instance, you could use a private #size field instead, then define a getter function to provide read-only access to the value:</p>
<blockquote>
<p>标准化中的实例字段同时也定义了私有实例字段。如果使用上例中所示的实例字段初始化语法来定义其名称以 # 开头的字段（在 JavaScript 标识符中通常不是合法字符），则该字段在类正文中可用（使用 # 前缀），但对类正文之外的任何代码不可见且不可访问（因此不可变）。如果对于前面的 Buffer 类，要确保类的用户不会无意中修改实例的 size 字段，可以改为使用私有 #size 字段，然后定义 getter 函数以提供对值的只读访问：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Buffer</span> &#123;</span><br><span class="line">    #size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.#size; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that private fields must be declared using this new field syntax before they can be used. You can’t just write this.#size &#x3D; 0; in the constructor of a class unless you include a “declaration” of the field directly in the class body.</p>
<blockquote>
<p>请注意，必须先使用新字段语法声明私有字段，然后才能使用它们。你不能只在类的构造函数中写 <code>this.#size = 0;</code>，除非直接在类正文中包含字段的”声明”。</p>
</blockquote>
<p>Finally, a related proposal seeks to standardize the use of the static keyword for fields. If you add static before a public or private field declaration, those fields will be created as properties of the constructor function instead of properties of instances. Consider the static Range.parse() method we’ve defined. It included a fairly complex regular expression that might be good to factor out into its own static field. With the proposed new static field syntax, we could do that like this:</p>
<blockquote>
<p>最后，在标准化过程中相关建议字段使用 static 关键字。如果在公有或私有字段声明之前添加静态字段，这些字段将创建为构造函数的属性，而不是实例的属性。思考我们定义的静态 Range.parse() 方法。它包括一个相当复杂的正则表达式，将其拆分到它自有的静态字段中可能会更好。使用建议的新静态字段语法，我们可以这编写：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> integerRangePattern = <span class="regexp">/^\((\d+)\.\.\.(\d+)\)$/</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="title function_">parse</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> matches = s.<span class="title function_">match</span>(<span class="title class_">Range</span>.<span class="property">integerRangePattern</span>);</span><br><span class="line">    <span class="keyword">if</span> (!matches) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`Cannot parse Range from &quot;<span class="subst">$&#123;s&#125;</span>&quot;.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Range</span>(<span class="built_in">parseInt</span>(matches[<span class="number">1</span>]), matches[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we wanted this static field to be accessible only within the class, we could make it private using a name like #pattern.</p>
<blockquote>
<p>如果我们希望此静态字段只能在类中访问，我们可以使用像 #pattern 这样的名称将其私有化。</p>
</blockquote>
<h3 id="9-3-4-Example-A-Complex-Number-Class"><a href="#9-3-4-Example-A-Complex-Number-Class" class="headerlink" title="9.3.4 Example: A Complex Number Class"></a>9.3.4 Example: A Complex Number Class</h3><p>Example 9-4 defines a class to represent complex numbers. The class is a relatively simple one, but it includes instance methods (including getters), static methods, instance fields, and static fields. It includes some commented-out code demonstrating how we might use the not-yet-standard syntax for defining instance fields and static fields within the class body.</p>
<blockquote>
<p>示例 9-4 定义了一个表示复数的类。该类相对简单，但它包括实例方法（包括 getters）、静态方法、实例字段和静态字段。它包括一些注释掉的代码，演示如何使用尚未加入标准的语法定义类正文中的实例字段和静态字段。</p>
</blockquote>
<p>Example 9-4. Complex.js: a complex number class</p>
<blockquote>
<p>示例 9-4：Complex.js：一个复数类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instances of this Complex class represent complex numbers.</span></span><br><span class="line"><span class="comment"> * Recall that a complex number is the sum of a real number and an</span></span><br><span class="line"><span class="comment"> * imaginary number and that the imaginary number i is the square root of -1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line">    <span class="comment">// Once class field declarations are standardized, we could declare</span></span><br><span class="line">    <span class="comment">// private fields to hold the real and imaginary parts of a complex number</span></span><br><span class="line">    <span class="comment">// here, with code like this:</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// #r = 0;</span></span><br><span class="line">    <span class="comment">// #i = 0;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This constructor function defines the instance fields r and i on every</span></span><br><span class="line">    <span class="comment">// instance it creates. These fields hold the real and imaginary parts of</span></span><br><span class="line">    <span class="comment">// the complex number: they are the state of the object.</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">real, imaginary</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">r</span> = real;       <span class="comment">// This field holds the real part of the number.</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">i</span> = imaginary;  <span class="comment">// This field holds the imaginary part.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here are two instance methods for addition and multiplication</span></span><br><span class="line">    <span class="comment">// of complex numbers. If c and d are instances of this class, we</span></span><br><span class="line">    <span class="comment">// might write c.plus(d) or d.times(c)</span></span><br><span class="line">    <span class="title function_">plus</span>(<span class="params">that</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="variable language_">this</span>.<span class="property">r</span> + that.<span class="property">r</span>, <span class="variable language_">this</span>.<span class="property">i</span> + that.<span class="property">i</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">times</span>(<span class="params">that</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="variable language_">this</span>.<span class="property">r</span> * that.<span class="property">r</span> - <span class="variable language_">this</span>.<span class="property">i</span> * that.<span class="property">i</span>,</span><br><span class="line">                           <span class="variable language_">this</span>.<span class="property">r</span> * that.<span class="property">i</span> + <span class="variable language_">this</span>.<span class="property">i</span> * that.<span class="property">r</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// And here are static variants of the complex arithmetic methods.</span></span><br><span class="line">    <span class="comment">// We could write Complex.sum(c,d) and Complex.product(c,d)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sum</span>(<span class="params">c, d</span>) &#123; <span class="keyword">return</span> c.<span class="title function_">plus</span>(d); &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">product</span>(<span class="params">c, d</span>) &#123; <span class="keyword">return</span> c.<span class="title function_">times</span>(d); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These are some instance methods that are defined as getters</span></span><br><span class="line">    <span class="comment">// so they&#x27;re used like fields. The real and imaginary getters would</span></span><br><span class="line">    <span class="comment">// be useful if we were using private fields this.#r and this.#i</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">real</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">r</span>; &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">imaginary</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i</span>; &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">magnitude</span>() &#123; <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">hypot</span>(<span class="variable language_">this</span>.<span class="property">r</span>, <span class="variable language_">this</span>.<span class="property">i</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Classes should almost always have a toString() method</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;<span class="variable language_">this</span>.r&#125;</span>,<span class="subst">$&#123;<span class="variable language_">this</span>.i&#125;</span>&#125;`</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It is often useful to define a method for testing whether</span></span><br><span class="line">    <span class="comment">// two instances of your class represent the same value</span></span><br><span class="line">    <span class="title function_">equals</span>(<span class="params">that</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> that <span class="keyword">instanceof</span> <span class="title class_">Complex</span> &amp;&amp;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">r</span> === that.<span class="property">r</span> &amp;&amp;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">i</span> === that.<span class="property">i</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once static fields are supported inside class bodies, we could</span></span><br><span class="line">    <span class="comment">// define a useful Complex.ZERO constant like this:</span></span><br><span class="line">    <span class="comment">// static ZERO = new Complex(0,0);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here are some class fields that hold useful predefined complex numbers.</span></span><br><span class="line"><span class="title class_">Complex</span>.<span class="property">ZERO</span> = <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="title class_">Complex</span>.<span class="property">ONE</span> = <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="title class_">Complex</span>.<span class="property">I</span> = <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>With the Complex class of Example 9-4 defined, we can use the constructor, instance fields, instance methods, class fields, and class methods with code like this:</p>
<blockquote>
<p>定义了示例 9-4 的 Complex 类后，我们可以将构造函数、实例字段、实例方法、类字段和类方法如下使用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="number">2</span>, <span class="number">3</span>);     <span class="comment">// Create a new object with the constructor</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="title class_">Complex</span>(c.<span class="property">i</span>, c.<span class="property">r</span>); <span class="comment">// Use instance fields of c</span></span><br><span class="line">c.<span class="title function_">plus</span>(d).<span class="title function_">toString</span>()           <span class="comment">// =&gt; &quot;&#123;5,5&#125;&quot;; use instance methods</span></span><br><span class="line">c.<span class="property">magnitude</span>                    <span class="comment">// =&gt; Math.hypot(2,3); use a getter function</span></span><br><span class="line"><span class="title class_">Complex</span>.<span class="title function_">product</span>(c, d)          <span class="comment">// =&gt; new Complex(0, 13); a static method</span></span><br><span class="line"><span class="title class_">Complex</span>.<span class="property">ZERO</span>.<span class="title function_">toString</span>()        <span class="comment">// =&gt; &quot;&#123;0,0&#125;&quot;; a static property</span></span><br></pre></td></tr></table></figure>
<h2 id="9-4-Adding-Methods-to-Existing-Classes"><a href="#9-4-Adding-Methods-to-Existing-Classes" class="headerlink" title="9.4 Adding Methods to Existing Classes"></a>9.4 Adding Methods to Existing Classes</h2><p>JavaScript’s prototype-based inheritance mechanism is dynamic: an object inherits properties from its prototype, even if the properties of the prototype change after the object is created. This means that we can augment JavaScript classes simply by adding new methods to their prototype objects.</p>
<blockquote>
<p>JavaScript 基于原型的继承机制是动态的：对象从其原型继承属性，即使原型的属性在创建对象后发生更改。这意味着我们只需向原型对象添加新方法，即可扩展 JavaScript 类。</p>
</blockquote>
<p>Here, for example, is code that adds a method for computing the complex conjugate to the Complex class of Example 9-4:</p>
<blockquote>
<p>例如，下面是将计算共轭复数的方法添加到示例 9-4 的 Complex 类的代码：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Return a complex number that is the complex conjugate of this one.</span></span><br><span class="line"><span class="title class_">Complex</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">conj</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Complex</span>(<span class="variable language_">this</span>.<span class="property">r</span>, -<span class="variable language_">this</span>.<span class="property">i</span>); &#125;;</span><br></pre></td></tr></table></figure>

<p>The prototype object of built-in JavaScript classes is also open like this, which means that we can add methods to numbers, strings, arrays, functions, and so on. This is useful for implementing new language features in older versions of the language:</p>
<blockquote>
<p>JavaScript 类内置的原型对象也是这样展现的，这意味着我们可以向数字、字符串、数组、函数等添加方法。这对于在旧版本的语言中实现新特性非常有用：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the new String method startsWith() is not already defined...</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span>) &#123;</span><br><span class="line">    <span class="comment">// ...then define it like this using the older indexOf() method.</span></span><br><span class="line">    <span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span> = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(s) === <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Here is another example:</p>
<blockquote>
<p>这是另外一个例子：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke the function f this many times, passing the iteration number</span></span><br><span class="line"><span class="comment">// For example, to print &quot;hello&quot; 3 times:</span></span><br><span class="line"><span class="comment">//     let n = 3;</span></span><br><span class="line"><span class="comment">//     n.times(i =&gt; &#123; console.log(`hello $&#123;i&#125;`); &#125;);</span></span><br><span class="line"><span class="title class_">Number</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">times</span> = <span class="keyword">function</span>(<span class="params">f, context</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="variable language_">this</span>.<span class="title function_">valueOf</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) f.<span class="title function_">call</span>(context, i);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Adding methods to the prototypes of built-in types like this is generally considered to be a bad idea because it will cause confusion and compatibility problems in the future if a new version of JavaScript defines a method with the same name. It is even possible to add methods to Object.prototype, making them available for all objects. But this is never a good thing to do because properties added to Object.prototype are visible to for&#x2F;in loops (though you can avoid this by using Object.defineProperty() [§14.1] to make the new property non-enumerable).</p>
<blockquote>
<p>向这样在内置类型的原型添加方法通常被认为是一个坏主意，因为如果新版本的 JavaScript 定义具有相同名称的方法，将来就会造成混淆和兼容性问题。甚至可以向 Object.prototype 添加方法，使它们可作用于所有对象。但这从来就不是一件好事，因为添加到 Object.prototype 的属性对 for&#x2F;in 循环可见（尽管可以使用 Object.defineProperty()（§14.1）来使新属性不可枚举来避免这种情况）。</p>
</blockquote>
<h2 id="9-5-Subclasses"><a href="#9-5-Subclasses" class="headerlink" title="9.5 Subclasses"></a>9.5 Subclasses</h2><p>In object-oriented programming, a class B can extend or subclass another class A. We say that A is the superclass and B is the subclass. Instances of B inherit the methods of A. The class B can define its own methods, some of which may override methods of the same name defined by class A. If a method of B overrides a method of A, the overriding method in B often needs to invoke the overridden method in A. Similarly, the subclass constructor B() must typically invoke the superclass constructor A() in order to ensure that instances are completely initialized.</p>
<blockquote>
<p>在面向对象的编程中，B 类可以扩展 A 类或成为 A 类子类。我们称 A 是父类，B 是子类。B 的实例继承 A 的方法。B 类可以定义自有方法，使用相同名称可以重写类 A 中的方法。如果 B 的方法重写 A 方法，则 B 中的重写方法通常需要调用 A 中的重写方法。同样，子类构造函数 B() 通常必须调用父类构造函数 A()，以确保实例完全初始化。</p>
</blockquote>
<p>This section starts by showing how to define subclasses the old, pre-ES6 way, and then quickly moves on to demonstrate subclassing using the class and extends keywords and superclass constructor method invocation with the super keyword. Next is a subsection about avoiding subclasses and relying on object composition instead of inheritance. The section ends with an extended example that defines a hierarchy of Set classes and demonstrates how abstract classes can be used to separate interface from implementation.</p>
<blockquote>
<p>本节首先演示 ES6 之前如何定义子类，然后演示使用 class 和 extends 关键字的子类和使用 super 关键字调用父类构造函数。再接下来一节是关于避免使用子类而依靠对象组合代替继承。本章最后结束于一个扩展的示例，定义 Set 类的层次结构和演示如何使用抽象类将接口与实现分离。</p>
</blockquote>
<h3 id="9-5-1-Subclasses-and-Prototypes"><a href="#9-5-1-Subclasses-and-Prototypes" class="headerlink" title="9.5.1 Subclasses and Prototypes"></a>9.5.1 Subclasses and Prototypes</h3><p>Suppose we wanted to define a Span subclass of the Range class from Example 9-2. This subclass will work just like a Range, but instead of initializing it with a start and an end, we’ll instead specify a start and a distance, or span. An instance of this Span class is also an instance of the Range superclass. A span instance inherits a customized toString() method from Span.prototype, but in order to be a subclass of Range, it must also inherit methods (such as includes()) from Range.prototype.</p>
<blockquote>
<p>假设我们想要给示例 9-2 中 Range 类定义 Span 子类。此子类的工作方式与 Range 一样，但我们初始化改为指定开始和范围，而不是制定开始和结束。Span 类的实例也是父类 Range 的实例。Span 实例从 Span.prototype 继承自定义的 toString() 方法，但为了成为 Range 的子类，它还必须从 Range.prototype 继承方法（如 includes()）。</p>
</blockquote>
<p>Example 9-5. Span.js: a simple subclass of Range</p>
<blockquote>
<p>实例 9-5：Span.js：Range 一个简单的子类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the constructor function for our subclass</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Span</span>(<span class="params">start, span</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (span &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">from</span> = start;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">to</span> = start + span;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">to</span> = start;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">from</span> = start + span;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensure that the Span prototype inherits from the Range prototype</span></span><br><span class="line"><span class="title class_">Span</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Range</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don&#x27;t want to inherit Range.prototype.constructor, so we</span></span><br><span class="line"><span class="comment">// define our own constructor property.</span></span><br><span class="line"><span class="title class_">Span</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Span</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// By defining its own toString() method, Span overrides the</span></span><br><span class="line"><span class="comment">// toString() method that it would otherwise inherit from Range.</span></span><br><span class="line"><span class="title class_">Span</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="variable language_">this</span>.<span class="keyword">from</span>&#125;</span>... +<span class="subst">$&#123;<span class="variable language_">this</span>.to - <span class="variable language_">this</span>.<span class="keyword">from</span>&#125;</span>)`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>In order to make Span a subclass of Range, we need to arrange for Span.prototype to inherit from Range.prototype. The key line of code in the preceding example is this one, and if it makes sense to you, you understand how subclasses work in JavaScript:</p>
<blockquote>
<p>为了使 Span 成为 Range 的子类，我们需要使 Span.prototype 从 Range.prototype 继承。前面示例中的关键代码行是此代码行，如果能理解子类使如何工作的，它是非常有意义的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Span</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Range</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br></pre></td></tr></table></figure>

<p>Objects created with the Span() constructor will inherit from the Span.prototype object. But we created that object to inherit from Range.prototype, so Span objects will inherit from both Span.prototype and Range.prototype.</p>
<blockquote>
<p>使用 Span() 构造函数创建的对象将从 Span.prototype 对象继承。但是，我们创建了该对象并继承 Range.prototype，因此 Span 对象将同时从 Span.prototype 和 Range.prototype 继承。</p>
</blockquote>
<p>You may notice that our Span() constructor sets the same from and to properties that the Range() constructor does and so does not need to invoke the Range() constructor to initialize the new object. Similarly, Span’s toString() method completely re-implements the string conversion without needing to call Range’s version of toString(). This makes Span a special case, and we can only really get away with this kind of subclassing because we know the implementation details of the superclass. A robust subclassing mechanism needs to allow classes to invoke the methods and constructor of their superclass, but prior to ES6, JavaScript did not have a simple way to do these things.</p>
<blockquote>
<p>可能会注意到，我们的 Span() 构造函数设置与 Range() 构造函数相同的 from 和 to 属性，因此不需要调用 Range() 构造函数来初始化新对象。同样，Span 的 toString() 方法完全重新实现字符串转换，而无需调用 Range 版本的 toString()。这使得 Span 成为特例，我们必须摆脱这种子类，因为这种情况是我们知道父类的实现细节。一个健壮的子类机制需要允许类调用其父类的方法和构造函数，但在 ES6 之前，JavaScript 没有一个简单的方法来执行这些操作。</p>
</blockquote>
<p>Fortunately, ES6 solves these problems with the super keyword as part of the class syntax. The next section demonstrates how it works.</p>
<blockquote>
<p>幸运的是，ES6 用 super 关键字作为类语法一部分解决了这些问题。下一节演示它是如何工作的。</p>
</blockquote>
<h3 id="9-5-2-Subclasses-with-extends-and-super"><a href="#9-5-2-Subclasses-with-extends-and-super" class="headerlink" title="9.5.2 Subclasses with extends and super"></a>9.5.2 Subclasses with extends and super</h3><p>In ES6 and later, you can create a superclass simply by adding an extends clause to a class declaration, and you can do this even for built-in classes:</p>
<blockquote>
<p>在 ES6 之后，可以简单的在类声明时接一个 extends 从句添加一个父类，即使对于内置类也可以这样做：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A trivial Array subclass that adds getters for the first and last elements.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EZArray</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Array</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">first</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="number">0</span>]; &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">last</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="variable language_">this</span>.<span class="property">length</span>-<span class="number">1</span>]; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">EZArray</span>();</span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">EZArray</span>  <span class="comment">// =&gt; true: a is subclass instance</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="title class_">Array</span>    <span class="comment">// =&gt; true: a is also a superclass instance.</span></span><br><span class="line">a.<span class="title function_">push</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);      <span class="comment">// a.length == 4; we can use inherited methods</span></span><br><span class="line">a.<span class="title function_">pop</span>()               <span class="comment">// =&gt; 4: another inherited method</span></span><br><span class="line">a.<span class="property">first</span>               <span class="comment">// =&gt; 1: first getter defined by subclass</span></span><br><span class="line">a.<span class="property">last</span>                <span class="comment">// =&gt; 3: last getter defined by subclass</span></span><br><span class="line">a[<span class="number">1</span>]                  <span class="comment">// =&gt; 2: regular array access syntax still works.</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(a)      <span class="comment">// =&gt; true: subclass instance really is an array</span></span><br><span class="line"><span class="title class_">EZArray</span>.<span class="title function_">isArray</span>(a)    <span class="comment">// =&gt; true: subclass inherits static methods, too!</span></span><br></pre></td></tr></table></figure>
<p>This EZArray subclass defines two simple getter methods. Instances of EZArray behave like ordinary arrays, and we can use inherited methods and properties like push(), pop(), and length. But we can also use the first and last getters defined in the subclass. Not only are instance methods like pop() inherited, but static methods like Array.isArray are also inherited. This is a new feature enabled by ES6 class syntax: EZArray() is a function, but it inherits from Array():</p>
<blockquote>
<p>EZArray 子类定义了两个简单的 getter 方法。EZArray 实例的行为类似于普通数组，我们可以使用继承的方法和属性，如 push()、pop() 和 length。但是，我们也可以使用子类中定义的 first 和 last getter 方法。不仅继承实例方法如 pop() ，也继承 Array.isArray 等静态方法。这是 ES6 类语法启用的新特性：EZArray() 是一个函数，但它从 Array() 继承：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EZArray inherits instance methods because EZArray.prototype</span></span><br><span class="line"><span class="comment">// inherits from Array.prototype</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(<span class="title class_">EZArray</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// And EZArray inherits static methods and properties because</span></span><br><span class="line"><span class="comment">// EZArray inherits from Array. This is a special feature of the</span></span><br><span class="line"><span class="comment">// extends keyword and is not possible before ES6.</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isPrototypeOf</span>(<span class="title class_">EZArray</span>) <span class="comment">// =&gt; true</span></span><br></pre></td></tr></table></figure>
<p>Our EZArray subclass is too simple to be very instructive. Example 9-6 is a more fully fleshed-out example. It defines a TypedMap subclass of the built-in Map class that adds type checking to ensure that the keys and values of the map are of the specified types (according to typeof). Importantly, this example demonstrates the use of the super keyword to invoke the constructor and methods of the superclass.</p>
<blockquote>
<p>EZArray 子类太简单了，没有教育意义。示例 9-6 是一个更充实的示例。它定义了内置 Map 类的 TypedMap 子类，该子类添加类型检查以确保映射的键和值是指定的类型（根据 typeof）。重要的是，此示例演示了使用 super 关键字来调用父类的构造函数和方法。</p>
</blockquote>
<p>Example 9-6. TypedMap.js: a subclass of Map that checks key and value types</p>
<blockquote>
<p>示例 9-6：TypedMap.js：一个检测 key 和 value 类型的 Map 子类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypedMap</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Map</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">keyType, valueType, entries</span>) &#123;</span><br><span class="line">        <span class="comment">// If entries are specified, check their types</span></span><br><span class="line">        <span class="keyword">if</span> (entries) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> [k, v] <span class="keyword">of</span> entries) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> k !== keyType || <span class="keyword">typeof</span> v !== valueType) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`Wrong type for entry [<span class="subst">$&#123;k&#125;</span>, <span class="subst">$&#123;v&#125;</span>]`</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the superclass with the (type-checked) initial entries</span></span><br><span class="line">        <span class="variable language_">super</span>(entries);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// And then initialize this subclass by storing the types</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">keyType</span> = keyType;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">valueType</span> = valueType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now redefine the set() method to add type checking for any</span></span><br><span class="line">    <span class="comment">// new entries added to the map.</span></span><br><span class="line">    <span class="title function_">set</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">        <span class="comment">// Throw an error if the key or value are of the wrong type</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">keyType</span> &amp;&amp; <span class="keyword">typeof</span> key !== <span class="variable language_">this</span>.<span class="property">keyType</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is not of type <span class="subst">$&#123;<span class="variable language_">this</span>.keyType&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">valueType</span> &amp;&amp; <span class="keyword">typeof</span> value !== <span class="variable language_">this</span>.<span class="property">valueType</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`<span class="subst">$&#123;value&#125;</span> is not of type <span class="subst">$&#123;<span class="variable language_">this</span>.valueType&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the types are correct, we invoke the superclass&#x27;s version of</span></span><br><span class="line">        <span class="comment">// the set() method, to actually add the entry to the map. And we</span></span><br><span class="line">        <span class="comment">// return whatever the superclass method returns.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">set</span>(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The first two arguments to the TypedMap() constructor are the desired key and value types. These should be strings, such as “number” and “boolean”, that the typeof operator returns. You can also specify a third argument: an array (or any iterable object) of [key,value] arrays that specify the initial entries in the map. If you specify any initial entries, then the first thing the constructor does is verify that their types are correct. Next, the constructor invokes the superclass constructor, using the super keyword as if it was a function name. The Map() constructor takes one optional argument: an iterable object of [key,value] arrays. So the optional third argument of the TypedMap() constructor is the optional first argument to the Map() constructor, and we pass it to that superclass constructor with super(entries).</p>
<blockquote>
<p>TypedMap() 构造函数的前两个实参是所需的键和值类型。这些实参应该是字符串，如”number”和”boolean”，这些字符串应该是 typeof 运算符的返回值。还可以指定第三个实参：指定 map 中初始条目的 [key,value] 数组（或任何可迭代对象）。如果指定任何初始条目，则构造函数要做的第一件事是验证其类型是否正确。接下来，构造函数调用父类构造函数，使用 super 关键字，就像它是一个函数名称一样。Map() 构造函数采用一个可选实参：可迭代对象 [key,value] 的数组。因此，TypedMap() 构造函数的第三个可选实参是 Map() 构造函数的第一个可选实参，我们用 <code>super(entries)</code> 将它传递给父类的构造函数。</p>
</blockquote>
<p>After invoking the superclass constructor to initialize superclass state, the TypedMap() constructor next initializes its own subclass state by setting this.keyType and this.valueType to the specified types. It needs to set these properties so that it can use them again in the set() method.</p>
<blockquote>
<p>调用父类构造函数初始化父类状态后，接下来 TypedMap() 构造函数初始化其自己的子类状态 this.keyType 和 this.valueType。它需要设置这些属性，以便它可以在 set() 方法中再次使用它们。</p>
</blockquote>
<p>There are a few important rules that you will need to know about using super() in constructors:</p>
<blockquote>
<p>在构造函数中使用 super() 需要了解一些重要规则：</p>
</blockquote>
<p>If you define a class with the extends keyword, then the constructor for your class must use super() to invoke the superclass constructor.</p>
<blockquote>
<p>如果使用 extends 关键字定义类，则类的构造函数必须使用 super() 调用父类构造函数。</p>
</blockquote>
<p>If you don’t define a constructor in your subclass, one will be defined automatically for you. This implicitly defined constructor simply takes whatever values are passed to it and passes those values to super().</p>
<blockquote>
<p>如果未在子类中定义构造函数，将自动为你定义一个构造函数。此隐式定义的构造函数只将传递给它值传递给 super()。</p>
</blockquote>
<p>You may not use the this keyword in your constructor until after you have invoked the superclass constructor with super(). This enforces a rule that superclasses get to initialize themselves before subclasses do.</p>
<blockquote>
<p>在使用 super() 调用父类构造函数之前，不能在构造函数中使用 this 关键字。这个强制规则确保父类先于子类初始化。</p>
</blockquote>
<p>The special expression new.target is undefined in functions that are invoked without the new keyword. In constructor functions, however, new.target is a reference to the constructor that was invoked. When a subclass constructor is invoked and uses super() to invoke the superclass constructor, that superclass constructor will see the subclass constructor as the value of new.target. A well-designed superclass should not need to know whether it has been subclassed, but it might be useful to be able to use new.target.name in logging messages, for example.</p>
<blockquote>
<p>在未使用 new 关键字调用的函数中，new.target 表达式是 undefined。但是，在构造函数中，new.target 是引用调用的构造函数。当调用子类构造函数并使用 super() 调用父类构造函数时，该父类构造函数将看到子类构造函数作为 new.target 的值。虽然设计良好的父类不需要知道它是否有子类，但，在日志记录消息的场景中使用 new.target.name 会很有用。</p>
</blockquote>
<p>After the constructor, the next part of Example 9-6 is a method named set(). The Map superclass defines a method named set() to add a new entry to the map. We say that this set() method in TypedMap overrides the set() method of its superclass. This simple TypedMap subclass doesn’t know anything about adding new entries to map, but it does know how to check types, so that is what it does first, verifying that the key and value to be added to the map have the correct types and throwing an error if they do not. This set() method doesn’t have any way to add the key and value to the map itself, but that is what the superclass set() method is for. So we use the super keyword again to invoke the superclass’s version of the method. In this context, super works much like the this keyword does: it refers to the current object but allows access to overridden methods defined in the superclass.</p>
<blockquote>
<p>在构造函数之后，示例 9-6 的下一部分是名为 set() 的方法。Map 父类定义了名为 set() 的方法，以向 Map 添加新条目。TypedMap 中的 set() 方法将重写其父类的 set() 方法。这个简单的 TypedMap 子类对向 Map 添加新条目一无所知，但它知道如何检查类型，因此它首先会这样做，验证要添加到地图中的键和值的类型是否正确，如果它们不正确则抛出异常。此 set() 方法无法将键和值添加到 Map 本身，但这就是父类 set() 方法的用途。因此，我们再次使用 super 关键字来调用父类版本的 set() 方法。在此上下文中，super 的工作方式与 this 关键字的工作方式非常相似：它引用当前对象，但允许访问在父级类中定义的被重写方法。</p>
</blockquote>
<p>In constructors, you are required to invoke the superclass constructor before you can access this and initialize the new object yourself. There are no such rules when you override a method. A method that overrides a superclass method is not required to invoke the superclass method. If it does use super to invoke the overridden method (or any method) in the superclass, it can do that at the beginning or the middle or the end of the overriding method.</p>
<blockquote>
<p>在构造函数中，需要先调用父类构造函数，然后才能访问 this 和初始化新对象。但重写方法时没有此类规则。调用重写父类方法时不需要调用父类方法。如果它确实使用 super 来调用父类中的重写方法（或任何方法），它可以在重写方法的开头、中间或末尾调用。</p>
</blockquote>
<p>Finally, before we leave the TypedMap example behind, it is worth noting that this class is an ideal candidate for the use of private fields. As the class is written now, a user could change the keyType or valueType properties to subvert the type checking. Once private fields are supported, we could change these properties to #keyType and #valueType so that they could not be altered from the outside.</p>
<blockquote>
<p>最后，在将 TypedMap 示例抛在脑后之前，值得注意的是，此类是使用私有字段的理想场景。现在编写类时，用户可以更改 keyType 或 valueType 属性以破坏类型检查。一旦支持私有字段，我们可以将这些属性改为 #keyType 和 #valueType，以便它们不能从外部更改。</p>
</blockquote>
<h3 id="9-5-3-Delegation-Instead-of-Inheritance"><a href="#9-5-3-Delegation-Instead-of-Inheritance" class="headerlink" title="9.5.3 Delegation Instead of Inheritance"></a>9.5.3 Delegation Instead of Inheritance</h3><p>The extends keyword makes it easy to create subclasses. But that does not mean that you should create lots of subclasses. If you want to write a class that shares the behavior of some other class, you can try to inherit that behavior by creating a subclass. But it is often easier and more flexible to get that desired behavior into your class by having your class create an instance of the other class and simply delegating to that instance as needed. You create a new class not by subclassing, but instead by wrapping or “composing” other classes. This delegation approach is often called “composition”, and it is an oft-quoted maxim of object-oriented programming that one should “favor composition over inheritance.”2</p>
<blockquote>
<p>extends 关键字便于创建子类。但这并不意味着应该创建大量的子类。如果要编写某些其他类共享的行为的类，可以尝试通过创建子类来继承该行为。但是，通常将期望的行为编写在类中比用类创建其他类的实例并根据需要委托给该实例更简单也更灵活。创建新类不将其作为子类，而是通过包装或”组合”其他类。这种委托方法通常称为”组合”，它是一种面向对象编程经常被引用的座右铭”倾向于组合而不是继承”。^2</p>
</blockquote>
<p>Suppose, for example, we wanted a Histogram class that behaves something like JavaScript’s Set class, except that instead of just keeping track of whether a value has been added to set or not, it instead maintains a count of the number of times the value has been added. Because the API for this Histogram class is similar to Set, we might consider subclassing Set and adding a count() method. On the other hand, once we start thinking about how we might implement this count() method, we might realize that the Histogram class is more like a Map than a Set because it needs to maintain a mapping between values and the number of times they have been added. So instead of subclassing Set, we can create a class that defines a Set-like API but implements those methods by delegating to an internal Map object. Example 9-7 shows how we could do this.</p>
<blockquote>
<p>例如，假设我们想要一个行为类似于 JavaScript 的 Set 类的 Histogram 类，只不过，它不只是跟踪是否给集合添加了值，还维护该值添加次数的计数。由于 Histogram 类的 API 与 Set 类似，因此我们可以考虑 Set 子类并添加 count() 方法。另一方面，一旦我们开始考虑如何实现 count() 方法，我们可能会意识到 Histogram 类更像是一个 Map 而不是一个 Set，因为它需要维护值与添加它们次数之间的映射。因此，我们可以创建一个类，该类定义一个类似 Set 的 API，但委托内部 Map 对象来实现这些方法，而不是创建 Set 的子类。示例 9-7 显示了我们如何做到这一点。</p>
</blockquote>
<p>Example 9-7. Histogram.js: a Set-like class implemented with delegation</p>
<blockquote>
<p>示例 9-7：Histogram.js：使用委托实现一个类似 Set 的类</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Set-like class that keeps track of how many times a value has</span></span><br><span class="line"><span class="comment"> * been added. Call add() and remove() like you would for a Set, and</span></span><br><span class="line"><span class="comment"> * call count() to find out how many times a given value has been added.</span></span><br><span class="line"><span class="comment"> * The default iterator yields the values that have been added at least</span></span><br><span class="line"><span class="comment"> * once. Use entries() if you want to iterate [value, count] pairs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Histogram</span> &#123;</span><br><span class="line">    <span class="comment">// To initialize, we just create a Map object to delegate to</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="property">map</span> = <span class="keyword">new</span> <span class="title class_">Map</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For any given key, the count is the value in the Map, or zero</span></span><br><span class="line">    <span class="comment">// if the key does not appear in the Map.</span></span><br><span class="line">    <span class="title function_">count</span>(<span class="params">key</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">get</span>(key) || <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Set-like method has() returns true if the count is non-zero</span></span><br><span class="line">    <span class="title function_">has</span>(<span class="params">key</span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">count</span>(key) &gt; <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The size of the histogram is just the number of entries in the Map.</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="property">size</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To add a key, just increment its count in the Map.</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="params">key</span>) &#123; <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(key, <span class="variable language_">this</span>.<span class="title function_">count</span>(key) + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Deleting a key is a little trickier because we have to delete</span></span><br><span class="line">    <span class="comment">// the key from the Map if the count goes back down to zero.</span></span><br><span class="line">    <span class="title function_">delete</span>(<span class="params">key</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> count = <span class="variable language_">this</span>.<span class="title function_">count</span>(key);</span><br><span class="line">        <span class="keyword">if</span> (count === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">delete</span>(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">set</span>(key, count - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterating a Histogram just returns the keys stored in it</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">keys</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These other iterator methods just delegate to the Map object</span></span><br><span class="line">    <span class="title function_">keys</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">keys</span>(); &#125;</span><br><span class="line">    <span class="title function_">values</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">values</span>(); &#125;</span><br><span class="line">    <span class="title function_">entries</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">map</span>.<span class="title function_">entries</span>(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>All the Histogram() constructor does in Example 9-7 is create a Map object. And most of the methods are one-liners that just delegate to a method of the map, making the implementation quite simple. Because we used delegation rather than inheritance, a Histogram object is not an instance of Set or Map. But Histogram implements a number of commonly used Set methods, and in an untyped language like JavaScript, that is often good enough: a formal inheritance relationship is sometimes nice, but often optional.</p>
<blockquote>
<p>在示例 9-7 中，Histogram() 构造函数创建一个 Map 对象。大多数方法都是单行，它们只是委托给 Map 的方法，使得实现变得非常简单。因为我们使用委托而不是继承，所以 Histogram 对象不是 Set 或 Map 的实例。但是，Histogram 实现了许多常用的 Set 方法，并没有过多的使用额外的 JavaScript，这通常足够好：有条理的继承关系有时是不错，但通常是可选的。</p>
</blockquote>
<h3 id="9-5-4-Class-Hierarchies-and-Abstract-Classes"><a href="#9-5-4-Class-Hierarchies-and-Abstract-Classes" class="headerlink" title="9.5.4 Class Hierarchies and Abstract Classes"></a>9.5.4 Class Hierarchies and Abstract Classes</h3><p>Example 9-6 demonstrated how we can subclass Map. Example 9-7 demonstrated how we can instead delegate to a Map object without actually subclassing anything. Using JavaScript classes to encapsulate data and modularize your code is often a great technique, and you may find yourself using the class keyword frequently. But you may find that you prefer composition to inheritance and that you rarely need to use extends (except when you’re using a library or framework that requires you to extend its base classes).</p>
<blockquote>
<p>示例 9-6 演示了如创建 Map 的子类。示例 9-7 演示了如何在不创建子类的情况下将委托给 Map 对象。使用 JavaScript 类封装数据和模块化代码通常是一种很好的技术，你可能会发现自己经常使用类关键字。但是，你可能会发现，你更喜欢组合而不是继承，而且很少需要使用 extends（除非使用需要扩展的库或框架）。</p>
</blockquote>
<p>There are some circumstances when multiple levels of subclassing are appropriate, however, and we’ll end this chapter with an extended example that demonstrates a hierarchy of classes representing different kinds of sets. (The set classes defined in Example 9-8 are similar to, but not completely compatible with, JavaScript’s built-in Set class.)</p>
<blockquote>
<p>但是，在某些情况下，多个级别的子类是合适的，我们将举一个扩展示例来结束本章，通过描述不同种类的集合来演示类的层次结构。（示例 9-8 中定义的类跟 JavaScript 中的内置 Set 类很相似，但不完全兼容。）</p>
</blockquote>
<p>Example 9-8 defines lots of subclasses, but it also demonstrates how you can define abstract classes—classes that do not include a complete implementation—to serve as a common superclass for a group of related subclasses. An abstract superclass can define a partial implementation that all subclasses inherit and share. The subclasses, then, only need to define their own unique behavior by implementing the abstract methods defined—but not implemented—by the superclass. Note that JavaScript does not have any formal definition of abstract methods or abstract classes; I’m simply using that name here for unimplemented methods and incompletely implemented classes.</p>
<blockquote>
<p>示例 9-8 定义了大量子类，但它也演示了如何定义抽象类（不包括完整实现的类）作为一组相关子类的通用父类。抽象父类可以定义所有子类继承和共享的部分实现。因此，子类只需要通过实现父类定义的抽象方法（没有实现）来定义它们自己的独特行为。请注意，JavaScript 对抽象方法或抽象类没有任何正式定义；我只是将这个名字用于未实现的方法和不完全实现的类。</p>
</blockquote>
<p>Example 9-8 is well commented and stands on its own. I encourage you to read it as a capstone example for this chapter on classes. The final class in Example 9-8 does a lot of bit manipulation with the &amp;, |, and ~ operators, which you can review in §4.8.3.</p>
<blockquote>
<p>示例 9-8 评论良好，并且独立。我鼓励你把它作为本章关于类的顶级示例。示例 9-8 用 &amp;、| 和 ~ 运算符执行大量位操作，可以在 §4.8.3 中查看这些运算符。</p>
</blockquote>
<p>Example 9-8. Sets.js: a hierarchy of abstract and concrete set classes</p>
<blockquote>
<p>示例 9-8：Sets.js：抽象类和实体类的层次</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The AbstractSet class defines a single abstract method, has().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractSet</span> &#123;</span><br><span class="line">    <span class="comment">// Throw an error here so that subclasses are forced</span></span><br><span class="line">    <span class="comment">// to define their own working version of this method.</span></span><br><span class="line">    <span class="title function_">has</span>(<span class="params">x</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NotSet is a concrete subclass of AbstractSet.</span></span><br><span class="line"><span class="comment"> * The members of this set are all values that are not members of some</span></span><br><span class="line"><span class="comment"> * other set. Because it is defined in terms of another set it is not</span></span><br><span class="line"><span class="comment"> * writable, and because it has infinite members, it is not enumerable.</span></span><br><span class="line"><span class="comment"> * All we can do with it is test for membership and convert it to a</span></span><br><span class="line"><span class="comment"> * string using mathematical notation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractSet</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">set</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">set</span> = set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Our implementation of the abstract method we inherited</span></span><br><span class="line">    <span class="title function_">has</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> !<span class="variable language_">this</span>.<span class="property">set</span>.<span class="title function_">has</span>(x); &#125;</span><br><span class="line">    <span class="comment">// And we also override this Object method</span></span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`&#123; x| x ∉ <span class="subst">$&#123;<span class="variable language_">this</span>.set.toString()&#125;</span> &#125;`</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Range set is a concrete subclass of AbstractSet. Its members are</span></span><br><span class="line"><span class="comment"> * all values that are between the from and to bounds, inclusive.</span></span><br><span class="line"><span class="comment"> * Since its members can be floating point numbers, it is not</span></span><br><span class="line"><span class="comment"> * enumerable and does not have a meaningful size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RangeSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractSet</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="keyword">from</span>, to</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">from</span> = <span class="keyword">from</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">to</span> = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">has</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x &gt;= <span class="variable language_">this</span>.<span class="property">from</span> &amp;&amp; x &lt;= <span class="variable language_">this</span>.<span class="property">to</span>; &#125;</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`&#123; x| <span class="subst">$&#123;<span class="variable language_">this</span>.<span class="keyword">from</span>&#125;</span> ≤ x ≤ <span class="subst">$&#123;<span class="variable language_">this</span>.to&#125;</span> &#125;`</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AbstractEnumerableSet is an abstract subclass of AbstractSet.  It defines</span></span><br><span class="line"><span class="comment"> * an abstract getter that returns the size of the set and also defines an</span></span><br><span class="line"><span class="comment"> * abstract iterator. And it then implements concrete isEmpty(), toString(),</span></span><br><span class="line"><span class="comment"> * and equals() methods on top of those. Subclasses that implement the</span></span><br><span class="line"><span class="comment"> * iterator, the size getter, and the has() method get these concrete</span></span><br><span class="line"><span class="comment"> * methods for free.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractEnumerableSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractSet</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">size</span> === <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="title function_">toString</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">`&#123;<span class="subst">$&#123;<span class="built_in">Array</span>.<span class="keyword">from</span>(<span class="variable language_">this</span>).join(<span class="string">&quot;, &quot;</span>)&#125;</span>&#125;`</span>; &#125;</span><br><span class="line">    <span class="title function_">equals</span>(<span class="params">set</span>) &#123;</span><br><span class="line">        <span class="comment">// If the other set is not also Enumerable, it isn&#x27;t equal to this one</span></span><br><span class="line">        <span class="keyword">if</span> (!(set <span class="keyword">instanceof</span> <span class="title class_">AbstractEnumerableSet</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If they don&#x27;t have the same size, they&#x27;re not equal</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">size</span> !== set.<span class="property">size</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Loop through the elements of this set</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">            <span class="comment">// If an element isn&#x27;t in the other set, they aren&#x27;t equal</span></span><br><span class="line">            <span class="keyword">if</span> (!set.<span class="title function_">has</span>(element)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The elements matched, so the sets are equal</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SingletonSet is a concrete subclass of AbstractEnumerableSet.</span></span><br><span class="line"><span class="comment"> * A singleton set is a read-only set with a single member.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractEnumerableSet</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">member</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">member</span> = member;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We implement these three methods, and inherit isEmpty, equals()</span></span><br><span class="line">    <span class="comment">// and toString() implementations based on these methods.</span></span><br><span class="line">    <span class="title function_">has</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x === <span class="variable language_">this</span>.<span class="property">member</span>; &#125;</span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123; <span class="keyword">yield</span> <span class="variable language_">this</span>.<span class="property">member</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * AbstractWritableSet is an abstract subclass of AbstractEnumerableSet.</span></span><br><span class="line"><span class="comment"> * It defines the abstract methods insert() and remove() that insert and</span></span><br><span class="line"><span class="comment"> * remove individual elements from the set, and then implements concrete</span></span><br><span class="line"><span class="comment"> * add(), subtract(), and intersect() methods on top of those. Note that</span></span><br><span class="line"><span class="comment"> * our API diverges here from the standard JavaScript Set class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractWritableSet</span> <span class="keyword">extends</span>  <span class="title class_ inherited__">AbstractEnumerableSet</span> &#123;</span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">x</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">x</span>) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Abstract method&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">add</span>(<span class="params">set</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> set) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">insert</span>(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">subtract</span>(<span class="params">set</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> set) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">remove</span>(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">intersect</span>(<span class="params">set</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> element <span class="keyword">of</span> <span class="variable language_">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">remove</span>(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A BitSet is a concrete subclass of AbstractWritableSet with a</span></span><br><span class="line"><span class="comment"> * very efficient fixed-size set implementation for sets whose</span></span><br><span class="line"><span class="comment"> * elements are non-negative integers less than some maximum size.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitSet</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractWritableSet</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">max</span> = max;  <span class="comment">// The maximum integer we can store.</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">n</span> = <span class="number">0</span>;      <span class="comment">// How many integers are in the set</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">numBytes</span> = <span class="title class_">Math</span>.<span class="title function_">floor</span>(max / <span class="number">8</span>) + <span class="number">1</span>;   <span class="comment">// How many bytes we need</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span> = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>(<span class="variable language_">this</span>.<span class="property">numBytes</span>); <span class="comment">// The bytes</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Internal method to check if a value is a legal member of this set</span></span><br><span class="line">    <span class="title function_">_valid</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> <span class="title class_">Number</span>.<span class="title function_">isInteger</span>(x) &amp;&amp; x &gt;= <span class="number">0</span> &amp;&amp; x &lt;= <span class="variable language_">this</span>.<span class="property">max</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tests whether the specified bit of the specified byte of our</span></span><br><span class="line">    <span class="comment">// data array is set or not. Returns true or false.</span></span><br><span class="line">    <span class="title function_">_has</span>(<span class="params">byte, bit</span>) &#123; <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">data</span>[byte] &amp; <span class="title class_">BitSet</span>.<span class="property">bits</span>[bit]) !== <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Is the value x in this BitSet?</span></span><br><span class="line">    <span class="title function_">has</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">_valid</span>(x)) &#123;</span><br><span class="line">            <span class="keyword">let</span> byte = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">let</span> bit = x % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_has</span>(byte, bit);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert the value x into the BitSet</span></span><br><span class="line">    <span class="title function_">insert</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">_valid</span>(x)) &#123;               <span class="comment">// If the value is valid</span></span><br><span class="line">            <span class="keyword">let</span> byte = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">8</span>);   <span class="comment">// convert to byte and bit</span></span><br><span class="line">            <span class="keyword">let</span> bit = x % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">_has</span>(byte, bit)) &#123;    <span class="comment">// If that bit is not set yet</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">data</span>[byte] |= <span class="title class_">BitSet</span>.<span class="property">bits</span>[bit]; <span class="comment">// then set it</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">n</span>++;                            <span class="comment">// and increment set size</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Invalid set element: &quot;</span> + x );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">remove</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">_valid</span>(x)) &#123;              <span class="comment">// If the value is valid</span></span><br><span class="line">            <span class="keyword">let</span> byte = <span class="title class_">Math</span>.<span class="title function_">floor</span>(x / <span class="number">8</span>);  <span class="comment">// compute the byte and bit</span></span><br><span class="line">            <span class="keyword">let</span> bit = x % <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">_has</span>(byte, bit)) &#123;    <span class="comment">// If that bit is already set</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">data</span>[byte] &amp;= <span class="title class_">BitSet</span>.<span class="property">masks</span>[bit];  <span class="comment">// then unset it</span></span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">n</span>--;                              <span class="comment">// and decrement size</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Invalid set element: &quot;</span> + x );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A getter to return the size of the set</span></span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">size</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">n</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate the set by just checking each bit in turn.</span></span><br><span class="line">    <span class="comment">// (We could be a lot more clever and optimize this substantially)</span></span><br><span class="line">    *[<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="variable language_">this</span>.<span class="property">max</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(i)) &#123;</span><br><span class="line">                <span class="keyword">yield</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some pre-computed values used by the has(), insert() and remove() methods</span></span><br><span class="line"><span class="title class_">BitSet</span>.<span class="property">bits</span> = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>, <span class="number">128</span>]);</span><br><span class="line"><span class="title class_">BitSet</span>.<span class="property">masks</span> = <span class="keyword">new</span> <span class="title class_">Uint8Array</span>([~<span class="number">1</span>, ~<span class="number">2</span>, ~<span class="number">4</span>, ~<span class="number">8</span>, ~<span class="number">16</span>, ~<span class="number">32</span>, ~<span class="number">64</span>, ~<span class="number">128</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="9-6-Summary"><a href="#9-6-Summary" class="headerlink" title="9.6 Summary"></a>9.6 Summary</h2><p>This chapter has explained the key features of JavaScript classes:</p>
<blockquote>
<p>本章说明了 JavaScript 类的主要功能：</p>
</blockquote>
<p>Objects that are members of the same class inherit properties from the same prototype object. The prototype object is the key feature of JavaScript classes, and it is possible to define classes with nothing more than the Object.create() method.</p>
<blockquote>
<p>同一类的成员对象从同一原型对象继承属性。原型对象是 JavaScript 类的关键特性，只有 Object.create() 方法可以定义类。</p>
</blockquote>
<p>Prior to ES6, classes were more typically defined by first defining a constructor function. Functions created with the function keyword have a prototype property, and the value of this property is an object that is used as the prototype of all objects created when the function is invoked with new as a constructor. By initializing this prototype object, you can define the shared methods of your class. Although the prototype object is the key feature of the class, the constructor function is the public identity of the class.</p>
<blockquote>
<p>在 ES6 之前，典型的类定义先定义构造函数。使用 function 关键字创建的函数具有原型属性，this 属性的值是使用 new 将函数用作构造函数调用时创建的对象的原型对象。通过初始化此原型对象，可以定义类的共享方法。虽然原型对象是类的关键特性，但构造函数是类的公共标识。</p>
</blockquote>
<p>ES6 introduces a class keyword that makes it easier to define classes, but under the hood, constructor and prototype mechanism remains the same.</p>
<blockquote>
<p>ES6 引入了一个 class 关键字，它使定义类更加容易，但它只是个语法糖，构造函数和原型机制保持不变。</p>
</blockquote>
<p>Subclasses are defined using the extends keyword in a class declaration.</p>
<blockquote>
<p>子类使用类声明中的 extends 关键字定义。</p>
</blockquote>
<p>Subclasses can invoke the constructor of their superclass or overridden methods of their superclass with the super keyword.</p>
<blockquote>
<p>子类可以使用 super 关键字调用其父类的构造函数或父类的重写方法。</p>
</blockquote>
<hr>
<ol>
<li><p>Except functions returned by the ES5 Function.bind() method. Bound functions have no prototype property of their own, but they use the prototype of the underlying function if they are invoked as constructors.</p>
</li>
<li><p>See Design Patterns (Addison-Wesley Professional) by Erich Gamma et al. or Effective Java (Addison-Wesley Professional) by Joshua Bloch, for example.</p>
</li>
</ol>
<blockquote>
<ol>
<li>除了 ES5 Function.bind() 方法返回的函数。绑定函数没有自己的原型属性，但如果它们作为构造函数调用，则它们使用基础函数的原型。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>例如，见《Design Patterns (Addison-Wesley Professional)》作者 Erich Gamma 等，或者《Effective Java (Addison-Wesley Professional)》作者 Joshua Bloch。</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Jack hou</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/')">第9章 类</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div><div class="reward-link mode"><a class="reward-link-button" href="/wechat/"><i class="anzhiyufont anzhiyu-icon-plant-fill"></i>运营模式与责任</a></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=第9章 类&amp;url=http://www.houyanbin.com/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch9/&amp;pic=https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.houyanbin.com" target="_blank">Jackhou Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>《JavaScript权威指南》<span class="tagsPageCount">17</span></a><a class="post-meta__box__tags" href="/tags/JavaScript/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>JavaScript<span class="tagsPageCount">17</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch10/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover10.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">第10章 模块</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第8章 函数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch1/" title="第1章 JavaScript 概述"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第1章 JavaScript 概述</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch12/" title="第12章 迭代器和生成器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第12章 迭代器和生成器</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch10/" title="第10章 模块"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第10章 模块</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch11/" title="第11章 JavaScript 标准库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第11章 JavaScript 标准库</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch14/" title="第14章 元编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第14章 元编程</div></div></a></div><div><a href="/2023/04/26/Books/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/ch17/" title="第17章 JavaScript 工具和扩展"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-04-26</div><div class="title">第17章 JavaScript 工具和扩展</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">Hi，这是我的博客网站，欢迎你能到访~</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">我会在这里分享我的<b style="color:#fff">技术知识</b>、<b style="color:#fff">日常生活</b>和<b style="color:#fff">人生经验。</b></div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Jack hou</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/YingxueSec" target="_blank" title="Github"><i class="fab fa-github faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/478589474" target="_blank" title="BiliBili"><i class="fa-brands fa-bilibili faa-tada"></i></a><a class="social-icon faa-parent animated-hover" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=jackhou921@qq.com" target="_blank" title="Email"><i class="anzhiyufont anzhiyu-icon-envelope"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/index/wxgzh1.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-Classes-and-Prototypes"><span class="toc-text">9.1 Classes and Prototypes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Classes-and-Constructors"><span class="toc-text">9.2 Classes and Constructors</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-Constructors-Class-Identity-and-instanceof"><span class="toc-text">9.2.1 Constructors, Class Identity, and instanceof</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-The-constructor-Property"><span class="toc-text">9.2.2 The constructor Property</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-Classes-with-the-class-Keyword"><span class="toc-text">9.3 Classes with the class Keyword</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-Static-Methods"><span class="toc-text">9.3.1 Static Methods</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-Getters-Setters-and-other-Method-Forms"><span class="toc-text">9.3.2 Getters, Setters, and other Method Forms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-Public-Private-and-Static-Fields"><span class="toc-text">9.3.3 Public, Private, and Static Fields</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-Example-A-Complex-Number-Class"><span class="toc-text">9.3.4 Example: A Complex Number Class</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-Adding-Methods-to-Existing-Classes"><span class="toc-text">9.4 Adding Methods to Existing Classes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-Subclasses"><span class="toc-text">9.5 Subclasses</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-1-Subclasses-and-Prototypes"><span class="toc-text">9.5.1 Subclasses and Prototypes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-2-Subclasses-with-extends-and-super"><span class="toc-text">9.5.2 Subclasses with extends and super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-3-Delegation-Instead-of-Inheritance"><span class="toc-text">9.5.3 Delegation Instead of Inheritance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-4-Class-Hierarchies-and-Abstract-Classes"><span class="toc-text">9.5.4 Class Hierarchies and Abstract Classes</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-Summary"><span class="toc-text">9.6 Summary</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="做情人真的没有好下场吗？"/></a><div class="content"><a class="title" href="/2023/08/15/%E5%8C%BF%E5%90%8D/%E6%83%85%E4%BA%BA/" title="做情人真的没有好下场吗？">做情人真的没有好下场吗？</a><time datetime="2023-08-14T16:00:00.000Z" title="发表于 2023-08-15 00:00:00">2023-08-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="不爱前行"/></a><div class="content"><a class="title" href="/2023/07/30/%E5%8C%BF%E5%90%8D/%E4%B8%8D%E7%88%B1%E6%80%8E%E4%B9%88%E8%B5%B0%E4%B8%8B%E5%8E%BB/" title="不爱前行">不爱前行</a><time datetime="2023-07-29T16:00:00.000Z" title="发表于 2023-07-30 00:00:00">2023-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="租房时光"/></a><div class="content"><a class="title" href="/2023/07/22/%E5%8C%BF%E5%90%8D/%E7%A7%9F%E6%88%BF%E6%97%B6%E5%85%89/" title="租房时光">租房时光</a><time datetime="2023-07-21T16:00:00.000Z" title="发表于 2023-07-22 00:00:00">2023-07-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="故宫记"/></a><div class="content"><a class="title" href="/2023/06/11/%E6%97%85%E8%A1%8C/%E6%95%85%E5%AE%AB%E8%AE%B0/" title="故宫记">故宫记</a><time datetime="2023-06-10T16:00:00.000Z" title="发表于 2023-06-11 00:00:00">2023-06-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://imagesblog.oss-cn-hangzhou.aliyuncs.com/themes/post/default_cover9.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信息收集道道之外网信息收集"/></a><div class="content"><a class="title" href="/2023/05/29/%E5%AE%89%E5%85%A8/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E9%81%93%E9%81%93%E4%B9%8B%E5%A4%96%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" title="信息收集道道之外网信息收集">信息收集道道之外网信息收集</a><time datetime="2023-05-28T16:00:00.000Z" title="发表于 2023-05-29 00:00:00">2023-05-29</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 By <a class="footer-bar-link" href="/" title="Jack hou" target="_blank">Jack hou</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://www.houyanbin.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.png" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=8868465080&amp;server=tencent&amp;type=0"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Article/" style="font-size: 0.88rem; color: rgb(103, 168, 66);">Article<sup>4</sup></a><a href="/tags/CSRF/" style="font-size: 0.88rem; color: rgb(111, 81, 145);">CSRF<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem; color: rgb(159, 155, 105);">Git<sup>1</sup></a><a href="/tags/Java/" style="font-size: 0.88rem; color: rgb(57, 31, 145);">Java<sup>3</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem; color: rgb(40, 64, 157);">JavaScript<sup>17</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem; color: rgb(85, 160, 94);">Linux<sup>1</sup></a><a href="/tags/Pikachu/" style="font-size: 0.88rem; color: rgb(138, 133, 182);">Pikachu<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem; color: rgb(113, 61, 3);">SQL<sup>2</sup></a><a href="/tags/XAUUSD/" style="font-size: 0.88rem; color: rgb(134, 2, 128);">XAUUSD<sup>1</sup></a><a href="/tags/XSS/" style="font-size: 0.88rem; color: rgb(143, 143, 166);">XSS<sup>2</sup></a><a href="/tags/%E3%80%8AJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B/" style="font-size: 0.88rem; color: rgb(89, 87, 129);">《JavaScript权威指南》<sup>17</sup></a><a href="/tags/%E5%8C%BF%E5%90%8D/" style="font-size: 0.88rem; color: rgb(152, 171, 35);">匿名<sup>3</sup></a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 0.88rem; color: rgb(199, 64, 100);">博客<sup>10</sup></a><a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size: 0.88rem; color: rgb(196, 169, 136);">安全<sup>20</sup></a><a href="/tags/%E6%94%AF%E4%BB%98/" style="font-size: 0.88rem; color: rgb(116, 63, 156);">支付<sup>1</sup></a><a href="/tags/%E6%94%BB%E9%98%B2/" style="font-size: 0.88rem; color: rgb(139, 47, 168);">攻防<sup>1</sup></a><a href="/tags/%E6%97%85%E8%A1%8C/" style="font-size: 0.88rem; color: rgb(143, 83, 88);">旅行<sup>1</sup></a><a href="/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 0.88rem; color: rgb(63, 86, 36);">虚拟机<sup>4</sup></a><a href="/tags/%E8%B6%8A%E6%9D%83/" style="font-size: 0.88rem; color: rgb(92, 190, 137);">越权<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8868465080" server="tencent" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8868465080&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("4/15/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Jack hou 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("4/15/2023 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.houyanbin.com/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo.houyanbin.com/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.25/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anzhiy.cn";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>